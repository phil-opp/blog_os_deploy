<!doctype html><html lang=ja><head><meta charset=UTF-8><meta content=yes name=apple-mobile-web-app-capable><meta content="width=device-width,initial-scale=1" name=viewport><meta content="light dark" name=color-scheme><meta content="この記事では、no_stdな実行環境における単体テスト (unit test) と結合テスト (integration test) について学びます。Rustではカスタムテストフレームワークがサポートされているので、これを使ってカーネルの中でテスト関数を実行します。QEMUの外へとテストの結果を通知…" name=description><meta content="Philipp Oppermann" name=author><link href=https://os.phil-opp.com/ja/testing/ rel=canonical><link href=/css/edition-2/main.css rel=stylesheet><link title="RSS feed for os.phil-opp.com" href=https://os.phil-opp.com/rss.xml rel=alternate type=application/rss+xml><script>let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }</script><script async src=/js/edition-2/main.js></script><title>テスト | Writing an OS in Rust</title><body><div class="container content"><header class=masthead><div style=position:relative><h2 class=masthead-title><a href=https://os.phil-opp.com title=Home>Writing an OS in Rust</a></h2><p><small>Philipp Oppermann's blog</small><aside id=all-posts-link><a title="All Posts" href=https://os.phil-opp.com/ja>« すべての記事へ</a></aside></div></header><div class=theme-switch><div title="Switch between light and dark theme" class=light-switch onclick=toggle_lights()></div><div title="Clear the theme override and go back to the system theme" class=light-switch-reset onclick=clear_theme_override()></div></div><div><aside id=toc-aside><h2>目次</h2><ol><li><a href=#konoji-shi-wodu-muqian-ni>この記事を読む前に</a><li><a href=#rustniokerutesuto>Rustにおけるテスト</a> <ol><li><a href=#du-zi-notesutohuremuwaku>独自のテストフレームワーク</a></ol><li><a href=#qemuwozhong-liao-suru>QEMUを終了する</a> <ol><li><a href=#i-opoto>I/Oポート</a><li><a href=#zhong-liao-debaisu-woshi-u>「終了デバイス」を使う</a><li><a href=#cheng-gong-nozhong-liao-kodo>成功の終了コード</a></ol><li><a href=#konsorunichu-li-suru>コンソールに出力する</a> <ol><li><a href=#siriarupoto>シリアルポート</a><li><a href=#qemunoyin-shu>QEMUの引数</a><li><a href=#panitukushi-noerametuseziwochu-li-suru>パニック時のエラーメッセージを出力する</a><li><a href=#qemuwoyin-su>QEMUを隠す</a><li><a href=#taimuauto>タイムアウト</a><li><a href=#chu-li-ji-neng-wozi-dong-decha-ru-suru>出力機能を自動で挿入する</a></ol><li><a href=#vgabatuhuawotesutosuru>VGAバッファをテストする</a><li><a href=#jie-he-tesuto>結合テスト</a> <ol><li><a href=#raiburariwozuo-ru>ライブラリを作る</a><li><a href=#jie-he-tesutowowan-cheng-saseru>結合テストを完成させる</a><li><a href=#jin-hou-notesuto>今後のテスト</a><li><a href=#panitukusinakerebanaranaitesuto>パニックしなければならないテスト</a><li><a href=#hanesu-harness-nonaitesuto>ハーネス (harness) のないテスト</a></ol><li><a href=#matome>まとめ</a><li><a href=#ci-ha>次は？</a><li class=toc-comments-link><a href=#comments>コメント</a></ol></aside><main><div><h1>テスト</h1><time class=post-date datetime=2019-04-27> Apr 27, 2019 </time></div><div class=warning><p><b>この記事は翻訳されたものです：</b> この記事は<strong><a href=https://os.phil-opp.com/testing/>Testing</a></strong>をコミュニティの手により翻訳したものです。そのため、翻訳が完全・最新でなかったり、原文にない誤りを含んでいる可能性があります。問題があれば<a href=https://github.com/phil-opp/blog_os/issues/906>このissue</a>上で報告してください！<p>翻訳者： <a href=https://github.com/woodyZootopia>@woodyZootopia</a> 及び <a href=https://github.com/JohnTitor>@JohnTitor</a>.</div><div><p>この記事では、<code>no_std</code>な実行環境における<ruby>単体テスト<rp> (<rt>unit test<rp>) </ruby>と<ruby>結合テスト<rp> (<rt>integration test<rp>) </ruby>について学びます。Rustではカスタムテストフレームワークがサポートされているので、これを使ってカーネルの中でテスト関数を実行します。QEMUの外へとテストの結果を通知するため、QEMUと<code>bootimage</code>の様々な機能を使います。</p><span id=continue-reading></span><p>このブログの内容は <a href=https://github.com/phil-opp/blog_os>GitHub</a> 上で公開・開発されています。何か問題や質問などがあれば issue をたててください (訳注: リンクは原文(英語)のものになります)。また<a href=https://os.phil-opp.com/ja/testing/#comments>こちら</a>にコメントを残すこともできます。この記事の完全なソースコードは<a href=https://github.com/phil-opp/blog_os/tree/post-04><code>post-04</code> ブランチ</a>にあります。<details id=toc-inline><summary><b>目次</b></summary> <ul><li><a href=#konoji-shi-wodu-muqian-ni>この記事を読む前に</a><li><a href=#rustniokerutesuto>Rustにおけるテスト</a> <ul><li><a href=#du-zi-notesutohuremuwaku>独自のテストフレームワーク</a></ul><li><a href=#qemuwozhong-liao-suru>QEMUを終了する</a> <ul><li><a href=#i-opoto>I/Oポート</a><li><a href=#zhong-liao-debaisu-woshi-u>「終了デバイス」を使う</a><li><a href=#cheng-gong-nozhong-liao-kodo>成功の終了コード</a></ul><li><a href=#konsorunichu-li-suru>コンソールに出力する</a> <ul><li><a href=#siriarupoto>シリアルポート</a><li><a href=#qemunoyin-shu>QEMUの引数</a><li><a href=#panitukushi-noerametuseziwochu-li-suru>パニック時のエラーメッセージを出力する</a><li><a href=#qemuwoyin-su>QEMUを隠す</a><li><a href=#taimuauto>タイムアウト</a><li><a href=#chu-li-ji-neng-wozi-dong-decha-ru-suru>出力機能を自動で挿入する</a></ul><li><a href=#vgabatuhuawotesutosuru>VGAバッファをテストする</a><li><a href=#jie-he-tesuto>結合テスト</a> <ul><li><a href=#raiburariwozuo-ru>ライブラリを作る</a><li><a href=#jie-he-tesutowowan-cheng-saseru>結合テストを完成させる</a><li><a href=#jin-hou-notesuto>今後のテスト</a><li><a href=#panitukusinakerebanaranaitesuto>パニックしなければならないテスト</a><li><a href=#hanesu-harness-nonaitesuto>ハーネス (harness) のないテスト</a></ul><li><a href=#matome>まとめ</a><li><a href=#ci-ha>次は？</a><li class=toc-comments-link><a href=#comments>コメント</a></ul></details><h2 id=konoji-shi-wodu-muqian-ni><a aria-label="Anchor link for: konoji-shi-wodu-muqian-ni" class=zola-anchor href=#konoji-shi-wodu-muqian-ni>🔗</a>この記事を読む前に</h2><p>この記事は、（古い版の）<a href=https://os.phil-opp.com/unit-testing/>単体テスト</a>と<a href=https://os.phil-opp.com/integration-tests/>結合テスト</a>の記事を置き換えるものです。この記事は、あなたが<a href=https://os.phil-opp.com/ja/minimal-rust-kernel/>最小のカーネル</a>の記事を2019-04-27以降に読んだことを前提にしています。主に、あなたの<code>.cargo/config.toml</code>ファイルが<a href=https://os.phil-opp.com/ja/minimal-rust-kernel/#biao-zhun-notagetutowosetutosuru>標準のターゲットを設定して</a>おり、<a href=https://os.phil-opp.com/ja/minimal-rust-kernel/#cargo-runwoshi-u>ランナー実行ファイルを定義している</a>ことが条件となります。<div class=note><p><strong>訳注:</strong> <a href=https://os.phil-opp.com/ja/minimal-rust-kernel/>最小のカーネル</a>の記事が日本語に翻訳されたのはこの日より後なので、あなたがこのサイトを日本語で閲覧している場合は特に問題はありません。</div><h2 id=rustniokerutesuto><a aria-label="Anchor link for: rustniokerutesuto" class=zola-anchor href=#rustniokerutesuto>🔗</a>Rustにおけるテスト</h2><p>Rustには<a href=https://doc.rust-jp.rs/book-ja/ch11-00-testing.html>テストフレームワークが組み込まれて</a>おり、特別な設定なしに単体テストを走らせることができます。何らかの結果をアサーションを使って確認する関数を作り、その関数のヘッダに<code>#[test]</code>属性をつけるだけです。その上で<code>cargo test</code>を実行すると、あなたのクレートのすべてのテスト関数を自動で見つけて実行してくれます。<p>残念なことに、私達のカーネルのような<code>no_std</code>のアプリケーションにとっては、テストは少しややこしくなります。問題なのは、Rustのテストフレームワークは組み込みの<a href=https://doc.rust-lang.org/test/index.html><code>test</code></a>ライブラリを内部で使っており、これは標準ライブラリに依存しているということです。つまり、私達の<code>#[no_std]</code>のカーネルには標準のテストフレームワークは使えないのです。<p>私達のプロジェクト内で<code>cargo test</code>を実行しようとすればそれがわかります：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> cargo test
</span><span>   Compiling blog_os v0.1.0 (/…/blog_os)
</span><span>error[E0463]: can't find crate for `test`
</span></code></pre><p><code>test</code>クレートは標準ライブラリに依存しているので、私達のベアメタルのターゲットでは使えません。<code>test</code>クレートを<code>#[no_std]</code>環境に持ってくるということは<a href=https://github.com/japaric/utest>不可能ではない</a>のですが、非常に不安定であり、また<code>panic</code>マクロの再定義といった<ruby>技巧<rp> (<rt>ハック<rp>) </ruby>が必要になってしまいます。<h3 id=du-zi-notesutohuremuwaku><a aria-label="Anchor link for: du-zi-notesutohuremuwaku" class=zola-anchor href=#du-zi-notesutohuremuwaku>🔗</a>独自のテストフレームワーク</h3><p>ありがたいことに、Rustでは、不安定な<a href=https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html><ruby><code>custom_test_frameworks</code><rp> (<rt>独自のテストフレームワーク<rp>) </ruby></a>機能を使えば標準のテストフレームワークを置き換えることができます。この機能には外部ライブラリは必要なく、したがって<code>#[no_std]</code>環境でも動きます。これは、<code>#[test_case]</code>属性をつけられたすべての関数のリストを引数としてユーザの指定した実行関数を呼び出すことで働きます。こうすることで、（実行関数の）実装内容によってテストプロセスを最大限コントロールできるようにしているのです。<p>標準のテストフレームワークと比べた欠点は、<a href=https://doc.rust-jp.rs/book-ja/ch11-01-writing-tests.html#should_panic%E3%81%A7%E3%83%91%E3%83%8B%E3%83%83%E3%82%AF%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B><code>should_panic</code>テスト</a>のような多くの高度な機能が利用できないということです。それらの機能が必要なら、自分で実装して提供してください、というわけです。これは私達にとって全く申し分のないことで、というのも、私達の非常に特殊な実行環境では、それらの高度な機能の標準の実装はいずれにせようまく働かないだろうからです。例えば、<code>#[should_panic]</code>属性はパニックを検知するためにスタックアンワインドを使いますが、これは私達のカーネルでは無効化しています。<p>私達のカーネルのための独自テストフレームワークを実装するため、以下を<code>main.rs</code>に追記します：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>
</span><span>#[cfg(test)]
</span><span style=color:#569cd6;>fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style=color:#d69d85;>"Running </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;> tests"</span><span>, tests.len());
</span><span>    </span><span style=color:#569cd6;>for</span><span> test </span><span style=color:#569cd6;>in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>}
</span></code></pre><p>このランナーは短いデバッグメッセージを表示し、リスト内のそれぞれの関数を呼び出すだけです。引数の型である<code>&[&dyn Fn()]</code>は、<a href=https://doc.rust-lang.org/std/ops/trait.Fn.html>Fn()</a>トレイトの<a href=https://doc.rust-jp.rs/book-ja/ch17-02-trait-objects.html>トレイトオブジェクト</a>参照の<a href=https://doc.rust-lang.org/std/primitive.slice.html>スライス</a>です。これは要するに、関数のように呼び出せる型への参照のリストです。この (test_runner) 関数はテストでない実行のときには意味がないので、<code>#[cfg(test)]</code>属性を使って、テスト時にのみこれがインクルードされるようにします。<p><code>cargo test</code>を実行すると、今度は成功しているはずです（もし失敗したなら、下の補足を読んでください）。しかし、依然として、<code>test_runner</code>からのメッセージではなく “Hello World” が表示されてしまっています。この理由は、<code>_start</code>関数がまだエントリポイントとして使われているからです。「独自のテストフレームワーク」機能は<code>test_runner</code>を呼び出す<code>main</code>関数を生成するのですが、私達は<code>#[no_main]</code>属性を使っており、独自のエントリポイントを与えてしまっているため、このmain関数は無視されてしまうのです。<div class=warning><p><strong>補足:</strong> 現在、cargoには<code>cargo test</code>を実行すると、いくらかのケースにおいて “duplicate lang item” エラーになってしまうバグが存在します。これは、<code>Cargo.toml</code>内のプロファイルにおいて<code>panic = "abort"</code>を設定していたときに起こります。これを取り除けば<code>cargo test</code>はうまくいくはずです。これについて、より詳しく知りたい場合は<a href=https://github.com/rust-lang/cargo/issues/7359>cargoのissue</a>を読んでください。</div><p>これを修正するために、まず生成される関数の名前を<code>reexport_test_harness_main</code>属性を使って<code>main</code>とは違うものに変える必要があります。そして、その<ruby>改名<rp> (<rt>リネーム<rp>) </ruby>された関数を<code>_start</code>関数から呼び出せばよいです。<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#![reexport_test_harness_main </span><span style=color:#569cd6;>= </span><span style=color:#d69d85;>"test_main"</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"Hello World</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#d69d85;>"!"</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>テストフレームワークのエントリ関数の名前を<code>test_main</code>に設定し、私達の<code>_start</code>エントリポイントから呼び出しています。<code>test_main</code>関数は通常の実行時には生成されていないので、<a href=https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html>条件付きコンパイル</a>を用いて、テスト時にのみこの関数への呼び出しが追記されるようにしています。<p><code>cargo test</code>を実行すると、 <code>test_runner</code>からの “Running 0 tests” というメッセージが画面に表示されます。これで、テスト関数を作り始める準備ができました：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>trivial_assertion() {
</span><span>    print!(</span><span style=color:#d69d85;>"trivial assertion... "</span><span>); </span><span style=color:#608b4e;>// "些末なアサーション……"
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>1</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>    println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>}
</span></code></pre><p><code>cargo test</code>を実行すると、以下の出力を得ます：<p><img alt="QEMU printing “Hello World!”, “Running 1 tests”, and “trivial assertion… [ok]”" src=qemu-test-runner-output.png><p>今、<code>test_runner</code>関数に渡される<code>test</code>のスライスは、<code>trivial_assertion</code>関数への参照を保持しています。<code>trivial assertion... [ok]</code>という画面の出力から、テストが呼び出され成功したことがわかります。<p>テストを実行したあとは、<code>test_runner</code>から<code>test_main</code>関数へとリターンし、さらに<code>_start</code>エントリポイント関数へとリターンします。エントリポイント関数がリターンすることは認められていないので、<code>_start</code>の最後では無限ループに入ります。しかし、<code>cargo test</code>にはすべてのテストを実行し終わった後に終了してほしいので、これは問題です。<h2 id=qemuwozhong-liao-suru><a aria-label="Anchor link for: qemuwozhong-liao-suru" class=zola-anchor href=#qemuwozhong-liao-suru>🔗</a>QEMUを終了する</h2><p>今の所、<code>_start</code>関数の最後で無限ループがあるので、<code>cargo test</code>を実行するたびにQEMUを手動で終了しないといけません。ユーザによる入力などのないスクリプトでも<code>cargo test</code>を実行したいので、これは不都合です。これに対する綺麗な解決法はOSをシャットダウンする適切な方法を実装することでしょう。これは<a href=https://wiki.osdev.org/APM>APM</a>か<a href=https://wiki.osdev.org/ACPI>ACPI</a>というパワーマネジメント標準規格へのサポートを実装する必要があるので、残念なことに比較的複雑です。<p>しかし嬉しいことに、ある「脱出口」があるのです。QEMUは特殊な<code>isa-debug-exit</code>デバイスをサポートしており、これを使うとゲストシステムから簡単にQEMUを終了できます。これを有効化するためには、QEMUに<code>-device</code>引数を渡す必要があります。これは<code>Cargo.toml</code>に<code>package.metadata.bootimage.test-args</code>設定キーを追加することで行えます。<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>package.metadata.bootimage</span><span>]
</span><span style=color:#569cd6;>test-args </span><span>= [</span><span style=color:#d69d85;>"-device"</span><span>, </span><span style=color:#d69d85;>"isa-debug-exit,iobase=0xf4,iosize=0x04"</span><span>]
</span></code></pre><p><code>bootimage runner</code>は、<code>test-args</code>をすべてのテスト実行可能ファイルの標準QEMUコマンドに追加します。通常の<code>cargo run</code>のとき、これらの引数は無視されます。<p>デバイス名 (<code>isa-debug-exit</code>) に加え、カーネルからそのデバイスにたどり着くための <strong>I/Oポート</strong> を指定する<code>iobase</code>と<code>iosize</code>という2つのパラメータを渡しています。<h3 id=i-opoto><a aria-label="Anchor link for: i-opoto" class=zola-anchor href=#i-opoto>🔗</a>I/Oポート</h3><p>CPUと<ruby>周辺機器<rp> (<rt>ペリフェラル<rp>) </ruby>が通信するやり方には、 <strong><ruby>memory-mapped<rp> (<rt>メモリマップされた<rp>) </ruby> I/O</strong> と <strong><ruby>port-mapped<rp> (<rt>ポートマップされた<rp>) </ruby> I/O</strong> の2つがあります。memory-mapped I/Oについては、すでに<a href=https://os.phil-opp.com/ja/vga-text-mode/>VGAテキストバッファ</a>にメモリアドレス<code>0xb8000</code>を使ってアクセスしたときに使っています。このアドレスはRAMではなく、VGAデバイス上にあるメモリにマップされているのです。<p>一方、port-mapped I/Oは通信に別個のI/Oバスを使います。接続されたそれぞれの周辺機器は1つ以上のポート番号を持っています。それらのI/Oポートと通信するために、<code>in</code>と<code>out</code>という特別なCPU命令があり、これらはポート番号と1バイトのデータを受け取ります（<code>u16</code>や<code>u32</code>を送信できる、これらの亜種も存在します）。<p><code>isa-debug-exit</code>はこのport-mapped I/Oを使います。<code>iobase</code>パラメータはどのポートにこのデバイスが繋がれているのか（<code>0xf4</code>はx86のI/Oバスにおいて<a href=https://wiki.osdev.org/I/O_Ports#The_list>普通使われない</a>ポートです）を、<code>iosize</code>はポートの大きさ（<code>0x04</code>は4バイトを意味します）を指定します。<h3 id=zhong-liao-debaisu-woshi-u><a aria-label="Anchor link for: zhong-liao-debaisu-woshi-u" class=zola-anchor href=#zhong-liao-debaisu-woshi-u>🔗</a>「終了デバイス」を使う</h3><p><code>isa-debug-exit</code>の機能は非常に単純です。値<code>value</code>が<code>iobase</code>により指定されたI/Oポートに書き込まれたら、QEMUは<a href=https://ja.wikipedia.org/wiki/%E7%B5%82%E4%BA%86%E3%82%B9%E3%83%86%E3%83%BC%E3%82%BF%E3%82%B9>終了ステータス</a>を<code>(value << 1) | 1</code>にして終了します。なので、このポートに<code>0</code>を書き込むと、QEMUは終了ステータス<code>(0 << 1) | 1 = 1</code>で、<code>1</code>を書き込むと終了ステータス<code>(1 << 1) | 1 = 3</code>で終了します。<p><code>in</code>と<code>out</code>のアセンブリ命令を手動で呼び出す代わりに、<a href=https://docs.rs/x86_64/0.14.2/x86_64/><code>x86_64</code></a>クレートによって提供される<ruby>abstraction<rp> (<rt>抽象化されたもの<rp>) </ruby>を使います。このクレートへの依存を追加するため、<code>Cargo.toml</code>の<code>dependencies</code>セクションにこれを追加しましょう：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>x86_64 </span><span>= </span><span style=color:#d69d85;>"0.14.2"
</span></code></pre><p>これで、このクレートによって提供される<a href=https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html><code>Port</code></a>型を使って<code>exit_qemu</code>関数を作ることができます。<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style=color:#569cd6;>pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style=color:#b5cea8;>0x10</span><span>,
</span><span>    Failed = </span><span style=color:#b5cea8;>0x11</span><span>,
</span><span>}
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style=color:#569cd6;>use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>        </span><span style=color:#569cd6;>let mut</span><span> port = Port::new(</span><span style=color:#b5cea8;>0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style=color:#569cd6;>as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>この関数は新しい<a href=https://docs.rs/x86_64/0.14.2/x86_64/instructions/port/struct.Port.html><code>Port</code></a>を<code>0xf4</code>（<code>isa-debug-exit</code>デバイスの<code>iobase</code>です）に作ります。そして、渡された終了コードをポートに書き込みます。<code>isa-device-exit</code>デバイスの<code>iosize</code>に4バイトを指定していたので、<code>u32</code>を使うことにします。I/Oポートへの書き込みは一般にあらゆる振る舞いを引き起こしうるので、これらの命令は両方unsafeです。<p>終了ステータスを指定するために、<code>QemuExitCode</code>enumを作ります。成功したら成功（<code>Success</code>）の終了コードで、そうでなければ失敗（<code>Failed</code>）の終了コードで終了しようというわけです。enumは<code>#[repr(u32)]</code>をつけることで、それぞれのヴァリアントが<code>u32</code>の整数として表されるようにしています。終了コード<code>0x10</code>を成功に、<code>0x11</code>を失敗に使います。終了コードの実際の値は、QEMUの標準の終了コードと被ってしまわない限りはなんでも構いません。例えば、成功の終了コードに<code>0</code>を使うと、変換後<code>(0 << 1) | 1 = 1</code>になってしまい、これはQEMUが実行に失敗したときの標準終了コードなのでよくありません。QEMUのエラーとテスト実行の成功が区別できなくなります。<p>というわけで、<code>test_runner</code>を更新して、すべてのテストが実行されたあとでQEMUを終了するようにできますね：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#569cd6;>fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Fn()]) {
</span><span>    println!(</span><span style=color:#d69d85;>"Running </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;> tests"</span><span>, tests.len());
</span><span>    </span><span style=color:#569cd6;>for</span><span> test </span><span style=color:#569cd6;>in</span><span> tests {
</span><span>        test();
</span><span>    }
</span><span>    </span><span style=color:#608b4e;>/// new
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre><p><code>cargo test</code>を実行すると、QEMUはテスト実行後即座に閉じるのがわかります。しかし、問題は、<code>Success</code>の終了コードを渡したのに、<code>cargo test</code>はテストが失敗したと解釈することです：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-5804fc7d2dd4c9be
</span><span>Building bootloader
</span><span>   Compiling bootloader v0.5.3 (/home/philipp/Documents/bootloader)
</span><span>    Finished release [optimized + debuginfo] target(s) in 1.07s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,
</span><span>    iosize=0x04`
</span><span>error: test failed, to rerun pass '--bin blog_os'
</span></code></pre><p>問題は、<code>cargo test</code>が<code>0</code>でないすべてのエラーコードを失敗と解釈してしまうことです。<h3 id=cheng-gong-nozhong-liao-kodo><a aria-label="Anchor link for: cheng-gong-nozhong-liao-kodo" class=zola-anchor href=#cheng-gong-nozhong-liao-kodo>🔗</a>成功の終了コード</h3><p>これを解決するために、<code>bootimage</code>は指定された終了コードを<code>0</code>へとマップする設定キー、<code>test-success-exit-code</code>を提供しています：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span>[</span><span style=color:#808080;>package.metadata.bootimage</span><span>]
</span><span style=color:#569cd6;>test-args </span><span>= [</span><span style=color:#ff3333;>…</span><span>]
</span><span style=color:#569cd6;>test-success-exit-code </span><span>= </span><span style=color:#b5cea8;>33         </span><span style=color:#608b4e;># (0x10 << 1) | 1
</span></code></pre><p>この設定を使うと、<code>bootimage</code>は私達の出した成功の終了コードを、終了コード0へとマップするので、<code>cargo test</code>は正しく成功を認識し、テストを失敗したと見做さなくなります。<p>これで私達のテストランナーは、自動でQEMUを閉じ、結果を報告するようになりました。しかし、QEMUの画面が非常に短い時間開くのは見えますが、短すぎて結果が読めません。QEMUが終了したあともテストの結果が見られるように、コンソールに出力できたら良さそうです。<h2 id=konsorunichu-li-suru><a aria-label="Anchor link for: konsorunichu-li-suru" class=zola-anchor href=#konsorunichu-li-suru>🔗</a>コンソールに出力する</h2><p>テストの結果をコンソールで見るためには、カーネルからホストシステムにどうにかしてデータを送る必要があります。これを達成する方法は色々あり、例えばTCPネットワークインターフェースを通じてデータを送るというのが考えられます。しかし、ネットワークスタックを設定するのは非常に複雑なタスクなので、より簡単な解決策を取ることにしましょう。<h3 id=siriarupoto><a aria-label="Anchor link for: siriarupoto" class=zola-anchor href=#siriarupoto>🔗</a>シリアルポート</h3><p>データを送る簡単な方法とは、<a href=https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%AB%E3%83%9D%E3%83%BC%E3%83%88>シリアルポート</a>という、最近のコンピュータにはもはや見られない古いインターフェース標準を使うことです。これはプログラムするのが簡単で、QEMUはシリアルを通じて送られたデータをホストの標準出力やファイルにリダイレクトすることができます。<p>シリアルインターフェースを実装しているチップは<a href=https://ja.wikipedia.org/wiki/UART>UART</a>と呼ばれています。x86には<a href=https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#UART_models>多くのUARTのモデルがありますが</a>、幸運なことに、それらの違いは私達の必要としないような高度な機能だけです。今日よく見られるUARTはすべて<a href=https://ja.wikipedia.org/wiki/16550_UART>16550 UART</a>に互換性があるので、このモデルを私達のテストフレームワークに使いましょう。<p><a href=https://docs.rs/uart_16550><code>uart_16550</code></a>クレートを使ってUARTを初期化しデータをシリアルポートを使って送信しましょう。これを依存先として追加するため、<code>Cargo.toml</code>と<code>main.rs</code>を書き換えます：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>uart_16550 </span><span>= </span><span style=color:#d69d85;>"0.2.0"
</span></code></pre><p><code>uart_16550</code>クレートにはUARTレジスタを表現する<code>SerialPort</code>構造体が含まれていますが、これのインスタンスは私達自身で作らなくてはいけません。そのため、以下の内容で新しい<code>serial</code>モジュールを作りましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span style=color:#569cd6;>mod </span><span>serial;
</span></code></pre><pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/serial.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>uart_16550::SerialPort;
</span><span style=color:#569cd6;>use </span><span>spin::Mutex;
</span><span style=color:#569cd6;>use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>pub static ref </span><span style=color:#b4cea8;>SERIAL1</span><span>: Mutex&LTSerialPort> = {
</span><span>        </span><span style=color:#569cd6;>let mut</span><span> serial_port = </span><span style=color:#569cd6;>unsafe </span><span>{ SerialPort::new(</span><span style=color:#b5cea8;>0x3F8</span><span>) };
</span><span>        serial_port.init();
</span><span>        Mutex::new(serial_port)
</span><span>    };
</span><span>}
</span></code></pre><p><a href=https://os.phil-opp.com/vga-text-mode/#lazy-statics>VGAテキストバッファ</a>のときのように、<code>lazy_static</code>とスピンロックを使って<code>static</code>なwriterインスタンスを作ります。<code>lazy_static</code>を使うことで、<code>init</code>メソッドが初回使用時にのみ呼び出されることを保証できます。<p><code>isa-debug-exit</code>デバイスのときと同じように、UARTはport I/Oを使ってプログラムされています。UARTはより複雑で、様々なデバイスレジスタ群をプログラムするために複数のI/Oポートを使います。unsafeな<code>SerialPort::new</code>関数はUARTの最初のI/Oポートを引数とします。この引数から、すべての必要なポートのアドレスを計算することができます。ポートアドレス<code>0x3F8</code>を渡していますが、これは最初のシリアルインターフェースの標準のポート番号です。<p>シリアルポートを簡単に使えるようにするために、<code>serial_print!</code>と<code>serial_println!</code>マクロを追加します：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[doc(hidden)]
</span><span style=color:#569cd6;>pub fn </span><span>_print(args: ::core::fmt::Arguments) {
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    </span><span style=color:#b4cea8;>SERIAL1</span><span>.lock().write_fmt(args).expect(</span><span style=color:#d69d85;>"Printing to serial failed"</span><span>);
</span><span>}
</span><span>
</span><span style=color:#608b4e;>/// シリアルインターフェースを通じてホストに出力する。
</span><span>#[macro_export]
</span><span>macro_rules! serial_print {
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>{
</span><span>        $crate::serial::_print(format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*));
</span><span>    };
</span><span>}
</span><span>
</span><span style=color:#608b4e;>/// シリアルインターフェースを通じてホストに出力し、改行を末尾に追加する。
</span><span>#[macro_export]
</span><span>macro_rules! serial_println {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>($crate::serial_print</span><span style=color:#569cd6;>!</span><span>(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>));
</span><span>    ($fmt:</span><span style=color:#569cd6;>expr</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::serial_print</span><span style=color:#569cd6;>!</span><span>(concat!($fmt, </span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>)));
</span><span>    ($fmt:</span><span style=color:#569cd6;>expr</span><span>, </span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::serial_print</span><span style=color:#569cd6;>!</span><span>(
</span><span>        concat!($fmt, </span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>), </span><span style=color:#569cd6;>$</span><span>($arg)*));
</span><span>}
</span></code></pre><p>この実装は私達の<code>print</code>および<code>println</code>マクロとよく似ています。<code>SerialPort</code>型はすでに<a href=https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html><code>fmt::Write</code></a>トレイトを実装しているので、自前の実装を提供する必要はありません。<p>これで、テストコードにおいてVGAテキストバッファの代わりにシリアルインターフェースに出力することができます：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style=color:#569cd6;>fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Running {} tests"</span><span>, tests.len());
</span><span>    […]
</span><span>}
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style=color:#d69d85;>"trivial assertion... "</span><span>);
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>1</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>}
</span></code></pre><p><code>#[macro_export]</code>属性を使うことで、<code>serial_println</code>マクロはルート<ruby>名前空間<rp> (<rt>namespace<rp>) </ruby>の直下に置かれるので、<code>use crate::serial::serial_println</code>とインポートするとうまくいかないということに注意してください。<h3 id=qemunoyin-shu><a aria-label="Anchor link for: qemunoyin-shu" class=zola-anchor href=#qemunoyin-shu>🔗</a>QEMUの引数</h3><p>QEMUからのシリアル出力を見るために、出力を標準出力にリダイレクトしたいので、<code>-serial</code>引数を使う必要があります。<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>package.metadata.bootimage</span><span>]
</span><span style=color:#569cd6;>test-args </span><span>= [
</span><span>    </span><span style=color:#d69d85;>"-device"</span><span>, </span><span style=color:#d69d85;>"isa-debug-exit,iobase=0xf4,iosize=0x04"</span><span>, </span><span style=color:#d69d85;>"-serial"</span><span>, </span><span style=color:#d69d85;>"stdio"
</span><span>]
</span></code></pre><p>これで<code>cargo test</code>を実行すると、テスト出力がコンソールに直接出力されているのが見えるでしょう：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [ok]
</span></code></pre><p>しかし、テストが失敗したときは、私達のパニックハンドラはまだ<code>println</code>を使っているので、出力がQEMUの中に出てしまいます。これをシミュレートするには、<code>trivial_assertion</code>テストの中のアサーションを<code>assert_eq!(0, 1)</code>に変えればよいです：<p><img alt="QEMU printing “Hello World!” and “panicked at ‘assertion failed: (left == right) left: 0, right: 1’, src/main.rs:55:5" src=qemu-failed-test.png><p>他のテスト出力がシリアルポートに出力されている一方、パニックメッセージはまだVGAバッファに出力されているのがわかります。このパニックメッセージは非常に役に立つので、コンソールでこのメッセージも見られたら非常に便利でしょう。<h3 id=panitukushi-noerametuseziwochu-li-suru><a aria-label="Anchor link for: panitukushi-noerametuseziwochu-li-suru" class=zola-anchor href=#panitukushi-noerametuseziwochu-li-suru>🔗</a>パニック時のエラーメッセージを出力する</h3><p>パニック時にQEMUをエラーメッセージとともに終了するためには、<a href=https://doc.rust-lang.org/1.30.0/book/first-edition/conditional-compilation.html>条件付きコンパイル</a>を使うことで、テスト時に異なるパニックハンドラを使うことができます：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// 前からあるパニックハンドラ
</span><span>#[cfg(not(test))] </span><span style=color:#608b4e;>// 新しく追加した属性
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#608b4e;>// テストモードで使うパニックハンドラ
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[failed]</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>);
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Error: {}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>テストパニックハンドラには<code>println</code>の代わりに<code>serial_println</code>を使い、そのあと失敗の終了コードでQEMUを終了します。コンパイラには、<code>exit_qemu</code>の呼び出しのあと<code>isa-debug-exit</code>デバイスがプログラムを終了させているということはわからないので、やはり最後に無限ループを入れないといけないことに注意してください。<p>これでQEMUはテストが失敗したときも終了し、コンソールに役に立つエラーメッセージを表示するようになります：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> cargo test
</span><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
</span><span>     Running target/x86_64-blog_os/debug/deps/blog_os-7b7c37b4ad62551a
</span><span>Building bootloader
</span><span>    Finished release [optimized + debuginfo] target(s) in 0.02s
</span><span>Running: `qemu-system-x86_64 -drive format=raw,file=/…/target/x86_64-blog_os/debug/
</span><span>    deps/bootimage-blog_os-7b7c37b4ad62551a.bin -device
</span><span>    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
</span><span>Running 1 tests
</span><span>trivial assertion... [failed]
</span><span>
</span><span>Error: panicked at 'assertion failed: `(left == right)`
</span><span>  left: `0`,
</span><span> right: `1`', src/main.rs:65:5
</span></code></pre><p>これですべてのテスト出力がコンソールで見られるようになったので、一瞬出てくるQEMUウィンドウはもはや必要ありません。ですので、これを完全に見えなくしてしまいましょう。<h3 id=qemuwoyin-su><a aria-label="Anchor link for: qemuwoyin-su" class=zola-anchor href=#qemuwoyin-su>🔗</a>QEMUを隠す</h3><p>すべてのテスト結果を<code>isa-debug-exit</code>デバイスとシリアルポートを使って通知できるので、QEMUのウィンドウはもはや必要ありません。これは、QEMUに<code>-display none</code>引数を渡すことで隠すことができます：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>package.metadata.bootimage</span><span>]
</span><span style=color:#569cd6;>test-args </span><span>= [
</span><span>    </span><span style=color:#d69d85;>"-device"</span><span>, </span><span style=color:#d69d85;>"isa-debug-exit,iobase=0xf4,iosize=0x04"</span><span>, </span><span style=color:#d69d85;>"-serial"</span><span>, </span><span style=color:#d69d85;>"stdio"</span><span>,
</span><span>    </span><span style=color:#d69d85;>"-display"</span><span>, </span><span style=color:#d69d85;>"none"
</span><span>]
</span></code></pre><p>これでQEMUは完全にバックグラウンドで実行するようになり、ウィンドウはもう開きません。これで、ジャマが減っただけでなく、私達のテストフレームワークがグラフィカルユーザーインターフェースのない環境――たとえばCIサービスや<a href=https://ja.wikipedia.org/wiki/Secure_Shell>SSH</a>接続――でも使えるようになりました。<h3 id=taimuauto><a aria-label="Anchor link for: taimuauto" class=zola-anchor href=#taimuauto>🔗</a>タイムアウト</h3><p><code>cargo test</code>はテストランナーが終了するまで待つので、絶対に終了しないテストがあるとテストランナーを永遠にブロックしかねません。これは悲しいですが、普通<ruby>エンドレス<rp> (<rt>終了しない<rp>) </ruby>ループを回避するのは簡単なので、実際は大きな問題ではありません。しかしながら、私達のケースでは、様々な状況でエンドレスループが発生しうるのです：<ul><li>ブートローダーが私達のカーネルを読み込むのに失敗し、これによりシステムが延々と再起動し続ける。<li>BIOS/UEFIファームウェアがブートローダーの読み込みに失敗し、同様に延々と再起動し続ける。<li>私達の関数のどれかの最後で、CPUが<code>loop {}</code>文に入ってしまう（例えば、QEMU終了デバイスがうまく動かなかったなどの理由で）。<li>CPU例外（今後説明します）がうまく捕捉されなかった場合などに、ハードウェアがシステムリセットを行う。</ul><p>エンドレスループは非常に多くの状況で発生しうるので、<code>bootimage</code>はそれぞれのテスト実行ファイルに対し標準で5分のタイムアウトを設定しています。テストがこの時間内に終了しなかった場合は失敗したとみなされ、“Timed Out” エラーがコンソールに出力されます。この機能により、エンドレスループで詰まったテストが<code>cargo test</code>を永遠にブロックしてしまうことがないことが保証されます。<p>これを自分で試すこともできます。<code>trivial_assertion</code>テストに<code>loop {}</code>文を追加してください。<code>cargo test</code>を実行すると、5分後にテストがタイムアウトしたことが表示されるでしょう。タイムアウトまでの時間は<code>Cargo.toml</code>の<code>test-timeout</code>キーで<a href=https://github.com/rust-osdev/bootimage#configuration>設定可能</a>です：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>package.metadata.bootimage</span><span>]
</span><span style=color:#569cd6;>test-timeout </span><span>= </span><span style=color:#b5cea8;>300          </span><span style=color:#608b4e;># (単位は秒)
</span></code></pre><p><code>trivial_assertion</code>テストがタイムアウトするのを待ちたくない場合は、上の値を一時的に下げても良いでしょう。<h3 id=chu-li-ji-neng-wozi-dong-decha-ru-suru><a aria-label="Anchor link for: chu-li-ji-neng-wozi-dong-decha-ru-suru" class=zola-anchor href=#chu-li-ji-neng-wozi-dong-decha-ru-suru>🔗</a>出力機能を自動で挿入する</h3><p>現在、私達の<code>trivial_assertion</code>テストは、自分のステータス情報を<code>serial_print!</code>/<code>serial_println!</code>を使って出力する必要があります：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>trivial_assertion() {
</span><span>    serial_print!(</span><span style=color:#d69d85;>"trivial assertion... "</span><span>);
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>1</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>}
</span></code></pre><p>私達の書くすべてのテストにこれらのprint文を手動で追加するのは煩わしいので、私達の<code>test_runner</code>を変更して、これらのメッセージを自動で出力するようにしましょう。そうするためには、<code>Testable</code>トレイトを作る必要があります：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span style=color:#569cd6;>pub trait </span><span>Testable {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>run(</span><span style=color:#569cd6;>&</span><span>self) -> ();
</span><span>}
</span></code></pre><p>ここで、<a href=https://doc.rust-lang.org/stable/core/ops/trait.Fn.html><code>Fn()</code>トレイト</a>を持つ型<code>T</code>すべてにこのトレイトを実装してやるのがミソです：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span style=color:#569cd6;>impl</span><span>&LTT> Testable </span><span style=color:#569cd6;>for </span><span>T
</span><span style=color:#569cd6;>where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style=color:#569cd6;>fn </span><span>run(</span><span style=color:#569cd6;>&</span><span>self) {
</span><span>        serial_print!(</span><span style=color:#d69d85;>"{}...</span><span style=color:#e3bbab;>\t</span><span style=color:#d69d85;>"</span><span>, core::any::type_name::&LTT>());
</span><span>        self();
</span><span>        serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p><code>run</code>関数を実装するに当たり、まず<a href=https://doc.rust-lang.org/stable/core/any/fn.type_name.html><code>any::type_name</code></a>を使って関数の名前を出力します。この関数はコンパイラの中に直接実装されており、すべての型の文字列による説明を返すことができます。関数の型はその名前なので、今回の場合まさに私達のやりたいことができています。文字<code>\t</code>は<a href=https://ja.wikipedia.org/wiki/%E3%82%BF%E3%83%96%E3%82%AD%E3%83%BC#%E3%82%BF%E3%83%96%E6%96%87%E5%AD%97>タブ文字</a>であり、メッセージ<code>[ok]</code>の前にちょっとしたアラインメント（幅を整えるための空白）をつけます。<p>関数名を出力したあとは、テスト関数を<code>self()</code>を使って呼び出します。これは、<code>self</code>が<code>Fn()</code>トレイトを実装していることが要求されているからこそ可能です。テスト関数がリターンしたら、<code>[ok]</code>を出力してこの関数がパニックしなかったことを示します。<p>最後に、<code>test_runner</code>をこの<code>Testable</code>トレイトを使うように更新します：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[cfg(test)]
</span><span style=color:#569cd6;>pub fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Testable]) {
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Running {} tests"</span><span>, tests.len());
</span><span>    </span><span style=color:#569cd6;>for</span><span> test </span><span style=color:#569cd6;>in</span><span> tests {
</span><span>        test.run(); </span><span style=color:#608b4e;>// ここを変更
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre><p>変更点は2つだけで、<code>tests</code>引数の型を<code>&[&dyn Fn()]</code>から<code>&[&dyn Testable]</code>に変えたことと、<code>test()</code>の変わりに<code>test.run()</code>を呼ぶようにしたことです。<p>また、<code>trivial_assertion</code>のprint文は今や自動で出力されるようになったので、これを取り除きましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>trivial_assertion() {
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>1</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>}
</span></code></pre><p>これで<code>cargo test</code>の出力は以下のようになるはずです：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>Running 1 tests
</span><span>blog_os::trivial_assertion...	[ok]
</span></code></pre><p>いま、関数名には関数までのフルパスが含まれていますが、これは異なるモジュールのテスト関数が同じ名前を持っているときに便利です。それ以外の点において出力は前と同じですが、もう手動でテストにprint文を付け加える必要はありません。<h2 id=vgabatuhuawotesutosuru><a aria-label="Anchor link for: vgabatuhuawotesutosuru" class=zola-anchor href=#vgabatuhuawotesutosuru>🔗</a>VGAバッファをテストする</h2><p>私達のテストフレームワークがうまく動くようになったので、私達のVGAバッファに関する実装のテストをいくつか作ってみましょう。まず、<code>println</code>がパニックすることなく成功することを確かめる非常に単純なテストを作ります：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>test_println_simple() {
</span><span>    println!(</span><span style=color:#d69d85;>"test_println_simple output"</span><span>);
</span><span>}
</span></code></pre><p>このテストは、適当な文字列をVGAバッファにただ出力するだけです。このテストがパニックすることなく終了したなら、<code>println</code>の呼び出しもまたパニックしなかったということです。<p>たくさんの行が出力され、行がスクリーンから押し出されたとしてもパニックが起きないことを確かめるために、もう一つテストを作ってみましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>test_println_many() {
</span><span>    </span><span style=color:#569cd6;>for _ in </span><span style=color:#b5cea8;>0</span><span style=color:#569cd6;>..</span><span style=color:#b5cea8;>200 </span><span>{
</span><span>        println!(</span><span style=color:#d69d85;>"test_println_many output"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>出力された行が本当に画面に映っているのかを確かめるテスト関数も作ることができます：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>test_println_output() {
</span><span>    </span><span style=color:#569cd6;>let</span><span> s = </span><span style=color:#d69d85;>"Some test string that fits on a single line"</span><span>;
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, s);
</span><span>    </span><span style=color:#569cd6;>for </span><span>(i, c) </span><span style=color:#569cd6;>in</span><span> s.chars().enumerate() {
</span><span>        </span><span style=color:#569cd6;>let</span><span> screen_char = </span><span style=color:#b4cea8;>WRITER</span><span>.lock().buffer.chars[</span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>- </span><span style=color:#b5cea8;>2</span><span>][i].read();
</span><span>        assert_eq!(</span><span style=color:#569cd6;>char</span><span>::from(screen_char.ascii_character), c);
</span><span>    }
</span><span>}
</span></code></pre><p>この関数はテスト用文字列を定義し、<code>println</code>を使って出力し、静的な<code>WRITER</code>――VGAテキストバッファを表現しています――上の表示文字を<ruby>走査<rp> (<rt>イテレート<rp>) </ruby>しています。<code>println</code>は最後に出力された行につづけて出力し、即座に改行するので、<code>BUFFER_HEIGHT - 2</code>行目にこの文字列は現れるはずです。<p><a href=https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.enumerate><code>enumerate</code></a>を使うことで、変数<code>i</code>によって反復の回数を数え、これを<code>c</code>に対応する画面上の文字を読み込むのに使っています。画面の文字の<code>ascii_character</code>を<code>c</code>と比較することで、文字列のそれぞれの文字がVGAテキストバッファに確実に現れていることを確かめることができます。<p>ご想像の通り、もっとたくさんテストを作っても良いです。例えば、非常に長い行を出力しても、うまく折り返され、パニックしないことをテストする関数や、改行・出力不可能な文字・非ユニコード文字などが適切に処理されることを確かめるような関数を作ることもできます。<p>ですが、この記事の残りでは、 <strong>結合テスト</strong> を作って、異なる<ruby>構成要素<rp> (<rt>コンポーネント<rp>) </ruby>の相互作用をテストする方法を説明しましょう。<h2 id=jie-he-tesuto><a aria-label="Anchor link for: jie-he-tesuto" class=zola-anchor href=#jie-he-tesuto>🔗</a>結合テスト</h2><p>Rustにおける<a href=https://doc.rust-jp.rs/book-ja/ch11-03-test-organization.html#%E7%B5%90%E5%90%88%E3%83%86%E3%82%B9%E3%83%88>結合テスト</a>では、慣習としてプロジェクトのルートにおいた<code>tests</code>ディレクトリ (つまり<code>src</code>ディレクトリと同じ階層ですね) にテストプログラムを入れます。標準のテストフレームワークも、独自のテストフレームワークも、自動的にこのディレクトリにあるすべてのテストを実行します。<p>すべての結合テストは、独自の実行可能ファイルを持っており、私達の<code>main.rs</code>とは完全に独立しています。つまり、それぞれのテストに独自のエントリポイント関数を定義しないといけないということです。どのような仕組みになっているのかを詳しく見るために、<code>basic_boot</code>という名前で試しに結合テストを作ってみましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/basic_boot.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style=color:#569cd6;>= </span><span style=color:#d69d85;>"test_main"</span><span>]
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::panic::PanicInfo;
</span><span>
</span><span>#[no_mangle] </span><span style=color:#608b4e;>// この関数の名前を変えない
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#569cd6;>fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Fn()]) {
</span><span>    unimplemented!();
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>結合テストは独立した実行ファイルであるので、クレート属性（<code>no_std</code>、<code>no_main</code>、<code>test_runner</code>など）をすべてもう一度与えないといけません。また、新しいエントリポイント関数<code>_start</code>も作らないといけません。これはテストエントリポイント関数<code>test_main</code>を呼び出します。結合テストの実行可能ファイルは、テストモードでないときはビルドされないので、<code>cfg(test)</code>属性は必要ありません。<p>今のところ、<code>test_runner</code>関数の中身として、常にパニックする<a href=https://doc.rust-lang.org/core/macro.unimplemented.html><code>unimplemented</code></a>マクロを代わりに入れており、そして<code>panic</code>ハンドラにはただの<code>loop</code>を入れています。本当は、<code>serial_println</code>マクロと<code>exit_qemu</code>関数を使って、これらの関数を<code>main.rs</code>と全く同じように実装したいです。しかし問題は、テストが私達の<code>main.rs</code>実行ファイルとは完全に別にビルドされているので、これらの関数にアクセスすることができないということです。<p>この段階で<code>cargo test</code>を実行したら、パニックハンドラによってエンドレスループに入ってしまうでしょう。QEMUを終了するキーボードショートカットである<code>Ctrl+c</code>を使わないといけません。<h3 id=raiburariwozuo-ru><a aria-label="Anchor link for: raiburariwozuo-ru" class=zola-anchor href=#raiburariwozuo-ru>🔗</a>ライブラリを作る</h3><p>結合テストに必要な関数を利用できるようにするために、<code>main.rs</code>からライブラリを分離してやる必要があります。こうすると、他のクレートや結合テスト実行ファイルがこれをインクルードできるようになります。これをするために、新しい<code>src/lib.rs</code>ファイルを作りましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// src/lib.rs
</span><span>
</span><span>#![no_std]
</span><span>
</span></code></pre><p><code>main.rs</code>と同じく、<code>lib.rs</code>は自動的にcargoに認識される特別なファイルです。ライブラリは別のコンパイル単位なので、<code>#![no_std]</code>属性を再び指定する必要があります。<p><code>cargo test</code>がライブラリにも使えるようにするために、テストのための関数や属性を<code>main.rs</code>から<code>lib.rs</code>へと移す必要もあります。<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/lib.rs
</span><span>
</span><span>#![cfg_attr(test, no_main)]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(crate::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style=color:#569cd6;>= </span><span style=color:#d69d85;>"test_main"</span><span>]
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::panic::PanicInfo;
</span><span>
</span><span style=color:#569cd6;>pub trait </span><span>Testable {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>run(</span><span style=color:#569cd6;>&</span><span>self) -> ();
</span><span>}
</span><span>
</span><span style=color:#569cd6;>impl</span><span>&LTT> Testable </span><span style=color:#569cd6;>for </span><span>T
</span><span style=color:#569cd6;>where
</span><span>    T: Fn(),
</span><span>{
</span><span>    </span><span style=color:#569cd6;>fn </span><span>run(</span><span style=color:#569cd6;>&</span><span>self) {
</span><span>        serial_print!(</span><span style=color:#d69d85;>"{}...</span><span style=color:#e3bbab;>\t</span><span style=color:#d69d85;>"</span><span>, core::any::type_name::&LTT>());
</span><span>        self();
</span><span>        serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Testable]) {
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Running {} tests"</span><span>, tests.len());
</span><span>    </span><span style=color:#569cd6;>for</span><span> test </span><span style=color:#569cd6;>in</span><span> tests {
</span><span>        test.run();
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>test_panic_handler(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[failed]</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>);
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Error: {}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#608b4e;>/// `cargo test`のときのエントリポイント
</span><span>#[cfg(test)]
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    test_main();
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    test_panic_handler(info)
</span><span>}
</span></code></pre><p><code>test_runner</code>を（<code>main.rs</code>の）実行可能ファイルと結合テストの両方から利用可能にするために、<code>cfg(test)</code>属性をこれに適用せず、また、publicにします。パニックハンドラの実装もpublicな<code>test_panic_handler</code>関数へと分離することで、実行可能ファイルからも使えるようにしています。<p><code>lib.rs</code>は<code>main.rs</code>とは独立にコンパイルされるので、ライブラリがテストモードでコンパイルされるときは<code>_start</code>エントリポイントとパニックハンドラを追加する必要があります。このような場合、<a href=https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute><code>cfg_attr</code></a>クレート属性を使うことで、<code>no_main</code>属性を条件付きで有効化することができます。<p><code>QemuExitCode</code>enumと<code>exit_qemu</code>関数も移動し、publicにします：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/lib.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u32)]
</span><span style=color:#569cd6;>pub enum </span><span>QemuExitCode {
</span><span>    Success = </span><span style=color:#b5cea8;>0x10</span><span>,
</span><span>    Failed = </span><span style=color:#b5cea8;>0x11</span><span>,
</span><span>}
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>exit_qemu(exit_code: QemuExitCode) {
</span><span>    </span><span style=color:#569cd6;>use </span><span>x86_64::instructions::port::Port;
</span><span>
</span><span>    </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>        </span><span style=color:#569cd6;>let mut</span><span> port = Port::new(</span><span style=color:#b5cea8;>0xf4</span><span>);
</span><span>        port.write(exit_code </span><span style=color:#569cd6;>as u32</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>これで、実行ファイルも結合テストもこれらの関数をライブラリからインポートでき、自前の実装を定義する必要はありません。<code>println</code>と<code>serial_println</code>も利用可能にするために、モジュールの宣言も移動させましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/lib.rs
</span><span>
</span><span style=color:#569cd6;>pub mod </span><span>serial;
</span><span style=color:#569cd6;>pub mod </span><span>vga_buffer;
</span></code></pre><p>モジュールをpublicにすることで、ライブラリの外からも使えるようにしています。<code>println</code>と<code>serial_println</code>マクロは、これらのモジュールの<code>_print</code>関数を使っているため、これらのマクロを使うためにも、この変更は必要です。<p>では、<code>main.rs</code>をこのライブラリを使うように更新しましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// src/main.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>#![reexport_test_harness_main </span><span style=color:#569cd6;>= </span><span style=color:#d69d85;>"test_main"</span><span>]
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::panic::PanicInfo;
</span><span style=color:#569cd6;>use </span><span>blog_os::println;
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"Hello World</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#d69d85;>"!"</span><span>);
</span><span>
</span><span>    #[cfg(test)]
</span><span>    test_main();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#608b4e;>/// この関数はパニック時に呼ばれる。
</span><span>#[cfg(not(test))]
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span>#[cfg(test)]
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre><p>ライブラリは通常の外部クレートと同じように使うことができます。名前は、私達のクレート名――今回なら<code>blog_os</code>――になります。上のコードでは、<code>blog_os::test_runner</code>関数を<code>test_runner</code>属性で、<code>blog_os::test_panic_handler</code>関数を<code>cfg(test)</code>のパニックハンドラで使っています。また、<code>println</code>マクロをインポートすることで、<code>_start</code>と<code>panic</code>関数で使えるようにもしています。<p>この時点で、<code>cargo run</code>と<code>cargo test</code>は再びうまく実行できるようになっているはずです。もちろん、<code>cargo test</code>は依然エンドレスループするはずですが（<code>ctrl+c</code>で終了できます）。結合テストに必要な関数を使ってこれを修正しましょう。<h3 id=jie-he-tesutowowan-cheng-saseru><a aria-label="Anchor link for: jie-he-tesutowowan-cheng-saseru" class=zola-anchor href=#jie-he-tesutowowan-cheng-saseru>🔗</a>結合テストを完成させる</h3><p><code>src/main.rs</code>と同じように、<code>tests/basic_boot.rs</code>実行ファイルは新しいライブラリから型をインポートできます。これで、テストを完成させるのに足りない要素をインポートすることができます。<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/basic_boot.rs
</span><span>
</span><span>#![test_runner(blog_os::test_runner)]
</span><span>
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    blog_os::test_panic_handler(info)
</span><span>}
</span></code></pre><p>テストランナーを再実装することはせず、ライブラリの<code>test_runner</code>関数を使います。<code>panic</code>ハンドラとしては、<code>main.rs</code>でやったように<code>blog_os::test_panic_handler</code>関数を呼びます。<p>これで、<code>cargo test</code>は再び通常通り終了するはずです。実行すると、<code>lib.rs</code>、<code>main.rs</code>、そして<code>basic_boot.rs</code>を順にそれぞれビルドし、テストを実行するのが見えるはずです。<code>main.rs</code>と<code>basic_boot</code>結合テストに関しては、これらには<code>#[test_case]</code>のつけられた関数はないため、“Running 0 tests“と報告されるはずです。<p>これで、<code>basic_boot.rs</code>にテストを追加していくことができます。例えば、<code>println</code>がパニックすることなくうまく行くことを、VGAバッファのときのようにテストすることができます：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/basic_boot.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>blog_os::println;
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>test_println() {
</span><span>    println!(</span><span style=color:#d69d85;>"test_println output"</span><span>);
</span><span>}
</span></code></pre><p><code>cargo test</code>を実行すると、テスト関数を見つけ出して実行しているのがわかるでしょう。<p>このテストは、VGAバッファのテストとほとんど同じであるため、今のところあまり意味がないように思われるかもしれません。しかし、将来的に<code>main.rs</code>の<code>_start</code>関数と<code>lib.rs</code>はどんどん大きくなり、<code>test_main</code>関数を実行する前に様々な初期化ルーチンを呼ぶようになるかもしれないので、これらの2つのテストは全然違う環境で実行されるようになるかもしれないのです。<p><code>println</code>を<code>basic_boot</code>環境で（<code>_start</code>で初期化ルーチンを一切呼ぶことなく）テストすることにより、起動の直後に<code>println</code>が使えることが保証されます。私達は、例えばパニックメッセージの出力などを<code>println</code>に依存しているので、これは重要です。<h3 id=jin-hou-notesuto><a aria-label="Anchor link for: jin-hou-notesuto" class=zola-anchor href=#jin-hou-notesuto>🔗</a>今後のテスト</h3><p>結合テストの魅力は、これらが完全に独立した実行ファイルとして扱われることです。これにより、実行環境を完全にコントロールすることができるので、コードがCPUやハードウェアデバイスと正しく相互作用していることをテストすることができるのです。<p><code>basic_boot</code>テストは結合テストの非常に簡単な例でした。今後、私達のカーネルは機能がより豊富になり、そして様々な方法でハードウェアと相互作用するようになります。結合テストを追加することにより、それらの相互作用が期待通り動く（また、期待通り動きつづけている）ことを確かめることができるのです。今後追加できるテストの例としては、以下があります：<ul><li><strong>CPU<ruby>例外<rp> (<rt>exception<rp>) </ruby></strong>: プログラムが不正な操作（例えばゼロで割るなど）を行った場合、CPUは例外を投げます（訳注：例外を発することを、英語でthrow an exceptionというのにちなんで、慣例的に「投げる」と表現します）。カーネルはそのような例外に対するハンドラ関数を登録しておくことができます。結合テストで、CPU例外が起こったときに、例外ハンドラが呼ばれていることや、例外が解決可能だった場合に実行が継続することを確かめることができるでしょう。<li><strong>ページテーブル</strong>: ページテーブルは、どのメモリ領域が有効でアクセスできるかを定義しています。例えばプログラムを立ち上げるとき、このページテーブルを変更することで、新しいメモリ領域を割り当てることが可能です。結合テストで、ページテーブルに<code>_start</code>関数内で何らかの変更を施して、その変更が期待通りの効果を起こしているかを<code>#[test_case]</code>関数で確かめることができるでしょう。<li><strong>ユーザー<ruby>空間<rp> (<rt>スペース<rp>) </ruby>プログラム</strong>: ユーザー空間プログラムは、システムの<ruby>資源<rp> (<rt>リソース<rp>) </ruby>に限られたアクセスしか持たないプログラムのことです。これらは例えば、カーネルのデータ構造や、他のプログラムのメモリにアクセスすることはできません。結合テストで、禁止された操作を実行するようなユーザー空間プログラムを起動し、カーネルがそれらをすべて防ぐことを確かめることができるでしょう。</ul><p>ご想像のとおり、もっと多くのテストが可能です。このようなテストを追加することで、カーネルに新しい機能を追加したときや、コードをリファクタリングしたときに、これらを壊してしまっていないことを保証できます。これは、私達のカーネルがより大きく、より複雑になったときに特に重要になります。<h3 id=panitukusinakerebanaranaitesuto><a aria-label="Anchor link for: panitukusinakerebanaranaitesuto" class=zola-anchor href=#panitukusinakerebanaranaitesuto>🔗</a>パニックしなければならないテスト</h3><p>標準ライブラリのテストフレームワークは、<a href=https://doc.rust-jp.rs/rust-by-example-ja/testing/unit_testing.html#testing-panics><code>#[should_panic]</code>属性</a>をサポートしています。これを使うと、失敗しなければならないテストを作ることができます。これは、例えば、関数が無効な引数を渡されたときに失敗することを確かめる場合などに便利です。残念なことに、この機能は標準ライブラリのサポートを必要とするため、<code>#[no_std]</code>クレートではこの属性はサポートされていません。<p><code>#[should_panic]</code>属性は使えませんが、パニックハンドラから成功のエラーコードで終了するような結合テストを作れば、似たような動きをさせることはできます。そのようなテストを<code>should_panic</code>という名前で作ってみましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::panic::PanicInfo;
</span><span style=color:#569cd6;>use </span><span>blog_os::{QemuExitCode, exit_qemu, serial_println};
</span><span>
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(_info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>これは<code>_start</code>関数や、独自テストランナー属性などをまだ定義していないので未完成です。足りない部分を追加しましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/should_panic.rs
</span><span>
</span><span>#![feature(custom_test_frameworks)]
</span><span>#![test_runner(test_runner)]
</span><span>#![reexport_test_harness_main </span><span style=color:#569cd6;>= </span><span style=color:#d69d85;>"test_main"</span><span>]
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    test_main();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>test_runner(tests: </span><span style=color:#569cd6;>&</span><span>[</span><span style=color:#569cd6;>&</span><span>dyn Fn()]) {
</span><span>    serial_println!(</span><span style=color:#d69d85;>"Running {} tests"</span><span>, tests.len());
</span><span>    </span><span style=color:#569cd6;>for</span><span> test </span><span style=color:#569cd6;>in</span><span> tests {
</span><span>        test();
</span><span>        serial_println!(</span><span style=color:#d69d85;>"[test did not panic]"</span><span>);
</span><span>        exit_qemu(QemuExitCode::Failed);
</span><span>    }
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>}
</span></code></pre><p>このテストは、<code>lib.rs</code>の<code>test_runner</code>を使い回さず、自前の、テストがパニックせずリターンしたときに失敗の終了コードを出すような<code>test_runner</code>関数を定義しています（私達はテストにパニックしてほしいわけですから）。もしテスト関数が一つも定義されていなければ、このランナーは成功のエラーコードで終了します。ランナーは一つテストを実行したら必ず終了するので、1つ以上の<code>#[test_case]</code>関数を定義しても意味はありません。<p>では、失敗するはずのテストを追加してみましょう：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/should_panic.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>blog_os::serial_print;
</span><span>
</span><span>#[test_case]
</span><span style=color:#569cd6;>fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style=color:#d69d85;>"should_panic::should_fail...</span><span style=color:#e3bbab;>\t</span><span style=color:#d69d85;>"</span><span>);
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>0</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>}
</span></code></pre><p>このテストは<code>assert_eq</code>を使って<code>0</code>と<code>1</code>が等しいことをアサートしています。これはもちろん失敗するので、私達のテストは望み通りパニックします。ここで、<code>Testable</code>トレイトは使っていないので、関数名は<code>serial_print!</code>を使って自分で出力しないといけないことに注意してください。<p><code>cargo test --test should_panic</code>を使ってテストすると、テストが期待通りパニックし、成功したことがわかるでしょう。アサーションをコメントアウトしテストをもう一度実行すると、“test did not panic“というメッセージとともに、テストが確かに失敗することがわかります。<p>この方法の無視できない欠点は、テスト関数を一つしか使えないことです。<code>#[test_case]</code>関数が複数ある場合、パニックハンドラが呼び出された後で（プログラムの）実行を続けることはできないので、最初の関数のみが実行されます。この問題を解決するいい方法を私は知らないので、もしなにかアイデアがあったら教えてください！<h3 id=hanesu-harness-nonaitesuto><a aria-label="Anchor link for: hanesu-harness-nonaitesuto" class=zola-anchor href=#hanesu-harness-nonaitesuto>🔗</a><ruby>ハーネス<rp> (<rt>harness<rp>) </ruby>のないテスト</h3><div class=note><p><strong>訳注:</strong> ハーネスとは、もともとは馬具の一種を意味する言葉です。転じて「制御する道具」一般を指し、また<a href=https://en.wikipedia.org/wiki/Test_harness>テストハーネス</a>というと（<code>test_runner</code>のように）複数のテストケースを処理し、その振る舞い・出力などを適切に処理・整形してくれるプログラムのことを指します。</div><p>（私達の<code>should_panic</code>テストのように）一つしかテスト関数を持たない結合テストでは、テストランナーは必ずしも必要というわけではありません。このような場合、テストランナーは完全に無効化してしまって、<code>_start</code>関数からテストを直接実行することができます。<p>このためには、<code>Cargo.toml</code>でこのテストの<code>harness</code>フラグを無効化することがカギとなります。これは、結合テストにテストランナーが使われるかを定義しています。これが<code>false</code>に設定されると、標準のテストランナーと独自のテストランナーの両方が無効化され、通常の実行ファイルのように扱われるようになります。<p><code>should_panic</code>テストの<code>harness</code>フラグを無効化してみましょう：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[[</span><span style=color:#808080;>test</span><span>]]
</span><span style=color:#569cd6;>name </span><span>= </span><span style=color:#d69d85;>"should_panic"
</span><span style=color:#569cd6;>harness </span><span>= </span><span style=color:#569cd6;>false
</span></code></pre><p>これで、テストランナーに関係するコードを取り除いて、<code>should_panic</code>テストを大幅に簡略化することができます。結果として以下のようになります：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in tests/should_panic.rs
</span><span>
</span><span>#![no_std]
</span><span>#![no_main]
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::panic::PanicInfo;
</span><span style=color:#569cd6;>use </span><span>blog_os::{exit_qemu, serial_print, serial_println, QemuExitCode};
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    should_fail();
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[test did not panic]"</span><span>);
</span><span>    exit_qemu(QemuExitCode::Failed);
</span><span>    </span><span style=color:#569cd6;>loop</span><span>{}
</span><span>}
</span><span>
</span><span style=color:#569cd6;>fn </span><span>should_fail() {
</span><span>    serial_print!(</span><span style=color:#d69d85;>"should_panic::should_fail...</span><span style=color:#e3bbab;>\t</span><span style=color:#d69d85;>"</span><span>);
</span><span>    assert_eq!(</span><span style=color:#b5cea8;>0</span><span>, </span><span style=color:#b5cea8;>1</span><span>);
</span><span>}
</span><span>
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(_info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    serial_println!(</span><span style=color:#d69d85;>"[ok]"</span><span>);
</span><span>    exit_qemu(QemuExitCode::Success);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p><code>should_fail</code>関数を<code>_start</code>関数から直接呼び出して、もしリターンしたら失敗の終了コードで終了するようにしました。今<code>cargo test --test should_panic</code>を実行しても、以前と全く同じように振る舞います。<p><code>should_panic</code>なテストを作るとき以外にも<code>harness</code>属性は有用なことがあります。例えば、それぞれのテスト関数が副作用を持っており、指定された順番で実行されないといけないときなどです。<h2 id=matome><a aria-label="Anchor link for: matome" class=zola-anchor href=#matome>🔗</a>まとめ</h2><p>テストは、ある要素が望み通りの振る舞いをしていることを保証するのにとても便利なテクニックです。バグが存在しないことを証明することはできないとはいえ、バグを発見したり、特にリグレッションを防ぐのに便利な方法であることは間違いありません。<p>この記事では、私達のRust製カーネルでテストフレームワークを組み立てる方法を説明しました。Rustの<ruby>独自<rp> (<rt>カスタム<rp>) </ruby>テストフレームワーク機能を使って、私達のベアメタル環境における、シンプルな<code>#[test_case]</code>属性のサポートを実装しました。私達のテストランナーは、QEMUの<code>isa-debug-exit</code>デバイスを使うことで、QEMUをテスト実行後に終了し、テストステータスを報告することができます。エラーメッセージを、VGAバッファの代わりにコンソールに出力するために、シリアルポートの単純なドライバを作りました。<p><code>println</code>マクロのテストをいくつか作った後、記事の後半では結合テストについて見ました。結合テストは<code>tests</code>ディレクトリに置かれ、完全に独立した実行ファイルとして扱われることを学びました。結合テストから<code>exit_qemu</code>関数と<code>serial_println</code>マクロにアクセスできるようにするために、コードのほとんどをライブラリに移し、すべての実行ファイルと結合テストがインポートできるようにしました。結合テストはそれぞれ独自の環境で実行されるため、ハードウェアとの相互作用や、パニックするべきテストを作るといったことが可能になります。<p>QEMU内で現実に近い環境で実行できるテストフレームワークを手に入れました。今後の記事でより多くのテストを作っていくことで、カーネルがより複雑になってもメンテナンスし続けられるでしょう。<h2 id=ci-ha><a aria-label="Anchor link for: ci-ha" class=zola-anchor href=#ci-ha>🔗</a>次は？</h2><p>次の記事では、<strong>CPU例外</strong>を見ていきます。この例外というのは、CPUによってなにか「不法行為」――例えば、ゼロ除算やマップされていないメモリページへのアクセス（いわゆる「ページフォルト」）――が行われたときに投げられます。これらの例外を捕捉してテストできるようにしておくことは、将来エラーをデバッグするときに非常に重要です。例外の処理はまた、キーボードをサポートするのに必要になる、ハードウェア割り込みの処理に非常に似てもいます。</div><div class=post-footer-support><h2>Support Me</h2><p>Creating and <a href=https://os.phil-opp.com/status-update/>maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.<p>The best way to support me is to <a href=https://github.com/sponsors/phil-opp><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href=https://www.patreon.com/phil_opp><em>Patreon</em></a> and <a href=https://donorbox.org/phil-opp><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.<p>Thank you!</div><hr><div class=PageNavigation><a class=prev href=/ja/vga-text-mode/>« VGAテキストモード</a><a class=next href=/ja/cpu-exceptions/>CPU例外 »</a></div><hr><section><h2 id=comments>コメント</h2><p class=comment-note>Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href=https://www.rust-lang.org/policies/code-of-conduct>code of conduct</a>. This comment thread directly maps to a <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="Testing (ja)"'><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.<div class=giscus></div><script data-category="Post Comments" data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ==" data-term="Testing (ja)" async crossorigin=anonymous data-category-id=MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1 data-emit-metadata=1 data-mapping=specific data-reactions-enabled=1 data-repo=phil-opp/blog_os data-theme=preferred_color_scheme src=https://giscus.app/client.js></script><p class=comment-directly-on-github>Instead of authenticating the <a href=https://giscus.app>giscus</a> application, you can also comment directly <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="Testing (ja)"'><em>on GitHub</em></a>.<p>可能な限りコメントは英語で残すようにしてください。</section><aside class=page-aside-right><div class=block id=language-selector><h2>Other Languages</h2><ul><li data-lang-switch-to=en><a href=https://os.phil-opp.com/testing/> English (original) </a><li data-lang-switch-to=zh-CN><a href=https://os.phil-opp.com/zh-CN/testing/> Chinese (simplified) </a><li data-lang-switch-to=fa><a href=https://os.phil-opp.com/fa/testing/> Persian </a></ul></div><div class="dark-mode-note warning"><h2>Dark Mode is Experimental</h2><p>We're still working on adjusting text colors, fixing images, and removing inconsistencies. If you have any problems, please <a href=https://github.com/phil-opp/blog_os/issues>file an issue</a>.<aside></aside><main><div><div></div><footer class=footer><hr><small> © <time datetime=2021>2021</time>. All rights reserved. <a href=https://os.phil-opp.com/contact/>Contact</a> </small></footer></div><script async data-goatcounter=https://phil-opp.goatcounter.com/count src=//gc.zgo.at/count.js></script>