<!doctype html><html lang=zh-CN><head><meta charset=UTF-8><meta content=yes name=apple-mobile-web-app-capable><meta content="width=device-width,initial-scale=1" name=viewport><meta content="light dark" name=color-scheme><meta content="VGA 字符模式（VGA text mode）是打印字符到屏幕的一种简单方式。在这篇文章中，为了包装这个模式为一个安全而简单的接口，我们将包装 unsafe 代码到独立的模块。我们还将实现对 Rust 语言格式化宏（formatting macros）的支持。
" name=description><meta content="Philipp Oppermann" name=author><link href=https://os.phil-opp.com/zh-CN/vga-text-mode/ rel=canonical><link href=/css/edition-2/main.css rel=stylesheet><link title="RSS feed for os.phil-opp.com" href=https://os.phil-opp.com/rss.xml rel=alternate type=application/rss+xml><script>let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }</script><script async src=/js/edition-2/main.js></script><title>VGA 字符模式 | Writing an OS in Rust</title><body><div class="container content"><header class=masthead><div style=position:relative><h2 class=masthead-title><a href=https://os.phil-opp.com title=Home>Writing an OS in Rust</a></h2><p><small>Philipp Oppermann's blog</small><aside id=all-posts-link><a title="All Posts" href=https://os.phil-opp.com/zh-CN>« 所有文章</a></aside></div></header><div class=theme-switch><div title="Switch between light and dark theme" class=light-switch onclick=toggle_lights()></div><div title="Clear the theme override and go back to the system theme" class=light-switch-reset onclick=clear_theme_override()></div></div><div><aside id=toc-aside><h2>目录</h2><ol><li><a href=#vga-zi-fu-huan-chong-qu>VGA 字符缓冲区</a><li><a href=#bao-zhuang-dao-rust-mo-kuai>包装到 Rust 模块</a> <ol><li><a href=#yan-se>颜色</a><li><a href=#zi-fu-huan-chong-qu>字符缓冲区</a><li><a href=#da-yin-zi-fu>打印字符</a><li><a href=#yi-shi-cao-zuo>易失操作</a><li><a href=#ge-shi-hua-hong>格式化宏</a><li><a href=#huan-xing>换行</a></ol><li><a href=#quan-ju-jie-kou>全局接口</a> <ol><li><a href=#yan-chi-chu-shi-hua>延迟初始化</a><li><a href=#zi-xuan-suo>自旋锁</a><li><a href=#an-quan-xing>安全性</a><li><a href=#println-hong>println! 宏</a><li><a href=#shi-yong-println-de-hello-world>使用 println! 的 Hello World</a><li><a href=#da-yin-panic-xin-xi>打印 panic 信息</a></ol><li><a href=#xiao-jie>小结</a><li><a href=#xia-pian-yu-gao>下篇预告</a><li class=toc-comments-link><a href=#comments>评论</a></ol></aside><main><div><h1>VGA 字符模式</h1><time class=post-date datetime=2018-02-26> Feb 26, 2018 </time></div><div class=warning><p><b>翻译内容：</b> 这是对原文章 <strong><a href=https://os.phil-opp.com/vga-text-mode/>VGA Text Mode</a></strong> 的社区中文翻译。它可能不完整，过时或者包含错误。可以在 <a href=https://github.com/phil-opp/blog_os/issues/961>这个 Issue</a> 上评论和提问！<p>翻译者： <a href=https://github.com/luojia65>@luojia65</a> 和 <a href=https://github.com/Rustin-Liu>@Rustin-Liu</a>.</div><div><p><strong>VGA 字符模式</strong>（<a href=https://en.wikipedia.org/wiki/VGA-compatible_text_mode>VGA text mode</a>）是打印字符到屏幕的一种简单方式。在这篇文章中，为了包装这个模式为一个安全而简单的接口，我们将包装 unsafe 代码到独立的模块。我们还将实现对 Rust 语言<strong>格式化宏</strong>（<a href=https://doc.rust-lang.org/std/fmt/#related-macros>formatting macros</a>）的支持。</p><span id=continue-reading></span><p>This blog is openly developed on <a href=https://github.com/phil-opp/blog_os>GitHub</a>. If you have any problems or questions, please open an issue there. You can also leave comments <a href=https://os.phil-opp.com/zh-CN/vga-text-mode/#comments>at the bottom</a>. The complete source code for this post can be found in the <a href=https://github.com/phil-opp/blog_os/tree/post-03><code>post-03</code></a> branch.<details id=toc-inline><summary><b>目录</b></summary> <ul><li><a href=#vga-zi-fu-huan-chong-qu>VGA 字符缓冲区</a><li><a href=#bao-zhuang-dao-rust-mo-kuai>包装到 Rust 模块</a> <ul><li><a href=#yan-se>颜色</a><li><a href=#zi-fu-huan-chong-qu>字符缓冲区</a><li><a href=#da-yin-zi-fu>打印字符</a><li><a href=#yi-shi-cao-zuo>易失操作</a><li><a href=#ge-shi-hua-hong>格式化宏</a><li><a href=#huan-xing>换行</a></ul><li><a href=#quan-ju-jie-kou>全局接口</a> <ul><li><a href=#yan-chi-chu-shi-hua>延迟初始化</a><li><a href=#zi-xuan-suo>自旋锁</a><li><a href=#an-quan-xing>安全性</a><li><a href=#println-hong>println! 宏</a><li><a href=#shi-yong-println-de-hello-world>使用 println! 的 Hello World</a><li><a href=#da-yin-panic-xin-xi>打印 panic 信息</a></ul><li><a href=#xiao-jie>小结</a><li><a href=#xia-pian-yu-gao>下篇预告</a><li class=toc-comments-link><a href=#comments>评论</a></ul></details><h2 id=vga-zi-fu-huan-chong-qu><a aria-label="Anchor link for: vga-zi-fu-huan-chong-qu" class=zola-anchor href=#vga-zi-fu-huan-chong-qu>🔗</a>VGA 字符缓冲区</h2><p>为了在 VGA 字符模式中向屏幕打印字符，我们必须将它写入硬件提供的 <strong>VGA 字符缓冲区</strong>（VGA text buffer）。通常状况下，VGA 字符缓冲区是一个 25 行、80 列的二维数组，它的内容将被实时渲染到屏幕。这个数组的元素被称作<strong>字符单元</strong>（character cell），它使用下面的格式描述一个屏幕上的字符：<table><thead><tr><th>Bit(s)<th>Value<tbody><tr><td>0-7<td>ASCII code point<tr><td>8-11<td>Foreground color<tr><td>12-14<td>Background color<tr><td>15<td>Blink</table><p>其中，<strong>前景色</strong>（foreground color）和<strong>背景色</strong>（background color）取值范围如下：<table><thead><tr><th>Number<th>Color<th>Number + Bright Bit<th>Bright Color<tbody><tr><td>0x0<td>Black<td>0x8<td>Dark Gray<tr><td>0x1<td>Blue<td>0x9<td>Light Blue<tr><td>0x2<td>Green<td>0xa<td>Light Green<tr><td>0x3<td>Cyan<td>0xb<td>Light Cyan<tr><td>0x4<td>Red<td>0xc<td>Light Red<tr><td>0x5<td>Magenta<td>0xd<td>Pink<tr><td>0x6<td>Brown<td>0xe<td>Yellow<tr><td>0x7<td>Light Gray<td>0xf<td>White</table><p>每个颜色的第四位称为<strong>加亮位</strong>（bright bit）。<p>要修改 VGA 字符缓冲区，我们可以通过<strong>存储器映射输入输出</strong>（<a href=https://en.wikipedia.org/wiki/Memory-mapped_I/O>memory-mapped I/O</a>）的方式，读取或写入地址 <code>0xb8000</code>；这意味着，我们可以像操作普通的内存区域一样操作这个地址。<p>需要注意的是，一些硬件虽然映射到存储器，但可能不会完全支持所有的内存操作：可能会有一些设备支持按 <code>u8</code> 字节读取，但在读取 <code>u64</code> 时返回无效的数据。幸运的是，字符缓冲区都<a href=https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip>支持标准的读写操作</a>，所以我们不需要用特殊的标准对待它。<h2 id=bao-zhuang-dao-rust-mo-kuai><a aria-label="Anchor link for: bao-zhuang-dao-rust-mo-kuai" class=zola-anchor href=#bao-zhuang-dao-rust-mo-kuai>🔗</a>包装到 Rust 模块</h2><p>既然我们已经知道 VGA 文字缓冲区如何工作，也是时候创建一个 Rust 模块来处理文字打印了。我们输入这样的代码：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span style=color:#569cd6;>mod </span><span>vga_buffer;
</span></code></pre><p>这行代码定义了一个 Rust 模块，它的内容应当保存在 <code>src/vga_buffer.rs</code> 文件中。使用 <strong>2018 版次</strong>（2018 edition）的 Rust 时，我们可以把模块的<strong>子模块</strong>（submodule）文件直接保存到 <code>src/vga_buffer/</code> 文件夹下，与 <code>vga_buffer.rs</code> 文件共存，而无需创建一个 <code>mod.rs</code> 文件。<p>我们的模块暂时不需要添加子模块，所以我们将它创建为 <code>src/vga_buffer.rs</code> 文件。除非另有说明，本文中的代码都保存到这个文件中。<h3 id=yan-se><a aria-label="Anchor link for: yan-se" class=zola-anchor href=#yan-se>🔗</a>颜色</h3><p>首先，我们使用 Rust 的<strong>枚举</strong>（enum）表示一种颜色：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[allow(dead_code)]
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u8)]
</span><span style=color:#569cd6;>pub enum </span><span>Color {
</span><span>    Black = </span><span style=color:#b5cea8;>0</span><span>,
</span><span>    Blue = </span><span style=color:#b5cea8;>1</span><span>,
</span><span>    Green = </span><span style=color:#b5cea8;>2</span><span>,
</span><span>    Cyan = </span><span style=color:#b5cea8;>3</span><span>,
</span><span>    Red = </span><span style=color:#b5cea8;>4</span><span>,
</span><span>    Magenta = </span><span style=color:#b5cea8;>5</span><span>,
</span><span>    Brown = </span><span style=color:#b5cea8;>6</span><span>,
</span><span>    LightGray = </span><span style=color:#b5cea8;>7</span><span>,
</span><span>    DarkGray = </span><span style=color:#b5cea8;>8</span><span>,
</span><span>    LightBlue = </span><span style=color:#b5cea8;>9</span><span>,
</span><span>    LightGreen = </span><span style=color:#b5cea8;>10</span><span>,
</span><span>    LightCyan = </span><span style=color:#b5cea8;>11</span><span>,
</span><span>    LightRed = </span><span style=color:#b5cea8;>12</span><span>,
</span><span>    Pink = </span><span style=color:#b5cea8;>13</span><span>,
</span><span>    Yellow = </span><span style=color:#b5cea8;>14</span><span>,
</span><span>    White = </span><span style=color:#b5cea8;>15</span><span>,
</span><span>}
</span></code></pre><p>我们使用<strong>类似于 C 语言的枚举</strong>（C-like enum），为每个颜色明确指定一个数字。在这里，每个用 <code>repr(u8)</code> 注记标注的枚举类型，都会以一个 <code>u8</code> 的形式存储——事实上 4 个二进制位就足够了，但 Rust 语言并不提供 <code>u4</code> 类型。<p>通常来说，编译器会对每个未使用的变量发出<strong>警告</strong>（warning）；使用 <code>#[allow(dead_code)]</code>，我们可以对 <code>Color</code> 枚举类型禁用这个警告。<p>我们还<strong>生成</strong>（<a href=https://doc.rust-lang.org/rust-by-example/trait/derive.html>derive</a>）了 <a href=https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html><code>Copy</code></a>、<a href=https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html><code>Clone</code></a>、<a href=https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html><code>Debug</code></a>、<a href=https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html><code>PartialEq</code></a> 和 <a href=https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html><code>Eq</code></a> 这几个 trait：这让我们的类型遵循<strong>复制语义</strong>（<a href=https://doc.rust-lang.org/1.30.0/book/first-edition/ownership.html#copy-types>copy semantics</a>），也让它可以被比较、被调试和打印。<p>为了描述包含前景色和背景色的、完整的<strong>颜色代码</strong>（color code），我们基于 <code>u8</code> 创建一个新类型：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(transparent)]
</span><span style=color:#569cd6;>struct </span><span>ColorCode(</span><span style=color:#569cd6;>u8</span><span>);
</span><span>
</span><span style=color:#569cd6;>impl </span><span>ColorCode {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new(foreground: Color, background: Color) -> ColorCode {
</span><span>        ColorCode((background </span><span style=color:#569cd6;>as u8</span><span>) << </span><span style=color:#b5cea8;>4 </span><span style=color:#569cd6;>| </span><span>(foreground </span><span style=color:#569cd6;>as u8</span><span>))
</span><span>    }
</span><span>}
</span></code></pre><p>这里，<code>ColorCode</code> 类型包装了一个完整的颜色代码字节，它包含前景色和背景色信息。和 <code>Color</code> 类型类似，我们为它生成 <code>Copy</code> 和 <code>Debug</code> 等一系列 trait。为了确保 <code>ColorCode</code> 和 <code>u8</code> 有完全相同的内存布局，我们添加 <a href=https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent>repr(transparent) 标记</a>。<h3 id=zi-fu-huan-chong-qu><a aria-label="Anchor link for: zi-fu-huan-chong-qu" class=zola-anchor href=#zi-fu-huan-chong-qu>🔗</a>字符缓冲区</h3><p>现在，我们可以添加更多的结构体，来描述屏幕上的字符和整个字符缓冲区：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(C)]
</span><span style=color:#569cd6;>struct </span><span>ScreenChar {
</span><span>    ascii_character: </span><span style=color:#569cd6;>u8</span><span>,
</span><span>    color_code: ColorCode,
</span><span>}
</span><span>
</span><span style=color:#569cd6;>const </span><span style=color:#b4cea8;>BUFFER_HEIGHT</span><span>: </span><span style=color:#569cd6;>usize </span><span>= </span><span style=color:#b5cea8;>25</span><span>;
</span><span style=color:#569cd6;>const </span><span style=color:#b4cea8;>BUFFER_WIDTH</span><span>: </span><span style=color:#569cd6;>usize </span><span>= </span><span style=color:#b5cea8;>80</span><span>;
</span><span>
</span><span>#[repr(transparent)]
</span><span style=color:#569cd6;>struct </span><span>Buffer {
</span><span>    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
</span><span>}
</span></code></pre><p>在内存布局层面，Rust 并不保证按顺序布局成员变量。因此，我们需要使用 <code>#[repr(C)]</code> 标记结构体；这将按 C 语言约定的顺序布局它的成员变量，让我们能正确地映射内存片段。对 <code>Buffer</code> 类型，我们再次使用 <code>repr(transparent)</code>，来确保类型和它的单个成员有相同的内存布局。<p>为了输出字符到屏幕，我们来创建一个 <code>Writer</code> 类型：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub struct </span><span>Writer {
</span><span>    column_position: </span><span style=color:#569cd6;>usize</span><span>,
</span><span>    color_code: ColorCode,
</span><span>    buffer: </span><span style=color:#569cd6;>&'static mut</span><span> Buffer,
</span><span>}
</span></code></pre><p>我们将让这个 <code>Writer</code> 类型将字符写入屏幕的最后一行，并在一行写满或接收到换行符 <code>\n</code> 的时候，将所有的字符向上位移一行。<code>column_position</code> 变量将跟踪光标在最后一行的位置。当前字符的前景和背景色将由 <code>color_code</code> 变量指定；另外，我们存入一个 VGA 字符缓冲区的可变借用到<code>buffer</code>变量中。需要注意的是，这里我们对借用使用<strong>显式生命周期</strong>（<a href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotation-syntax>explicit lifetime</a>），告诉编译器这个借用在何时有效：我们使用** <code>'static</code> 生命周期 **（<a href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime>’static lifetime</a>），意味着这个借用应该在整个程序的运行期间有效；这对一个全局有效的 VGA 字符缓冲区来说，是非常合理的。<h3 id=da-yin-zi-fu><a aria-label="Anchor link for: da-yin-zi-fu" class=zola-anchor href=#da-yin-zi-fu>🔗</a>打印字符</h3><p>现在我们可以使用 <code>Writer</code> 类型来更改缓冲区内的字符了。首先，为了写入一个 ASCII 码字节，我们创建这样的函数：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_byte(</span><span style=color:#569cd6;>&mut </span><span>self, byte: </span><span style=color:#569cd6;>u8</span><span>) {
</span><span>        </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>            </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.new_line(),
</span><span>            byte </span><span style=color:#569cd6;>=> </span><span>{
</span><span>                </span><span style=color:#569cd6;>if </span><span>self.column_position >= </span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>                    self.new_line();
</span><span>                }
</span><span>
</span><span>                </span><span style=color:#569cd6;>let</span><span> row = </span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>- </span><span style=color:#b5cea8;>1</span><span>;
</span><span>                </span><span style=color:#569cd6;>let</span><span> col = self.column_position;
</span><span>
</span><span>                </span><span style=color:#569cd6;>let</span><span> color_code = self.color_code;
</span><span>                self.buffer.chars[row][col] = ScreenChar {
</span><span>                    ascii_character: byte,
</span><span>                    color_code,
</span><span>                };
</span><span>                self.column_position += </span><span style=color:#b5cea8;>1</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new_line(</span><span style=color:#569cd6;>&mut </span><span>self) {</span><span style=color:#608b4e;>/* TODO */</span><span>}
</span><span>}
</span></code></pre><p>如果这个字节是一个<strong>换行符</strong>（<a href=https://en.wikipedia.org/wiki/Newline>line feed</a>）字节 <code>\n</code>，我们的 <code>Writer</code> 不应该打印新字符，相反，它将调用我们稍后会实现的 <code>new_line</code> 方法；其它的字节应该将在 <code>match</code> 语句的第二个分支中被打印到屏幕上。<p>当打印字节时，<code>Writer</code> 将检查当前行是否已满。如果已满，它将首先调用 <code>new_line</code> 方法来将这一行字向上提升，再将一个新的 <code>ScreenChar</code> 写入到缓冲区，最终将当前的光标位置前进一位。<p>要打印整个字符串，我们把它转换为字节并依次输出：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_string(</span><span style=color:#569cd6;>&mut </span><span>self, s: </span><span style=color:#569cd6;>&str</span><span>) {
</span><span>        </span><span style=color:#569cd6;>for</span><span> byte </span><span style=color:#569cd6;>in</span><span> s.bytes() {
</span><span>            </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>                </span><span style=color:#608b4e;>// 可以是能打印的 ASCII 码字节，也可以是换行符
</span><span>                </span><span style=color:#b5cea8;>0x20</span><span style=color:#569cd6;>...</span><span style=color:#b5cea8;>0x7e </span><span style=color:#569cd6;>| b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.write_byte(byte),
</span><span>                </span><span style=color:#608b4e;>// 不包含在上述范围之内的字节
</span><span>                </span><span style=color:#569cd6;>_ => </span><span>self.write_byte(</span><span style=color:#b5cea8;>0xfe</span><span>),
</span><span>            }
</span><span>
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>VGA 字符缓冲区只支持 ASCII 码字节和<strong>代码页 437</strong>（<a href=https://en.wikipedia.org/wiki/Code_page_437>Code page 437</a>）定义的字节。Rust 语言的字符串默认编码为 <a href=https://www.fileformat.info/info/unicode/utf8.htm>UTF-8</a>，也因此可能包含一些 VGA 字符缓冲区不支持的字节：我们使用 <code>match</code> 语句，来区别可打印的 ASCII 码或换行字节，和其它不可打印的字节。对每个不可打印的字节，我们打印一个 <code>■</code> 符号；这个符号在 VGA 硬件中被编码为十六进制的 <code>0xfe</code>。<p>我们可以亲自试一试已经编写的代码。为了这样做，我们可以临时编写一个函数：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>print_something() {
</span><span>    </span><span style=color:#569cd6;>let mut</span><span> writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>
</span><span>    writer.write_byte(</span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'H'</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"ello "</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"Wörld!"</span><span>);
</span><span>}
</span></code></pre><p>这个函数首先创建一个指向 <code>0xb8000</code> 地址VGA缓冲区的 <code>Writer</code>。实现这一点，我们需要编写的代码可能看起来有点奇怪：首先，我们把整数 <code>0xb8000</code> 强制转换为一个可变的<strong>裸指针</strong>（<a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer>raw pointer</a>）；之后，通过运算符<code>*</code>，我们将这个裸指针解引用；最后，我们再通过 <code>&mut</code>，再次获得它的可变借用。这些转换需要 <strong><code>unsafe</code> 语句块</strong>（<a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html>unsafe block</a>），因为编译器并不能保证这个裸指针是有效的。<p>然后它将字节 <code>b'H'</code> 写入缓冲区内. 前缀 <code>b</code> 创建了一个字节常量（<a href=https://doc.rust-lang.org/reference/tokens.html#byte-literals>byte literal</a>），表示单个 ASCII 码字符；通过尝试写入 <code>"ello "</code> 和 <code>"Wörld!"</code>，我们可以测试 <code>write_string</code> 方法和其后对无法打印字符的处理逻辑。为了观察输出，我们需要在 <code>_start</code> 函数中调用 <code>print_something</code> 方法：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    vga_buffer::print_something();
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>编译运行后，黄色的 <code>Hello W■■rld!</code> 字符串将会被打印在屏幕的左下角：<p><img alt="QEMU output with a yellow Hello W■■rld! in the lower left corner" src=https://os.phil-opp.com/vga-text-mode/vga-hello.png><p>需要注意的是，<code>ö</code> 字符被打印为两个 <code>■</code> 字符。这是因为在 <a href=https://www.fileformat.info/info/unicode/utf8.htm>UTF-8</a> 编码下，字符 <code>ö</code> 是由两个字节表述的——而这两个字节并不处在可打印的 ASCII 码字节范围之内。事实上，这是 UTF-8 编码的基本特点之一：<strong>如果一个字符占用多个字节，那么每个组成它的独立字节都不是有效的 ASCII 码字节</strong>（the individual bytes of multi-byte values are never valid ASCII）。<h3 id=yi-shi-cao-zuo><a aria-label="Anchor link for: yi-shi-cao-zuo" class=zola-anchor href=#yi-shi-cao-zuo>🔗</a>易失操作</h3><p>我们刚才看到，自己想要输出的信息被正确地打印到屏幕上。然而，未来 Rust 编译器更暴力的优化可能让这段代码不按预期工作。<p>产生问题的原因在于，我们只向 <code>Buffer</code> 写入，却不再从它读出数据。此时，编译器不知道我们事实上已经在操作 VGA 缓冲区内存，而不是在操作普通的 RAM——因此也不知道产生的<strong>副效应</strong>（side effect），即会有几个字符显示在屏幕上。这时，编译器也许会认为这些写入操作都没有必要，甚至会选择忽略这些操作！所以，为了避免这些并不正确的优化，这些写入操作应当被指定为<a href=https://en.wikipedia.org/wiki/Volatile_(computer_programming)>易失操作</a>。这将告诉编译器，这些写入可能会产生副效应，不应该被优化掉。<p>为了在我们的 VGA 缓冲区中使用易失的写入操作，我们使用 <a href=https://docs.rs/volatile>volatile</a> 库。这个<strong>包</strong>（crate）提供一个名为 <code>Volatile</code> 的<strong>包装类型</strong>（wrapping type）和它的 <code>read</code>、<code>write</code> 方法；这些方法包装了 <code>core::ptr</code> 内的 <a href=https://doc.rust-lang.org/nightly/core/ptr/fn.read_volatile.html>read_volatile</a> 和 <a href=https://doc.rust-lang.org/nightly/core/ptr/fn.write_volatile.html>write_volatile</a> 函数，从而保证读操作或写操作不会被编译器优化。<p>要添加 <code>volatile</code> 包为项目的<strong>依赖项</strong>（dependency），我们可以在 <code>Cargo.toml</code> 文件的 <code>dependencies</code> 中添加下面的代码：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>volatile </span><span>= </span><span style=color:#d69d85;>"0.2.6"
</span></code></pre><p><code>0.2.6</code> 表示一个<strong>语义版本号</strong>（<a href=https://semver.org/>semantic version number</a>），在 cargo 文档的<a href=https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html>《指定依赖项》章节</a>可以找到与它相关的使用指南。<p>现在，我们使用它来完成 VGA 缓冲区的 volatile 写入操作。我们将 <code>Buffer</code> 类型的定义修改为下列代码：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>volatile::Volatile;
</span><span>
</span><span style=color:#569cd6;>struct </span><span>Buffer {
</span><span>    chars: [[Volatile&LTScreenChar>; BUFFER_WIDTH]; BUFFER_HEIGHT],
</span><span>}
</span></code></pre><p>在这里，我们不使用 <code>ScreenChar</code> ，而选择使用 <code>Volatile&LTScreenChar></code> ——在这里，<code>Volatile</code> 类型是一个<strong>泛型</strong>（<a href=https://doc.rust-lang.org/book/ch10-01-syntax.html>generic</a>），可以包装几乎所有的类型——这确保了我们不会通过普通的写入操作，意外地向它写入数据；我们转而使用提供的 <code>write</code> 方法。<p>这意味着，我们必须要修改我们的 <code>Writer::write_byte</code> 方法：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_byte(</span><span style=color:#569cd6;>&mut </span><span>self, byte: </span><span style=color:#569cd6;>u8</span><span>) {
</span><span>        </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>            </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.new_line(),
</span><span>            byte </span><span style=color:#569cd6;>=> </span><span>{
</span><span>                </span><span style=color:#569cd6;>...
</span><span>
</span><span>                self.buffer.chars[row][col].write(ScreenChar {
</span><span>                    ascii_character: byte,
</span><span>                    color_code: color_code,
</span><span>                });
</span><span>                </span><span style=color:#569cd6;>...
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#569cd6;>...
</span><span>}
</span></code></pre><p>正如代码所示，我们不再使用普通的 <code>=</code> 赋值，而使用了 <code>write</code> 方法：这能确保编译器不再优化这个写入操作。<h3 id=ge-shi-hua-hong><a aria-label="Anchor link for: ge-shi-hua-hong" class=zola-anchor href=#ge-shi-hua-hong>🔗</a>格式化宏</h3><p>支持 Rust 提供的<strong>格式化宏</strong>（formatting macros）也是一个很好的思路。通过这种途径，我们可以轻松地打印不同类型的变量，如整数或浮点数。为了支持它们，我们需要实现 <a href=https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html><code>core::fmt::Write</code></a> trait；要实现它，唯一需要提供的方法是 <code>write_str</code>，它和我们先前编写的 <code>write_string</code> 方法差别不大，只是返回值类型变成了 <code>fmt::Result</code>：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::fmt;
</span><span>
</span><span style=color:#569cd6;>impl </span><span>fmt::Write </span><span style=color:#569cd6;>for </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>write_str(</span><span style=color:#569cd6;>&mut </span><span>self, s: </span><span style=color:#569cd6;>&str</span><span>) -> fmt::Result {
</span><span>        self.write_string(s);
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span></code></pre><p>这里，<code>Ok(())</code> 属于 <code>Result</code> 枚举类型中的 <code>Ok</code>，包含一个值为 <code>()</code> 的变量。<p>现在我们就可以使用 Rust 内置的格式化宏 <code>write!</code> 和 <code>writeln!</code> 了：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>print_something() {
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    </span><span style=color:#569cd6;>let mut</span><span> writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>
</span><span>    writer.write_byte(</span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'H'</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"ello! "</span><span>);
</span><span>    write!(writer, </span><span style=color:#d69d85;>"The numbers are </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;> and </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#b5cea8;>42</span><span>, </span><span style=color:#b5cea8;>1.0</span><span>/</span><span style=color:#b5cea8;>3.0</span><span>).unwrap();
</span><span>}
</span></code></pre><p>现在，你应该在屏幕下端看到一串 <code>Hello! The numbers are 42 and 0.3333333333333333</code>。<code>write!</code> 宏返回的 <code>Result</code> 类型必须被使用，所以我们调用它的 <a href=https://doc.rust-lang.org/core/result/enum.Result.html#method.unwrap><code>unwrap</code></a> 方法，它将在错误发生时 panic。这里的情况下应该不会发生这样的问题，因为写入 VGA 字符缓冲区并没有可能失败。<h3 id=huan-xing><a aria-label="Anchor link for: huan-xing" class=zola-anchor href=#huan-xing>🔗</a>换行</h3><p>在之前的代码中，我们忽略了换行符，因此没有处理超出一行字符的情况。当换行时，我们想要把每个字符向上移动一行——此时最顶上的一行将被删除——然后在最后一行的起始位置继续打印。要做到这一点，我们要为 <code>Writer</code> 实现一个新的 <code>new_line</code> 方法：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new_line(</span><span style=color:#569cd6;>&mut </span><span>self) {
</span><span>        </span><span style=color:#569cd6;>for</span><span> row </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>1</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>{
</span><span>            </span><span style=color:#569cd6;>for</span><span> col </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>0</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>                </span><span style=color:#569cd6;>let</span><span> character = self.buffer.chars[row][col].read();
</span><span>                self.buffer.chars[row - </span><span style=color:#b5cea8;>1</span><span>][col].write(character);
</span><span>            }
</span><span>        }
</span><span>        self.clear_row(</span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>- </span><span style=color:#b5cea8;>1</span><span>);
</span><span>        self.column_position = </span><span style=color:#b5cea8;>0</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#569cd6;>fn </span><span>clear_row(</span><span style=color:#569cd6;>&mut </span><span>self, row: </span><span style=color:#569cd6;>usize</span><span>) {</span><span style=color:#608b4e;>/* TODO */</span><span>}
</span><span>}
</span></code></pre><p>我们遍历每个屏幕上的字符，把每个字符移动到它上方一行的相应位置。这里，<code>..</code> 符号是<strong>区间标号</strong>（range notation）的一种；它表示左闭右开的区间，因此不包含它的上界。在外层的枚举中，我们从第 1 行开始，省略了对第 0 行的枚举过程——因为这一行应该被移出屏幕，即它将被下一行的字符覆写。<p>所以我们实现的 <code>clear_row</code> 方法代码如下：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>clear_row(</span><span style=color:#569cd6;>&mut </span><span>self, row: </span><span style=color:#569cd6;>usize</span><span>) {
</span><span>        </span><span style=color:#569cd6;>let</span><span> blank = ScreenChar {
</span><span>            ascii_character: </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>' '</span><span>,
</span><span>            color_code: self.color_code,
</span><span>        };
</span><span>        </span><span style=color:#569cd6;>for</span><span> col </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>0</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>            self.buffer.chars[row][col].write(blank);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>通过向对应的缓冲区写入空格字符，这个方法能清空一整行的字符位置。<h2 id=quan-ju-jie-kou><a aria-label="Anchor link for: quan-ju-jie-kou" class=zola-anchor href=#quan-ju-jie-kou>🔗</a>全局接口</h2><p>编写其它模块时，我们希望无需随时拥有 <code>Writer</code> 实例，便能使用它的方法。我们尝试创建一个静态的 <code>WRITER</code> 变量：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub static </span><span style=color:#b4cea8;>WRITER</span><span>: Writer = Writer {
</span><span>    column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>    color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>    buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>};
</span></code></pre><p>我们尝试编译这些代码，却发生了下面的编译错误：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
</span><span> --> src/vga_buffer.rs:7:17
</span><span>  |
</span><span>7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>
</span><span>error[E0396]: raw pointers cannot be dereferenced in statics
</span><span> --> src/vga_buffer.rs:8:22
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant
</span><span>
</span><span>error[E0017]: references in statics may only refer to immutable values
</span><span> --> src/vga_buffer.rs:8:22
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
</span><span>
</span><span>error[E0017]: references in statics may only refer to immutable values
</span><span> --> src/vga_buffer.rs:8:13
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
</span></code></pre><p>为了明白现在发生了什么，我们需要知道一点：一般的变量在运行时初始化，而静态变量在编译时初始化。Rust编译器规定了一个称为<strong>常量求值器</strong>（<a href=https://rustc-dev-guide.rust-lang.org/const-eval.html>const evaluator</a>）的组件，它应该在编译时处理这样的初始化工作。虽然它目前的功能较为有限，但对它的扩展工作进展活跃，比如允许在常量中 panic 的<a href=https://github.com/rust-lang/rfcs/pull/2345>一篇 RFC 文档</a>。<p>关于 <code>ColorCode::new</code> 的问题应该能使用<strong>常函数</strong>（<a href=https://doc.rust-lang.org/reference/const_eval.html#const-functions><code>const</code> functions</a>）解决，但常量求值器还存在不完善之处，它还不能在编译时直接转换裸指针到变量的引用——也许未来这段代码能够工作，但在那之前，我们需要寻找另外的解决方案。<h3 id=yan-chi-chu-shi-hua><a aria-label="Anchor link for: yan-chi-chu-shi-hua" class=zola-anchor href=#yan-chi-chu-shi-hua>🔗</a>延迟初始化</h3><p>使用非常函数初始化静态变量是 Rust 程序员普遍遇到的问题。幸运的是，有一个叫做 <a href=https://docs.rs/lazy_static/1.0.1/lazy_static/>lazy_static</a> 的包提供了一个很棒的解决方案：它提供了名为 <code>lazy_static!</code> 的宏，定义了一个<strong>延迟初始化</strong>（lazily initialized）的静态变量；这个变量的值将在第一次使用时计算，而非在编译时计算。这时，变量的初始化过程将在运行时执行，任意的初始化代码——无论简单或复杂——都是能够使用的。<p>现在，我们将 <code>lazy_static</code> 包导入到我们的项目：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies.lazy_static</span><span>]
</span><span style=color:#569cd6;>version </span><span>= </span><span style=color:#d69d85;>"1.0"
</span><span style=color:#569cd6;>features </span><span>= [</span><span style=color:#d69d85;>"spin_no_std"</span><span>]
</span></code></pre><p>在这里，由于程序不连接标准库，我们需要启用 <code>spin_no_std</code> 特性。<p>使用 <code>lazy_static</code> 我们就可以定义一个不出问题的 <code>WRITER</code> 变量：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>pub static ref </span><span style=color:#b4cea8;>WRITER</span><span>: Writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>}
</span></code></pre><p>然而，这个 <code>WRITER</code> 可能没有什么用途，因为它目前还是<strong>不可变变量</strong>（immutable variable）：这意味着我们无法向它写入数据，因为所有与写入数据相关的方法都需要实例的可变引用 <code>&mut self</code>。一种解决方案是使用<strong>可变静态</strong>（<a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable>mutable static</a>）的变量，但所有对它的读写操作都被规定为不安全的（unsafe）操作，因为这很容易导致数据竞争或发生其它不好的事情——使用 <code>static mut</code> 极其不被赞成，甚至有一些提案认为<a href=https://internals.rust-lang.org/t/pre-rfc-remove-static-mut/1437>应该将它删除</a>。也有其它的替代方案，比如可以尝试使用比如 <a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#keeping-track-of-borrows-at-runtime-with-refcellt>RefCell</a> 或甚至 <a href=https://doc.rust-lang.org/nightly/core/cell/struct.UnsafeCell.html>UnsafeCell</a> 等类型提供的<strong>内部可变性</strong>（<a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html>interior mutability</a>）；但这些类型都被设计为非同步类型，即不满足 <a href=https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html>Sync</a> 约束，所以我们不能在静态变量中使用它们。<h3 id=zi-xuan-suo><a aria-label="Anchor link for: zi-xuan-suo" class=zola-anchor href=#zi-xuan-suo>🔗</a>自旋锁</h3><p>要定义同步的内部可变性，我们往往使用标准库提供的互斥锁类 <a href=https://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html>Mutex</a>，它通过提供当资源被占用时将线程<strong>阻塞</strong>（block）的<strong>互斥条件</strong>（mutual exclusion）实现这一点；但我们初步的内核代码还没有线程和阻塞的概念，我们将不能使用这个类。不过，我们还有一种较为基础的互斥锁实现方式——<strong>自旋锁</strong>（<a href=https://en.wikipedia.org/wiki/Spinlock>spinlock</a>）。自旋锁并不会调用阻塞逻辑，而是在一个小的无限循环中反复尝试获得这个锁，也因此会一直占用 CPU 时间，直到互斥锁被它的占用者释放。<p>为了使用自旋的互斥锁，我们添加 <a href=https://crates.io/crates/spin>spin包</a> 到项目的依赖项列表：<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>spin </span><span>= </span><span style=color:#d69d85;>"0.4.9"
</span></code></pre><p>现在，我们能够使用自旋的互斥锁，为我们的 <code>WRITER</code> 类实现安全的<a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html>内部可变性</a>：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>spin::Mutex;
</span><span style=color:#569cd6;>...
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>pub static ref </span><span style=color:#b4cea8;>WRITER</span><span>: Mutex&LTWriter> = Mutex::new(Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    });
</span><span>}
</span></code></pre><p>现在我们可以删除 <code>print_something</code> 函数，尝试直接在 <code>_start</code> 函数中打印字符：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    vga_buffer::</span><span style=color:#b4cea8;>WRITER</span><span>.lock().write_str(</span><span style=color:#d69d85;>"Hello again"</span><span>).unwrap();
</span><span>    write!(vga_buffer::WRITER.lock(), </span><span style=color:#d69d85;>", some numbers: </span><span style=color:#b4cea8;>{} {}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#b5cea8;>42</span><span>, </span><span style=color:#b5cea8;>1.337</span><span>).unwrap();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>在这里，我们需要导入名为 <code>fmt::Write</code> 的 trait，来使用实现它的类的相应方法。<h3 id=an-quan-xing><a aria-label="Anchor link for: an-quan-xing" class=zola-anchor href=#an-quan-xing>🔗</a>安全性</h3><p>经过上面的努力后，我们现在的代码只剩一个 unsafe 语句块，它用于创建一个指向 <code>0xb8000</code> 地址的 <code>Buffer</code> 类型引用；在这步之后，所有的操作都是安全的。Rust 将为每个数组访问检查边界，所以我们不会在不经意间越界到缓冲区之外。因此，我们把需要的条件编码到 Rust 的类型系统，这之后，我们为外界提供的接口就符合内存安全原则了。<h3 id=println-hong><a aria-label="Anchor link for: println-hong" class=zola-anchor href=#println-hong>🔗</a><code>println!</code> 宏</h3><p>现在我们有了一个全局的 <code>Writer</code> 实例，我们就可以基于它实现 <code>println!</code> 宏，这样它就能被任意地方的代码使用了。Rust 提供的<a href=https://doc.rust-lang.org/nightly/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming>宏定义语法</a>需要时间理解，所以我们将不从零开始编写这个宏。我们先看看标准库中 <a href=https://doc.rust-lang.org/nightly/std/macro.println!.html><code>println!</code> 宏的实现源码</a>：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[macro_export]
</span><span>macro_rules! println {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>(print!(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>));
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>(print!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span></code></pre><p>宏是通过一个或多个<strong>规则</strong>（rule）定义的，这就像 <code>match</code> 语句的多个分支。<code>println!</code> 宏有两个规则：第一个规则不要求传入参数——就比如 <code>println!()</code> ——它将被扩展为 <code>print!("\n")</code>，因此只会打印一个新行；第二个要求传入参数——好比 <code>println!("Rust 能够编写操作系统")</code> 或 <code>println!("我学习 Rust 已经{}年了", 3)</code>——它将使用 <code>print!</code> 宏扩展，传入它需求的所有参数，并在输出的字符串最后加入一个换行符 <code>\n</code>。<p>这里，<code>#[macro_export]</code> 属性让整个包（crate）和基于它的包都能访问这个宏，而不仅限于定义它的模块（module）。它还将把宏置于包的根模块（crate root）下，这意味着比如我们需要通过 <code>use std::println</code> 来导入这个宏，而不是通过 <code>std::macros::println</code>。<p><a href=https://doc.rust-lang.org/nightly/std/macro.print!.html><code>print!</code> 宏</a>是这样定义的：<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>#[macro_export]
</span><span>macro_rules! print {
</span><span>    ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));
</span><span>}
</span></code></pre><p>这个宏将扩展为一个对 <code>io</code> 模块中 <a href=https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698><code>_print</code> 函数</a>的调用。<a href=https://doc.rust-lang.org/1.30.0/book/first-edition/macros.html#the-variable-crate><code>$crate</code> 变量</a>将在 <code>std</code> 包之外被解析为 <code>std</code> 包，保证整个宏在 <code>std</code> 包之外也可以使用。<p><a href=https://doc.rust-lang.org/nightly/std/macro.format_args.html><code>format_args!</code> 宏</a>将传入的参数搭建为一个 <a href=https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html>fmt::Arguments</a> 类型，这个类型将被传入 <code>_print</code> 函数。<code>std</code> 包中的 <a href=https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698><code>_print</code> 函数</a>将调用复杂的私有函数 <code>print_to</code>，来处理对不同 <code>Stdout</code> 设备的支持。我们不需要编写这样的复杂函数，因为我们只需要打印到 VGA 字符缓冲区。<p>要打印到字符缓冲区，我们把 <code>println!</code> 和 <code>print!</code> 两个宏复制过来，但修改部分代码，让这些宏使用我们定义的 <code>_print</code> 函数：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[macro_export]
</span><span>macro_rules! print {
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::vga_buffer::_print(format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span><span>
</span><span>#[macro_export]
</span><span>macro_rules! println {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>($crate::print</span><span style=color:#569cd6;>!</span><span>(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>));
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::print</span><span style=color:#569cd6;>!</span><span>(</span><span style=color:#d69d85;>"{}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span><span>
</span><span>#[doc(hidden)]
</span><span style=color:#569cd6;>pub fn </span><span>_print(args: fmt::Arguments) {
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    </span><span style=color:#b4cea8;>WRITER</span><span>.lock().write_fmt(args).unwrap();
</span><span>}
</span></code></pre><p>我们首先修改了 <code>println!</code> 宏，在每个使用的 <code>print!</code> 宏前面添加了 <code>$crate</code> 变量。这样我们在只需要使用 <code>println!</code> 时，不必也编写代码导入 <code>print!</code> 宏。<p>就像标准库做的那样，我们为两个宏都添加了 <code>#[macro_export]</code> 属性，这样在包的其它地方也可以使用它们。需要注意的是，这将占用包的<strong>根命名空间</strong>（root namespace），所以我们不能通过 <code>use crate::vga_buffer::println</code> 来导入它们；我们应该使用 <code>use crate::println</code>。<p>另外，<code>_print</code> 函数将占有静态变量 <code>WRITER</code> 的锁，并调用它的 <code>write_fmt</code> 方法。这个方法是从名为 <code>Write</code> 的 trait 中获得的，所以我们需要导入这个 trait。额外的 <code>unwrap()</code> 函数将在打印不成功的时候 panic；但既然我们的 <code>write_str</code> 总是返回 <code>Ok</code>，这种情况不应该发生。<p>如果这个宏将能在模块外访问，它们也应当能访问 <code>_print</code> 函数，因此这个函数必须是公有的（public）。然而，考虑到这是一个私有的实现细节，我们添加一个 <a href=https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#dochidden><code>doc(hidden)</code> 属性</a>，防止它在生成的文档中出现。<h3 id=shi-yong-println-de-hello-world><a aria-label="Anchor link for: shi-yong-println-de-hello-world" class=zola-anchor href=#shi-yong-println-de-hello-world>🔗</a>使用 <code>println!</code> 的 Hello World</h3><p>现在，我们可以在 <code>_start</code> 里使用 <code>println!</code> 了：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() {
</span><span>    println!(</span><span style=color:#d69d85;>"Hello World</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#d69d85;>"!"</span><span>);
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>要注意的是，我们在入口函数中不需要导入这个宏——因为它已经被置于包的根命名空间了。<p>运行这段代码，和我们预料的一样，一个 <em>“Hello World!”</em> 字符串被打印到了屏幕上：<p><img alt="QEMU printing “Hello World!”" src=https://os.phil-opp.com/vga-text-mode/vga-hello-world.png><h3 id=da-yin-panic-xin-xi><a aria-label="Anchor link for: da-yin-panic-xin-xi" class=zola-anchor href=#da-yin-panic-xin-xi>🔗</a>打印 panic 信息</h3><p>既然我们已经有了 <code>println!</code> 宏，我们可以在 panic 处理函数中，使用它打印 panic 信息和 panic 产生的位置：<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in main.rs
</span><span>
</span><span style=color:#608b4e;>/// 这个函数将在 panic 发生时被调用
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>当我们在 <code>_start</code> 函数中插入一行 <code>panic!("Some panic message");</code> 后，我们得到了这样的输出：<p><img alt="QEMU printing “panicked at ‘Some panic message’, src/main.rs:28:5" src=https://os.phil-opp.com/vga-text-mode/vga-panic.png><p>所以，现在我们不仅能知道 panic 已经发生，还能够知道 panic 信息和产生 panic 的代码。<h2 id=xiao-jie><a aria-label="Anchor link for: xiao-jie" class=zola-anchor href=#xiao-jie>🔗</a>小结</h2><p>这篇文章中，我们学习了 VGA 字符缓冲区的结构，以及如何在 <code>0xb8000</code> 的内存映射地址访问它。我们将所有的不安全操作包装为一个 Rust 模块，以便在外界安全地访问它。<p>我们也发现了——感谢便于使用的 cargo——在 Rust 中使用第三方提供的包是及其容易的。我们添加的两个依赖项，<code>lazy_static</code> 和 <code>spin</code>，都在操作系统开发中及其有用；我们将在未来的文章中多次使用它们。<h2 id=xia-pian-yu-gao><a aria-label="Anchor link for: xia-pian-yu-gao" class=zola-anchor href=#xia-pian-yu-gao>🔗</a>下篇预告</h2><p>下一篇文章中，我们将会讲述如何配置 Rust 内置的单元测试框架。我们还将为本文编写的 VGA 缓冲区模块添加基础的单元测试项目。</div><div class=post-footer-support><h2>Support Me</h2><p>Creating and <a href=https://os.phil-opp.com/status-update/>maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.<p>The best way to support me is to <a href=https://github.com/sponsors/phil-opp><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href=https://www.patreon.com/phil_opp><em>Patreon</em></a> and <a href=https://donorbox.org/phil-opp><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.<p>Thank you!</div><hr><div class=PageNavigation><a class=prev href=/zh-CN/minimal-rust-kernel/>« 最小化内核</a><a class=next href=/zh-CN/testing/>内核测试 »</a></div><hr><section><h2 id=comments>评论</h2><p class=comment-note>Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href=https://www.rust-lang.org/policies/code-of-conduct>code of conduct</a>. This comment thread directly maps to a <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="VGA Text Mode (zh-CN)"'><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.<div class=giscus></div><script data-category="Post Comments" data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ==" data-term="VGA Text Mode (zh-CN)" async crossorigin=anonymous data-category-id=MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1 data-emit-metadata=1 data-mapping=specific data-reactions-enabled=1 data-repo=phil-opp/blog_os data-theme=preferred_color_scheme src=https://giscus.app/client.js></script><p class=comment-directly-on-github>Instead of authenticating the <a href=https://giscus.app>giscus</a> application, you can also comment directly <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="VGA Text Mode (zh-CN)"'><em>on GitHub</em></a>.<p>请尽可能使用英语评论。</section><aside class=page-aside-right><div class=block id=language-selector><h2>Other Languages</h2><ul><li data-lang-switch-to=en><a href=https://os.phil-opp.com/vga-text-mode/> English (original) </a><li data-lang-switch-to=ja><a href=https://os.phil-opp.com/ja/vga-text-mode/> Japanese </a><li data-lang-switch-to=fa><a href=https://os.phil-opp.com/fa/vga-text-mode/> Persian </a></ul></div><div class="dark-mode-note warning"><h2>Dark Mode is Experimental</h2><p>We're still working on adjusting text colors, fixing images, and removing inconsistencies. If you have any problems, please <a href=https://github.com/phil-opp/blog_os/issues>file an issue</a>.<aside></aside><main><div><div></div><footer class=footer><hr><small> © <time datetime=2021>2021</time>. All rights reserved. <a href=https://os.phil-opp.com/contact/>Contact</a> </small></footer></div><script async data-goatcounter=https://phil-opp.goatcounter.com/count src=//gc.zgo.at/count.js></script>