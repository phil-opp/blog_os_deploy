<!doctype html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="Philipp Oppermann">

    
        <link rel="canonical" href="https://os.phil-opp.com/double-fault-exceptions/" />
    
    <link href="/css/poole.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">

    <script async src="/js/main.js"></script>

    <title>Double Faults | Writing an OS in Rust</title>
</head>

<body>
    <div class="container content">
        <header class="masthead">
            <div style="position:relative">
                <h1 class="masthead-title">
                    <a href="https:&#x2F;&#x2F;os.phil-opp.com" title="Home">Writing an OS in Rust (Second Edition)</a>
                </h1>
                <p><small>Philipp&amp;nbsp;Oppermann&#x27;s&amp;nbsp;blog</small></p>
                
    <aside id="all-posts-link"><a href="https:&#x2F;&#x2F;os.phil-opp.com" title="All Posts">¬´ All Posts</a></aside>

            </div>
        </header>

        <main>
    <h1>Double Faults</h1>
    <time datetime="2018-06-18" class="post-date">
        Jun 18, 2018
        
    </time>

    <aside id="toc-aside">
        <h2>Table of Contents</h2>
        <ol>
            <li>
                <a href="#what-is-a-double-fault">What is a Double Fault?</a>
                <ol>
                    <li>
                        <a href="#triggering-a-double-fault">Triggering a Double Fault</a>
                    </li>
                </ol>
            </li><li>
                <a href="#a-double-fault-handler">A Double Fault Handler</a>
                
            </li><li>
                <a href="#causes-of-double-faults">Causes of Double Faults</a>
                <ol>
                    <li>
                        <a href="#kernel-stack-overflow">Kernel Stack Overflow</a>
                    </li>
                </ol>
            </li><li>
                <a href="#switching-stacks">Switching Stacks</a>
                <ol>
                    <li>
                        <a href="#the-ist-and-tss">The IST and TSS</a>
                    </li><li>
                        <a href="#creating-a-tss">Creating a TSS</a>
                    </li><li>
                        <a href="#the-global-descriptor-table">The Global Descriptor Table</a>
                    </li><li>
                        <a href="#the-final-steps">The final Steps</a>
                    </li>
                </ol>
            </li><li>
                <a href="#a-stack-overflow-test">A Stack Overflow Test</a>
                <ol>
                    <li>
                        <a href="#implementing-start">Implementing _start</a>
                    </li><li>
                        <a href="#the-test-idt">The Test IDT</a>
                    </li><li>
                        <a href="#the-double-fault-handler">The Double Fault Handler</a>
                    </li>
                </ol>
            </li><li>
                <a href="#summary">Summary</a>
                
            </li><li>
                <a href="#what-s-next">What's next?</a>
                
            </li>
        </ol>
    </aside>

    

    <p>This post explores the double fault exception in detail, which occurs when the CPU fails to invoke an exception handler. By handling this exception we avoid fatal <em>triple faults</em> that cause a system reset. To prevent triple faults in all cases we also set up an <em>Interrupt Stack Table</em> to catch double faults on a separate kernel stack.</p>
<p id="zola-continue-reading"><a name="continue-reading"></a></p>
<p>This blog is openly developed on <a href="https://github.com/phil-opp/blog_os">GitHub</a>. If you have any problems or questions, please open an issue there. You can also leave comments <a href="https://os.phil-opp.com/double-fault-exceptions/#comments">at the bottom</a>.  The complete source code for this post can be found in the <a href="https://github.com/phil-opp/blog_os/tree/post-06"><code>post-06</code></a> branch.</p>

    <details id = "toc-inline">
        <summary><b>Table of Contents</b></summary>
        <ul>
            <li>
                <a href="#what-is-a-double-fault">What is a Double Fault?</a>
                <ul>
                    <li>
                        <a href="#triggering-a-double-fault">Triggering a Double Fault</a>
                    </li>
                </ul>
            </li><li>
                <a href="#a-double-fault-handler">A Double Fault Handler</a>
                
            </li><li>
                <a href="#causes-of-double-faults">Causes of Double Faults</a>
                <ul>
                    <li>
                        <a href="#kernel-stack-overflow">Kernel Stack Overflow</a>
                    </li>
                </ul>
            </li><li>
                <a href="#switching-stacks">Switching Stacks</a>
                <ul>
                    <li>
                        <a href="#the-ist-and-tss">The IST and TSS</a>
                    </li><li>
                        <a href="#creating-a-tss">Creating a TSS</a>
                    </li><li>
                        <a href="#the-global-descriptor-table">The Global Descriptor Table</a>
                    </li><li>
                        <a href="#the-final-steps">The final Steps</a>
                    </li>
                </ul>
            </li><li>
                <a href="#a-stack-overflow-test">A Stack Overflow Test</a>
                <ul>
                    <li>
                        <a href="#implementing-start">Implementing _start</a>
                    </li><li>
                        <a href="#the-test-idt">The Test IDT</a>
                    </li><li>
                        <a href="#the-double-fault-handler">The Double Fault Handler</a>
                    </li>
                </ul>
            </li><li>
                <a href="#summary">Summary</a>
                
            </li><li>
                <a href="#what-s-next">What's next?</a>
                
            </li>
        </ul>
    </details>

<h2 id="what-is-a-double-fault"><a class="zola-anchor" href="#what-is-a-double-fault" aria-label="Anchor link for: what-is-a-double-fault">üîó</a>What is a Double Fault?</h2>
<p>In simplified terms, a double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered but there is no page fault handler registered in the <a href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">Interrupt Descriptor Table</a> (IDT). So it's kind of similar to catch-all blocks in programming languages with exceptions, e.g. <code>catch(...)</code> in C++ or <code>catch(Exception e)</code> in Java or C#.</p>
<p>A double fault behaves like a normal exception. It has the vector number <code>8</code> and we can define a normal handler function for it in the IDT. It is really important to provide a double fault handler, because if a double fault is unhandled a fatal <em>triple fault</em> occurs. Triple faults can't be caught and most hardware reacts with a system reset.</p>
<h3 id="triggering-a-double-fault"><a class="zola-anchor" href="#triggering-a-double-fault" aria-label="Anchor link for: triggering-a-double-fault">üîó</a>Triggering a Double Fault</h3>
<p>Let's provoke a double fault by triggering an exception for that we didn't define a handler function:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/main.rs

</span><span style="color:#dcdcdc;">#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">_start() -&gt; </span><span style="color:#569cd6;">! </span><span style="color:#dcdcdc;">{
    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, </span><span style="color:#d69d85;">&quot;!&quot;</span><span style="color:#dcdcdc;">);

    blog_os::init();

    </span><span style="color:#608b4e;">// trigger a page fault
    </span><span style="color:#569cd6;">unsafe </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">*</span><span style="color:#dcdcdc;">(</span><span style="color:#b5cea8;">0xdeadbeef </span><span style="color:#569cd6;">as *mut u64</span><span style="color:#dcdcdc;">) </span><span style="color:#569cd6;">= </span><span style="color:#b5cea8;">42</span><span style="color:#dcdcdc;">;
    };

    </span><span style="color:#608b4e;">// as before
    </span><span style="color:#dcdcdc;">#[cfg(test)]
    test_main();

    println!(</span><span style="color:#d69d85;">&quot;It did not crash!&quot;</span><span style="color:#dcdcdc;">);
    </span><span style="color:#569cd6;">loop </span><span style="color:#dcdcdc;">{}
}
</span></pre>
<p>We use <code>unsafe</code> to write to the invalid address <code>0xdeadbeef</code>. The virtual address is not mapped to a physical address in the page tables, so a page fault occurs. We haven't registered a page fault handler in our <a href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">IDT</a>, so a double fault occurs.</p>
<p>When we start our kernel now, we see that it enters an endless boot loop. The reason for the boot loop is the following:</p>
<ol>
<li>The CPU tries to write to <code>0xdeadbeef</code>, which causes a page fault.</li>
<li>The CPU looks at the corresponding entry in the IDT and sees that the present bit isn't set. Thus, it can't call the page fault handler and a double fault occurs.</li>
<li>The CPU looks at the IDT entry of the double fault handler, but this entry is also non-present. Thus, a <em>triple</em> fault occurs.</li>
<li>A triple fault is fatal. QEMU reacts to it like most real hardware and issues a system reset.</li>
</ol>
<p>So in order to prevent this triple fault, we need to either provide a handler function for page faults or a double fault handler. We want to avoid triple faults in all cases, so let's start with a double fault handler that is invoked for all unhandled exception types.</p>
<h2 id="a-double-fault-handler"><a class="zola-anchor" href="#a-double-fault-handler" aria-label="Anchor link for: a-double-fault-handler">üîó</a>A Double Fault Handler</h2>
<p>A double fault is a normal exception with an error code, so we can specify a handler function similar to our breakpoint handler:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/interrupts.rs

</span><span style="color:#dcdcdc;">lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span style="color:#dcdcdc;">: InterruptDescriptorTable </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> idt </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt.double_fault.set_handler_fn(double_fault_handler); </span><span style="color:#608b4e;">// new
</span><span style="color:#dcdcdc;">        idt
    };
}

</span><span style="color:#608b4e;">// new
</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">double_fault_handler(
    stack_frame: </span><span style="color:#569cd6;">&amp;mut</span><span style="color:#dcdcdc;"> InterruptStackFrame, _error_code: </span><span style="color:#569cd6;">u64</span><span style="color:#dcdcdc;">)
{
    panic!(</span><span style="color:#d69d85;">&quot;EXCEPTION: DOUBLE FAULT</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">{:#?}&quot;</span><span style="color:#dcdcdc;">, stack_frame);
}
</span></pre>
<p>Our handler prints a short error message and dumps the exception stack frame. The error code of the double fault handler is always zero, so there's no reason to print it.</p>
<p>When we start our kernel now, we should see that the double fault handler is invoked:</p>
<p><img src="https://os.phil-opp.com/double-fault-exceptions/qemu-catch-double-fault.png" alt="QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame" /></p>
<p>It worked! Here is what happens this time:</p>
<ol>
<li>The CPU executes tries to write to <code>0xdeadbeef</code>, which causes a page fault.</li>
<li>Like before, the CPU looks at the corresponding entry in the IDT and sees that the present bit isn't set. Thus, a double fault occurs.</li>
<li>The CPU jumps to the ‚Äì now present ‚Äì double fault handler.</li>
</ol>
<p>The triple fault (and the boot-loop) no longer occurs, since the CPU can now call the double fault handler.</p>
<p>That was quite straightforward! So why do we need a whole post for this topic? Well, we're now able to catch <em>most</em> double faults, but there are some cases where our current approach doesn't suffice.</p>
<h2 id="causes-of-double-faults"><a class="zola-anchor" href="#causes-of-double-faults" aria-label="Anchor link for: causes-of-double-faults">üîó</a>Causes of Double Faults</h2>
<p>Before we look at the special cases, we need to know the exact causes of double faults. Above, we used a pretty vague definition:</p>
<blockquote>
<p>A double fault is a special exception that occurs when the CPU fails to invoke an exception handler.</p>
</blockquote>
<p>What does <em>‚Äúfails to invoke‚Äù</em> mean exactly? The handler is not present? The handler is <a href="http://pages.cs.wisc.edu/%7Eremzi/OSTEP/vm-beyondphys.pdf">swapped out</a>? And what happens if a handler causes exceptions itself?</p>
<p>For example, what happens if:</p>
<ol>
<li>a breakpoint exception occurs, but the corresponding handler function is swapped out?</li>
<li>a page fault occurs, but the page fault handler is swapped out?</li>
<li>a divide-by-zero handler causes a breakpoint exception, but the breakpoint handler is swapped out?</li>
<li>our kernel overflows its stack and the <em>guard page</em> is hit?</li>
</ol>
<p>Fortunately, the AMD64 manual (<a href="https://www.amd.com/system/files/TechDocs/24593.pdf">PDF</a>) has an exact definition (in Section 8.2.9). According to it, a ‚Äúdouble fault exception <em>can</em> occur when a second exception occurs during the handling of a prior (first) exception handler‚Äù. The <em>‚Äúcan‚Äù</em> is important: Only very specific combinations of exceptions lead to a double fault. These combinations are:</p>
<table><thead><tr><th>First Exception</th><th>Second Exception</th></tr></thead><tbody>
<tr><td><a href="http://wiki.osdev.org/Exceptions#Divide-by-zero_Error">Divide-by-zero</a>,<br><a href="http://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="http://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="http://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="http://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td><td><a href="http://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="http://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="http://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="http://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td></tr>
<tr><td><a href="http://wiki.osdev.org/Exceptions#Page_Fault">Page Fault</a></td><td><a href="http://wiki.osdev.org/Exceptions#Page_Fault">Page Fault</a>,<br><a href="http://wiki.osdev.org/Exceptions#Invalid_TSS">Invalid TSS</a>,<br><a href="http://wiki.osdev.org/Exceptions#Segment_Not_Present">Segment Not Present</a>,<br><a href="http://wiki.osdev.org/Exceptions#Stack-Segment_Fault">Stack-Segment Fault</a>,<br><a href="http://wiki.osdev.org/Exceptions#General_Protection_Fault">General Protection Fault</a></td></tr>
</tbody></table>
<p>So for example a divide-by-zero fault followed by a page fault is fine (the page fault handler is invoked), but a divide-by-zero fault followed by a general-protection fault leads to a double fault.</p>
<p>With the help of this table, we can answer the first three of the above questions:</p>
<ol>
<li>If a breakpoint exception occurs and the corresponding handler function is swapped out, a <em>page fault</em> occurs and the <em>page fault handler</em> is invoked.</li>
<li>If a page fault occurs and the page fault handler is swapped out, a <em>double fault</em> occurs and the <em>double fault handler</em> is invoked.</li>
<li>If a divide-by-zero handler causes a breakpoint exception, the CPU tries to invoke the breakpoint handler. If the breakpoint handler is swapped out, a <em>page fault</em> occurs and the <em>page fault handler</em> is invoked.</li>
</ol>
<p>In fact, even the case of a non-present handler follows this scheme: A non-present handler causes a <em>segment-not-present</em> exception. We didn't define a segment-not-present handler, so another segment-not-present exception occurs. According to the table, this leads to a double fault.</p>
<h3 id="kernel-stack-overflow"><a class="zola-anchor" href="#kernel-stack-overflow" aria-label="Anchor link for: kernel-stack-overflow">üîó</a>Kernel Stack Overflow</h3>
<p>Let's look at the fourth question:</p>
<blockquote>
<p>What happens if our kernel overflows its stack and the guard page is hit?</p>
</blockquote>
<p>A guard page is a special memory page at the bottom of a stack that makes it possible to detect stack overflows. The page is not mapped to any physical frame, so accessing it causes a page fault instead of silently corrupting other memory. The bootloader sets up a guard page for our kernel stack, so a stack overflow causes a <em>page fault</em>.</p>
<p>When a page fault occurs the CPU looks up the page fault handler in the IDT and tries to push the <a href="http://os.phil-opp.com/better-exception-messages.html#exceptions-in-detail">exception stack frame</a> onto the stack. However, the current stack pointer still points to the non-present guard page. Thus, a second page fault occurs, which causes a double fault (according to the above table).</p>
<p>So the CPU tries to call the <em>double fault handler</em> now. However, on a double fault the CPU tries to push the exception stack frame, too. The stack pointer still points to the guard page, so a <em>third</em> page fault occurs, which causes a <em>triple fault</em> and a system reboot. So our current double fault handler can't avoid a triple fault in this case.</p>
<p>Let's try it ourselves! We can easily provoke a kernel stack overflow by calling a function that recurses endlessly:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/main.rs

</span><span style="color:#dcdcdc;">#[no_mangle] </span><span style="color:#608b4e;">// don&#39;t mangle the name of this function
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">_start() -&gt; </span><span style="color:#569cd6;">! </span><span style="color:#dcdcdc;">{
    println!(</span><span style="color:#d69d85;">&quot;Hello World</span><span style="color:#b4cea8;">{}</span><span style="color:#d69d85;">&quot;</span><span style="color:#dcdcdc;">, </span><span style="color:#d69d85;">&quot;!&quot;</span><span style="color:#dcdcdc;">);

    blog_os::init();

    </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">stack_overflow() {
        stack_overflow(); </span><span style="color:#608b4e;">// for each recursion, the return address is pushed
    </span><span style="color:#dcdcdc;">}

    </span><span style="color:#608b4e;">// trigger a stack overflow
    </span><span style="color:#dcdcdc;">stack_overflow();

    [‚Ä¶] </span><span style="color:#608b4e;">// test_main(), println(‚Ä¶), and loop {}
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>When we try this code in QEMU, we see that the system enters a boot-loop again.</p>
<p>So how can we avoid this problem? We can't omit the pushing of the exception stack frame, since the CPU itself does it. So we need to ensure somehow that the stack is always valid when a double fault exception occurs. Fortunately, the x86_64 architecture has a solution to this problem.</p>
<h2 id="switching-stacks"><a class="zola-anchor" href="#switching-stacks" aria-label="Anchor link for: switching-stacks">üîó</a>Switching Stacks</h2>
<p>The x86_64 architecture is able to switch to a predefined, known-good stack when an exception occurs. This switch happens at hardware level, so it can be performed before the CPU pushes the exception stack frame.</p>
<p>The switching mechanism is implemented as an <em>Interrupt Stack Table</em> (IST). The IST is a table of 7 pointers to known-good stacks. In Rust-like pseudo code:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#569cd6;">struct </span><span style="color:#dcdcdc;">InterruptStackTable {
    stack_pointers: [Option&lt;StackPointer&gt;; 7],
}
</span></pre>
<p>For each exception handler, we can choose a stack from the IST through the <code>stack_pointers</code> field in the corresponding <a href="https://os.phil-opp.com/cpu-exceptions/#the-interrupt-descriptor-table">IDT entry</a>. For example, we could use the first stack in the IST for our double fault handler. Then the CPU would automatically switch to this stack whenever a double fault occurs. This switch would happen before anything is pushed, so it would prevent the triple fault.</p>
<h3 id="the-ist-and-tss"><a class="zola-anchor" href="#the-ist-and-tss" aria-label="Anchor link for: the-ist-and-tss">üîó</a>The IST and TSS</h3>
<p>The Interrupt Stack Table (IST) is part of an old legacy structure called <em><a href="https://en.wikipedia.org/wiki/Task_state_segment">Task State Segment</a></em> (TSS). The TSS used to hold various information (e.g. processor register state) about a task in 32-bit mode and was for example used for <a href="http://wiki.osdev.org/Context_Switching#Hardware_Context_Switching">hardware context switching</a>. However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS changed completely.</p>
<p>On x86_64, the TSS no longer holds any task specific information at all. Instead, it holds two stack tables (the IST is one of them). The only common field between the 32-bit and 64-bit TSS is the pointer to the <a href="https://en.wikipedia.org/wiki/Task_state_segment#I.2FO_port_permissions">I/O port permissions bitmap</a>.</p>
<p>The 64-bit TSS has the following format:</p>
<table><thead><tr><th>Field</th><th>Type</th></tr></thead><tbody>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u32</code></td></tr>
<tr><td>Privilege Stack Table</td><td><code>[u64; 3]</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u64</code></td></tr>
<tr><td>Interrupt Stack Table</td><td><code>[u64; 7]</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u64</code></td></tr>
<tr><td><span style="opacity: 0.5">(reserved)</span></td><td><code>u16</code></td></tr>
<tr><td>I/O Map Base Address</td><td><code>u16</code></td></tr>
</tbody></table>
<p>The <em>Privilege Stack Table</em> is used by the CPU when the privilege level changes. For example, if an exception occurs while the CPU is in user mode (privilege level 3), the CPU normally switches to kernel mode (privilege level 0) before invoking the exception handler. In that case, the CPU would switch to the 0th stack in the Privilege Stack Table (since 0 is the target privilege level). We don't have any user mode programs yet, so we ignore this table for now.</p>
<h3 id="creating-a-tss"><a class="zola-anchor" href="#creating-a-tss" aria-label="Anchor link for: creating-a-tss">üîó</a>Creating a TSS</h3>
<p>Let's create a new TSS that contains a separate double fault stack in its interrupt stack table. For that we need a TSS struct. Fortunately, the <code>x86_64</code> crate already contains a <a href="https://docs.rs/x86_64/0.7.5/x86_64/structures/tss/struct.TaskStateSegment.html"><code>TaskStateSegment</code> struct</a> that we can use.</p>
<p>We create the TSS in a new <code>gdt</code> module (the name will make sense later):</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/lib.rs

</span><span style="color:#569cd6;">pub mod </span><span style="color:#dcdcdc;">gdt;

</span><span style="color:#608b4e;">// in src/gdt.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::VirtAddr;
</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::structures::tss::TaskStateSegment;
</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">lazy_static::lazy_static;

</span><span style="color:#569cd6;">pub const </span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span style="color:#dcdcdc;">: </span><span style="color:#569cd6;">u16 = </span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">;

lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">TSS</span><span style="color:#dcdcdc;">: TaskStateSegment </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> tss </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">TaskStateSegment::new();
        tss.interrupt_stack_table[</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX </span><span style="color:#569cd6;">as usize</span><span style="color:#dcdcdc;">] </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
            </span><span style="color:#569cd6;">const </span><span style="color:#b4cea8;">STACK_SIZE</span><span style="color:#dcdcdc;">: </span><span style="color:#569cd6;">usize = </span><span style="color:#b5cea8;">4096</span><span style="color:#dcdcdc;">;
            </span><span style="color:#569cd6;">static mut </span><span style="color:#b4cea8;">STACK</span><span style="color:#dcdcdc;">: [</span><span style="color:#569cd6;">u8</span><span style="color:#dcdcdc;">; </span><span style="color:#b4cea8;">STACK_SIZE</span><span style="color:#dcdcdc;">] </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">[</span><span style="color:#b5cea8;">0</span><span style="color:#dcdcdc;">; </span><span style="color:#b4cea8;">STACK_SIZE</span><span style="color:#dcdcdc;">];

            </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> stack_start </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">VirtAddr::from_ptr(</span><span style="color:#569cd6;">unsafe </span><span style="color:#dcdcdc;">{ </span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">STACK </span><span style="color:#dcdcdc;">});
            </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> stack_end </span><span style="color:#569cd6;">=</span><span style="color:#dcdcdc;"> stack_start </span><span style="color:#569cd6;">+ </span><span style="color:#b4cea8;">STACK_SIZE</span><span style="color:#dcdcdc;">;
            stack_end
        };
        tss
    };
}
</span></pre>
<p>We use <code>lazy_static</code> because Rust's const evaluator is not yet powerful enough to do this initialization at compile time. We define that the 0th IST entry is the double fault stack (any other IST index would work too). Then we write the top address of a double fault stack to the 0th entry. We write the top address because stacks on x86 grow downwards, i.e. from high addresses to low addresses.</p>
<p>We don't have implemented memory management yet, so we don't have a proper way to allocate a new stack. Instead, we use a <code>static mut</code> array as stack storage for now. The <code>unsafe</code> is required because the compiler can't guarantee race freedom when mutable statics are accessed. It is important that it is a <code>static mut</code> and not an immutable <code>static</code>, because otherwise the bootloader will map it to a read-only page. We will replace this with a proper stack allocation in a later post, then the <code>unsafe</code> will be no longer needed at this place.</p>
<p>Note that this double fault stack has no guard page that protects against stack overflow. This means that we should not do anything stack intensive in our double fault handler because a stack overflow might corrupt the memory below the stack.</p>
<h4 id="loading-the-tss"><a class="zola-anchor" href="#loading-the-tss" aria-label="Anchor link for: loading-the-tss">üîó</a>Loading the TSS</h4>
<p>Now that we created a new TSS, we need a way to tell the CPU that it should use it. Unfortunately this is a bit cumbersome, since the TSS uses the segmentation system (for historical reasons). Instead of loading the table directly, we need to add a new segment descriptor to the <a href="http://www.flingos.co.uk/docs/reference/Global-Descriptor-Table/">Global Descriptor Table</a> (GDT). Then we can load our TSS invoking the <a href="https://www.felixcloutier.com/x86/ltr"><code>ltr</code> instruction</a> with the respective GDT index. (This is the reason why we named our module <code>gdt</code>.)</p>
<h3 id="the-global-descriptor-table"><a class="zola-anchor" href="#the-global-descriptor-table" aria-label="Anchor link for: the-global-descriptor-table">üîó</a>The Global Descriptor Table</h3>
<p>The Global Descriptor Table (GDT) is a relict that was used for <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">memory segmentation</a> before paging became the de facto standard. It is still needed in 64-bit mode for various things such as kernel/user mode configuration or TSS loading.</p>
<p>The GDT is a structure that contains the <em>segments</em> of the program. It was used on older architectures to isolate programs from each other, before paging became the standard. For more information about segmentation check out the equally named chapter of the free <a href="http://pages.cs.wisc.edu/%7Eremzi/OSTEP/">‚ÄúThree Easy Pieces‚Äù book</a>. While segmentation is no longer supported in 64-bit mode, the GDT still exists. It is mostly used for two things: Switching between kernel space and user space, and loading a TSS structure.</p>
<h4 id="creating-a-gdt"><a class="zola-anchor" href="#creating-a-gdt" aria-label="Anchor link for: creating-a-gdt">üîó</a>Creating a GDT</h4>
<p>Let's create a static <code>GDT</code> that includes a segment for our <code>TSS</code> static:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/gdt.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::structures::gdt::{GlobalDescriptorTable, Descriptor};

lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">: GlobalDescriptorTable </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> gdt </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">GlobalDescriptorTable::new();
        gdt.add_entry(Descriptor::kernel_code_segment());
        gdt.add_entry(Descriptor::tss_segment(</span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">TSS</span><span style="color:#dcdcdc;">));
        gdt
    };
}
</span></pre>
<p>We use <code>lazy_static</code> again, because Rust's const evaluator is not powerful enough yet. We create a new GDT with a code segment and a TSS segment.</p>
<h4 id="loading-the-gdt"><a class="zola-anchor" href="#loading-the-gdt" aria-label="Anchor link for: loading-the-gdt">üîó</a>Loading the GDT</h4>
<p>To load our GDT we create a new <code>gdt::init</code> function, that we call from our <code>init</code> function:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/gdt.rs

</span><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">init() {
    </span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">.load();
}

</span><span style="color:#608b4e;">// in src/lib.rs

</span><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">init() {
    gdt::init();
    interrupts::init_idt();
}
</span></pre>
<p>Now our GDT is loaded (since the <code>_start</code> function calls <code>init</code>), but we still see the boot loop on stack overflow.</p>
<h3 id="the-final-steps"><a class="zola-anchor" href="#the-final-steps" aria-label="Anchor link for: the-final-steps">üîó</a>The final Steps</h3>
<p>The problem is that the GDT segments are not yet active because the segment and TSS registers still contain the values from the old GDT. We also need to modify the double fault IDT entry so that it uses the new stack.</p>
<p>In summary, we need to do the following:</p>
<ol>
<li><strong>Reload code segment register</strong>: We changed our GDT, so we should reload <code>cs</code>, the code segment register. This is required since the old segment selector could point a different GDT descriptor now (e.g. a TSS descriptor).</li>
<li><strong>Load the TSS</strong> : We loaded a GDT that contains a TSS selector, but we still need to tell the CPU that it should use that TSS.</li>
<li><strong>Update the IDT entry</strong>: As soon as our TSS is loaded, the CPU has access to a valid interrupt stack table (IST). Then we can tell the CPU that it should use our new double fault stack by modifying our double fault IDT entry.</li>
</ol>
<p>For the first two steps, we need access to the <code>code_selector</code> and <code>tss_selector</code> variables in our <code>gdt::init</code> function. We can achieve this by making them part of the static through a new <code>Selectors</code> struct:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/gdt.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::structures::gdt::SegmentSelector;

lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">: (GlobalDescriptorTable, Selectors) </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> gdt </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">GlobalDescriptorTable::new();
        </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> code_selector </span><span style="color:#569cd6;">=</span><span style="color:#dcdcdc;"> gdt.add_entry(Descriptor::kernel_code_segment());
        </span><span style="color:#569cd6;">let</span><span style="color:#dcdcdc;"> tss_selector </span><span style="color:#569cd6;">=</span><span style="color:#dcdcdc;"> gdt.add_entry(Descriptor::tss_segment(</span><span style="color:#569cd6;">&amp;</span><span style="color:#b4cea8;">TSS</span><span style="color:#dcdcdc;">));
        (gdt, Selectors { code_selector, tss_selector })
    };
}

</span><span style="color:#569cd6;">struct </span><span style="color:#dcdcdc;">Selectors {
    code_selector: SegmentSelector,
    tss_selector: SegmentSelector,
}
</span></pre>
<p>Now we can use the selectors to reload the <code>cs</code> segment register and load our <code>TSS</code>:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/gdt.rs

</span><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">init() {
    </span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::instructions::segmentation::set_cs;
    </span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::instructions::tables::load_tss;

    </span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">.</span><span style="color:#b5cea8;">0.</span><span style="color:#dcdcdc;">load();
    </span><span style="color:#569cd6;">unsafe </span><span style="color:#dcdcdc;">{
        set_cs(</span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">.</span><span style="color:#b5cea8;">1.</span><span style="color:#dcdcdc;">code_selector);
        load_tss(</span><span style="color:#b4cea8;">GDT</span><span style="color:#dcdcdc;">.</span><span style="color:#b5cea8;">1.</span><span style="color:#dcdcdc;">tss_selector);
    }
}
</span></pre>
<p>We reload the code segment register using <a href="https://docs.rs/x86_64/0.7.5/x86_64/instructions/segmentation/fn.set_cs.html"><code>set_cs</code></a> and to load the TSS using <a href="https://docs.rs/x86_64/0.7.5/x86_64/instructions/tables/fn.load_tss.html"><code>load_tss</code></a>. The functions are marked as <code>unsafe</code>, so we need an <code>unsafe</code> block to invoke them. The reason is that it might be possible to break memory safety by loading invalid selectors.</p>
<p>Now that we loaded a valid TSS and interrupt stack table, we can set the stack index for our double fault handler in the IDT:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in src/interrupts.rs

</span><span style="color:#569cd6;">use crate</span><span style="color:#dcdcdc;">::gdt;

lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">IDT</span><span style="color:#dcdcdc;">: InterruptDescriptorTable </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> idt </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        </span><span style="color:#569cd6;">unsafe </span><span style="color:#dcdcdc;">{
            idt.double_fault.set_handler_fn(double_fault_handler)
                .set_stack_index(gdt::</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span style="color:#dcdcdc;">); </span><span style="color:#608b4e;">// new
        </span><span style="color:#dcdcdc;">}

        idt
    };
}
</span></pre>
<p>The <code>set_stack_index</code> method is unsafe because the the caller must ensure that the used index is valid and not already used for another exception.</p>
<p>That's it! Now the CPU should switch to the double fault stack whenever a double fault occurs. Thus, we are able to catch <em>all</em> double faults, including kernel stack overflows:</p>
<p><img src="https://os.phil-opp.com/double-fault-exceptions/qemu-double-fault-on-stack-overflow.png" alt="QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame" /></p>
<p>From now on we should never see a triple fault again! To ensure that we don't accidentally break the above, we should add a test for this.</p>
<h2 id="a-stack-overflow-test"><a class="zola-anchor" href="#a-stack-overflow-test" aria-label="Anchor link for: a-stack-overflow-test">üîó</a>A Stack Overflow Test</h2>
<p>To test our new <code>gdt</code> module and ensure that the double fault handler is correctly called on a stack overflow, we can add an integration test. The idea is to do provoke a double fault in the test function and verify that the double fault handler is called.</p>
<p>Let's start with a minimal skeleton:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in tests/stack_overflow.rs

</span><span style="color:#dcdcdc;">#![no_std]
#![no_main]

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">core::panic::PanicInfo;

#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">_start() -&gt; </span><span style="color:#569cd6;">! </span><span style="color:#dcdcdc;">{
    unimplemented!();
}

#[panic_handler]
</span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">panic(info: </span><span style="color:#569cd6;">&amp;</span><span style="color:#dcdcdc;">PanicInfo) -&gt; </span><span style="color:#569cd6;">! </span><span style="color:#dcdcdc;">{
    blog_os::test_panic_handler(info)
}
</span></pre>
<p>Like our <code>panic_handler</code> test, the test will run <a href="https://os.phil-opp.com/testing/#no-harness-tests">without a test harness</a>. The reason is that we can't continue execution after a double fault, so more than one test doesn't make sense. To disable, the test harness for the test, we add the following to our <code>Cargo.toml</code>:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;"># in Cargo.toml

</span><span style="color:#dcdcdc;">[[</span><span style="color:#808080;">test</span><span style="color:#dcdcdc;">]]
</span><span style="color:#569cd6;">name </span><span style="color:#dcdcdc;">= </span><span style="color:#d69d85;">&quot;stack_overflow&quot;
</span><span style="color:#569cd6;">harness </span><span style="color:#dcdcdc;">= </span><span style="color:#569cd6;">false
</span></pre>
<p>Now <code>cargo xtest --test stack_overflow</code> should compile successfully. The test fails of course, since the <code>unimplemented</code> macro panics.</p>
<h3 id="implementing-start"><a class="zola-anchor" href="#implementing-start" aria-label="Anchor link for: implementing-start">üîó</a>Implementing <code>_start</code></h3>
<p>The implementation of the <code>_start</code> function looks like this:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in tests/stack_overflow.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">blog_os::serial_print;

#[no_mangle]
</span><span style="color:#569cd6;">pub extern </span><span style="color:#d69d85;">&quot;C&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">_start() -&gt; </span><span style="color:#569cd6;">! </span><span style="color:#dcdcdc;">{
    serial_print!(</span><span style="color:#d69d85;">&quot;stack_overflow... &quot;</span><span style="color:#dcdcdc;">);

    blog_os::gdt::init();
    init_test_idt();

    </span><span style="color:#608b4e;">// trigger a stack overflow
    </span><span style="color:#dcdcdc;">stack_overflow();

    panic!(</span><span style="color:#d69d85;">&quot;Execution continued after stack overflow&quot;</span><span style="color:#dcdcdc;">);
}

#[allow(unconditional_recursion)]
</span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">stack_overflow() {
    stack_overflow(); </span><span style="color:#608b4e;">// for each recursion, the return address is pushed
</span><span style="color:#dcdcdc;">}
</span></pre>
<p>We call our <code>gdt::init</code> function to initialize a new GDT. Instead of calling our <code>interrupts::init_idt</code> function, we call a <code>init_test_idt</code> function that will be explained in a moment. The reason is that we want to register a custom double fault handler that does a <code>exit_qemu(QemuExitCode::Success)</code> instead of panicking.</p>
<p>The <code>stack_overflow</code> function is identical to the function in our <code>main.rs</code>. We additionally added the <code>allow(unconditional_recursion)</code> attribute to silence the warning that the function recurses endlessly.</p>
<h3 id="the-test-idt"><a class="zola-anchor" href="#the-test-idt" aria-label="Anchor link for: the-test-idt">üîó</a>The Test IDT</h3>
<p>As noted above, the test needs its own IDT with a custom double fault handler. The implementation looks like this:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in tests/stack_overflow.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">lazy_static::lazy_static;
</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::structures::idt::InterruptDescriptorTable;

lazy_static! {
    </span><span style="color:#569cd6;">static ref </span><span style="color:#b4cea8;">TEST_IDT</span><span style="color:#dcdcdc;">: InterruptDescriptorTable </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">{
        </span><span style="color:#569cd6;">let mut</span><span style="color:#dcdcdc;"> idt </span><span style="color:#569cd6;">= </span><span style="color:#dcdcdc;">InterruptDescriptorTable::new();
        </span><span style="color:#569cd6;">unsafe </span><span style="color:#dcdcdc;">{
            idt.double_fault
                .set_handler_fn(test_double_fault_handler)
                .set_stack_index(blog_os::gdt::</span><span style="color:#b4cea8;">DOUBLE_FAULT_IST_INDEX</span><span style="color:#dcdcdc;">);
        }

        idt
    };
}

</span><span style="color:#569cd6;">pub fn </span><span style="color:#dcdcdc;">init_test_idt() {
    </span><span style="color:#b4cea8;">TEST_IDT</span><span style="color:#dcdcdc;">.load();
}
</span></pre>
<p>The implementation is very similar to our normal IDT in <code>interrupts.rs</code>. Like in the normal IDT, we set a stack index into the IST for the double fault handler in order to switch to a separate stack. The <code>init_test_idt</code> function loads the IDT on the CPU through the <code>load</code> method.</p>
<h3 id="the-double-fault-handler"><a class="zola-anchor" href="#the-double-fault-handler" aria-label="Anchor link for: the-double-fault-handler">üîó</a>The Double Fault Handler</h3>
<p>The only missing piece is our double fault handler. It looks like this:</p>
<pre style="background-color:#1e1e1e;">
<span style="color:#608b4e;">// in tests/stack_overflow.rs

</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">blog_os::{exit_qemu, QemuExitCode, serial_println};
</span><span style="color:#569cd6;">use </span><span style="color:#dcdcdc;">x86_64::structures::idt::InterruptStackFrame;

</span><span style="color:#569cd6;">extern </span><span style="color:#d69d85;">&quot;x86-interrupt&quot; </span><span style="color:#569cd6;">fn </span><span style="color:#dcdcdc;">test_double_fault_handler(
    _stack_frame: </span><span style="color:#569cd6;">&amp;mut</span><span style="color:#dcdcdc;"> InterruptStackFrame,
    _error_code: </span><span style="color:#569cd6;">u64</span><span style="color:#dcdcdc;">,
) {
    serial_println!(</span><span style="color:#d69d85;">&quot;[ok]&quot;</span><span style="color:#dcdcdc;">);
    exit_qemu(QemuExitCode::Success);
    </span><span style="color:#569cd6;">loop </span><span style="color:#dcdcdc;">{}
}
</span></pre>
<p>When the double fault handler is called, we exit QEMU with a success exit code, which marks the test as passed. Since integration tests are completely separate executables, we need to set <code>#![feature(abi_x86_interrupt)]</code> attribute again at the top of our test file.</p>
<p>Now we can run our test through <code>cargo xtest --test stack_overflow</code> (or <code>cargo xtest</code> to run all tests). As expected, we see the <code>stack_overflow... [ok]</code> output in the console. Try to comment out the <code>set_stack_index</code> line: it should cause the test to fail.</p>
<h2 id="summary"><a class="zola-anchor" href="#summary" aria-label="Anchor link for: summary">üîó</a>Summary</h2>
<p>In this post we learned what a double fault is and under which conditions it occurs. We added a basic double fault handler that prints an error message and added an integration test for it.</p>
<p>We also enabled the hardware supported stack switching on double fault exceptions so that it also works on stack overflow. While implementing it, we learned about the task state segment (TSS), the contained interrupt stack table (IST), and the global descriptor table (GDT), which was used for segmentation on older architectures.</p>
<h2 id="what-s-next"><a class="zola-anchor" href="#what-s-next" aria-label="Anchor link for: what-s-next">üîó</a>What's next?</h2>
<p>The next post explains how to handle interrupts from external devices such as timers, keyboards, or network controllers. These hardware interrupts are very similar to exceptions, e.g. they are also dispatched through the IDT. However, unlike exceptions, they don't arise directly on the CPU. Instead, an <em>interrupt controller</em> aggregates these interrupts and forwards them to CPU depending on their priority. In the next we will explore the <a href="https://en.wikipedia.org/wiki/Intel_8259">Intel 8259</a> (‚ÄúPIC‚Äù) interrupt controller and learn how to implement keyboard support.</p>


    <div class="post-footer-support">
        <h2>Support Me</h2>
        <p>If you liked this post and would like to support me, you can do so on <a href="https://donorbox.org/phil-opp">Donorbox</a>, <a href="https://www.patreon.com/phil_opp">Patreon</a>, or <a href="https://liberapay.com/phil-opp/">Liberapay</a>. Thanks!</p>
    </div>
</main>

        <div>
    <hr>
    <div class="PageNavigation">
        
            <a class="prev" href="/cpu-exceptions/">&laquo; CPU Exceptions</a>
        
        
            <a class="next" href="/hardware-interrupts/">Hardware Interrupts &raquo;</a>
        
    </div>

    <hr>
    <section>
        <h2 id="comments">Comments</h2>
        
    <script src="https://utteranc.es/client.js"
        repo="phil-opp/blog_os"
        issue-term="url"
        label="comments"
        crossorigin="anonymous"
        async>
    </script>

    </section>

</div>

        <footer class="footer">
            <hr>
            <small>
                &copy; <time datetime="2019">2019</time>. All rights reserved.
                <a href="https:&#x2F;&#x2F;os.phil-opp.com&#x2F;.&#x2F;pages&#x2F;contact.md">Contact</a>
            </small>
        </footer>
    </div>

    <!-- Fathom - simple website analytics - https://github.com/usefathom/fathom -->
    <script>
        (function(f, a, t, h, o, m){
            a[h]=a[h]||function(){
                (a[h].q=a[h].q||[]).push(arguments)
            };
            o=f.createElement('script'),
            m=f.getElementsByTagName('script')[0];
            o.async=1; o.src=t; o.id='fathom-script';
            m.parentNode.insertBefore(o,m)
        })(document, window, '//fathom.phil-opp.com/tracker.js', 'fathom');
        fathom('set', 'siteId', 'MUXWM');
        fathom('trackPageview');
    </script>
    <!-- / Fathom -->
</body>

</html>
