<!doctype html><html lang=en><head><meta charset=UTF-8><meta content=yes name=apple-mobile-web-app-capable><meta content="width=device-width,initial-scale=1" name=viewport><meta content="light dark" name=color-scheme><meta content="The VGA text mode is a simple way to print text to the screen. In this post, we create an interface that makes its usage safe and simple, by encapsula‚Ä¶" name=description><meta content="Philipp Oppermann" name=author><link href=https://os.phil-opp.com/vga-text-mode/ rel=canonical><link href=/css/edition-2/main.css rel=stylesheet><link title="RSS feed for os.phil-opp.com" href=https://os.phil-opp.com/rss.xml rel=alternate type=application/rss+xml><script>let theme = localStorage.getItem("theme");
        if (theme != null) {
            document.documentElement.setAttribute("data-theme", theme);
        }</script><script async src=/js/edition-2/main.js></script><title>VGA Text Mode | Writing an OS in Rust</title><body><div class="container content"><header class=masthead><div style=position:relative><h2 class=masthead-title><a href=https://os.phil-opp.com title=Home>Writing an OS in Rust</a></h2><p><small>Philipp¬†Oppermann's¬†blog</small><aside id=all-posts-link><a title="All Posts" href=https://os.phil-opp.com>¬´ All Posts</a></aside></div></header><div class=theme-switch><div title="Switch between light and dark theme" class=light-switch onclick=toggle_lights()></div><div title="Clear the theme override and go back to the system theme" class=light-switch-reset onclick=clear_theme_override()></div></div><div><aside id=toc-aside><h2>Table of Contents</h2><ol><li><a href=#the-vga-text-buffer>The VGA Text Buffer</a><li><a href=#a-rust-module>A Rust Module</a> <ol><li><a href=#colors>Colors</a><li><a href=#text-buffer>Text Buffer</a><li><a href=#printing>Printing</a><li><a href=#volatile>Volatile</a><li><a href=#formatting-macros>Formatting Macros</a><li><a href=#newlines>Newlines</a></ol><li><a href=#a-global-interface>A Global Interface</a> <ol><li><a href=#lazy-statics>Lazy Statics</a><li><a href=#spinlocks>Spinlocks</a><li><a href=#safety>Safety</a><li><a href=#a-println-macro>A println Macro</a><li><a href=#hello-world-using-println>Hello World using println</a><li><a href=#printing-panic-messages>Printing Panic Messages</a></ol><li><a href=#summary>Summary</a><li><a href=#what-s-next>What‚Äôs next?</a><li class=toc-comments-link><a href=#comments>Comments</a></ol></aside><main><div><h1>VGA Text Mode</h1><time class=post-date datetime=2018-02-26> Feb 26, 2018 </time></div><div><p>The <a href=https://en.wikipedia.org/wiki/VGA-compatible_text_mode>VGA text mode</a> is a simple way to print text to the screen. In this post, we create an interface that makes its usage safe and simple, by encapsulating all unsafety in a separate module. We also implement support for Rust‚Äôs <a href=https://doc.rust-lang.org/std/fmt/#related-macros>formatting macros</a>.</p><span id=continue-reading></span><p>This blog is openly developed on <a href=https://github.com/phil-opp/blog_os>GitHub</a>. If you have any problems or questions, please open an issue there. You can also leave comments <a href=https://os.phil-opp.com/vga-text-mode/#comments>at the bottom</a>. The complete source code for this post can be found in the <a href=https://github.com/phil-opp/blog_os/tree/post-03><code>post-03</code></a> branch.<details id=toc-inline><summary><b>Table of Contents</b></summary> <ul><li><a href=#the-vga-text-buffer>The VGA Text Buffer</a><li><a href=#a-rust-module>A Rust Module</a> <ul><li><a href=#colors>Colors</a><li><a href=#text-buffer>Text Buffer</a><li><a href=#printing>Printing</a><li><a href=#volatile>Volatile</a><li><a href=#formatting-macros>Formatting Macros</a><li><a href=#newlines>Newlines</a></ul><li><a href=#a-global-interface>A Global Interface</a> <ul><li><a href=#lazy-statics>Lazy Statics</a><li><a href=#spinlocks>Spinlocks</a><li><a href=#safety>Safety</a><li><a href=#a-println-macro>A println Macro</a><li><a href=#hello-world-using-println>Hello World using println</a><li><a href=#printing-panic-messages>Printing Panic Messages</a></ul><li><a href=#summary>Summary</a><li><a href=#what-s-next>What‚Äôs next?</a><li class=toc-comments-link><a href=#comments>Comments</a></ul></details><h2 id=the-vga-text-buffer><a aria-label="Anchor link for: the-vga-text-buffer" class=zola-anchor href=#the-vga-text-buffer>üîó</a>The VGA Text Buffer</h2><p>To print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware. The VGA text buffer is a two-dimensional array with typically 25 rows and 80 columns, which is directly rendered to the screen. Each array entry describes a single screen character through the following format:<table><thead><tr><th>Bit(s)<th>Value<tbody><tr><td>0-7<td>ASCII code point<tr><td>8-11<td>Foreground color<tr><td>12-14<td>Background color<tr><td>15<td>Blink</table><p>The first byte represents the character that should be printed in the <a href=https://en.wikipedia.org/wiki/ASCII>ASCII encoding</a>. To be exact, it isn‚Äôt exactly ASCII, but a character set named <a href=https://en.wikipedia.org/wiki/Code_page_437><em>code page 437</em></a> with some additional characters and slight modifications. For simplicity, we proceed to call it an ASCII character in this post.<p>The second byte defines how the character is displayed. The first four bits define the foreground color, the next three bits the background color, and the last bit whether the character should blink. The following colors are available:<table><thead><tr><th>Number<th>Color<th>Number + Bright Bit<th>Bright Color<tbody><tr><td>0x0<td>Black<td>0x8<td>Dark Gray<tr><td>0x1<td>Blue<td>0x9<td>Light Blue<tr><td>0x2<td>Green<td>0xa<td>Light Green<tr><td>0x3<td>Cyan<td>0xb<td>Light Cyan<tr><td>0x4<td>Red<td>0xc<td>Light Red<tr><td>0x5<td>Magenta<td>0xd<td>Pink<tr><td>0x6<td>Brown<td>0xe<td>Yellow<tr><td>0x7<td>Light Gray<td>0xf<td>White</table><p>Bit 4 is the <em>bright bit</em>, which turns for example blue into light blue. For the background color, this bit is repurposed as the blink bit.<p>The VGA text buffer is accessible via <a href=https://en.wikipedia.org/wiki/Memory-mapped_I/O>memory-mapped I/O</a> to the address <code>0xb8000</code>. This means that reads and writes to that address don‚Äôt access the RAM, but directly the text buffer on the VGA hardware. This means that we can read and write it through normal memory operations to that address.<p>Note that memory-mapped hardware might not support all normal RAM operations. For example, a device could only support byte-wise reads and return junk when an <code>u64</code> is read. Fortunately, the text buffer <a href=https://web.stanford.edu/class/cs140/projects/pintos/specs/freevga/vga/vgamem.htm#manip>supports normal reads and writes</a>, so that we don‚Äôt have to treat it in special way.<h2 id=a-rust-module><a aria-label="Anchor link for: a-rust-module" class=zola-anchor href=#a-rust-module>üîó</a>A Rust Module</h2><p>Now that we know how the VGA buffer works, we can create a Rust module to handle printing:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>//‚ÄØin src/main.rs
</span><span style=color:#569cd6;>mod </span><span>vga_buffer;
</span></code></pre><p>For the content of this module we create a new <code>src/vga_buffer.rs</code> file. All of the code below goes into our new module (unless specified otherwise).<h3 id=colors><a aria-label="Anchor link for: colors" class=zola-anchor href=#colors>üîó</a>Colors</h3><p>First, we represent the different colors using an enum:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[allow(dead_code)]
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(u8)]
</span><span style=color:#569cd6;>pub enum </span><span>Color {
</span><span>    Black = </span><span style=color:#b5cea8;>0</span><span>,
</span><span>    Blue = </span><span style=color:#b5cea8;>1</span><span>,
</span><span>    Green = </span><span style=color:#b5cea8;>2</span><span>,
</span><span>    Cyan = </span><span style=color:#b5cea8;>3</span><span>,
</span><span>    Red = </span><span style=color:#b5cea8;>4</span><span>,
</span><span>    Magenta = </span><span style=color:#b5cea8;>5</span><span>,
</span><span>    Brown = </span><span style=color:#b5cea8;>6</span><span>,
</span><span>    LightGray = </span><span style=color:#b5cea8;>7</span><span>,
</span><span>    DarkGray = </span><span style=color:#b5cea8;>8</span><span>,
</span><span>    LightBlue = </span><span style=color:#b5cea8;>9</span><span>,
</span><span>    LightGreen = </span><span style=color:#b5cea8;>10</span><span>,
</span><span>    LightCyan = </span><span style=color:#b5cea8;>11</span><span>,
</span><span>    LightRed = </span><span style=color:#b5cea8;>12</span><span>,
</span><span>    Pink = </span><span style=color:#b5cea8;>13</span><span>,
</span><span>    Yellow = </span><span style=color:#b5cea8;>14</span><span>,
</span><span>    White = </span><span style=color:#b5cea8;>15</span><span>,
</span><span>}
</span></code></pre><p>We use a <a href=https://doc.rust-lang.org/rust-by-example/custom_types/enum/c_like.html>C-like enum</a> here to explicitly specify the number for each color. Because of the <code>repr(u8)</code> attribute each enum variant is stored as an <code>u8</code>. Actually 4 bits would be sufficient, but Rust doesn‚Äôt have an <code>u4</code> type.<p>Normally the compiler would issue a warning for each unused variant. By using the <code>#[allow(dead_code)]</code> attribute we disable these warnings for the <code>Color</code> enum.<p>By <a href=https://doc.rust-lang.org/rust-by-example/trait/derive.html>deriving</a> the <a href=https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html><code>Copy</code></a>, <a href=https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html><code>Clone</code></a>, <a href=https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html><code>Debug</code></a>, <a href=https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html><code>PartialEq</code></a>, and <a href=https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html><code>Eq</code></a> traits, we enable <a href=https://doc.rust-lang.org/1.30.0/book/first-edition/ownership.html#copy-types>copy semantics</a> for the type and make it printable and comparable.<p>To represent a full color code that specifies foreground and background color, we create a <a href=https://doc.rust-lang.org/rust-by-example/generics/new_types.html>newtype</a> on top of <code>u8</code>:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(transparent)]
</span><span style=color:#569cd6;>struct </span><span>ColorCode(</span><span style=color:#569cd6;>u8</span><span>);
</span><span>
</span><span style=color:#569cd6;>impl </span><span>ColorCode {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new(foreground: Color, background: Color) -> ColorCode {
</span><span>        ColorCode((background </span><span style=color:#569cd6;>as u8</span><span>) << </span><span style=color:#b5cea8;>4 </span><span style=color:#569cd6;>| </span><span>(foreground </span><span style=color:#569cd6;>as u8</span><span>))
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>ColorCode</code> struct contains the full color byte, containing foreground and background color. Like before, we derive the <code>Copy</code> and <code>Debug</code> traits for it. To ensure that the <code>ColorCode</code> has the exact same data layout as an <code>u8</code>, we use the <a href=https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent><code>repr(transparent)</code></a> attribute.<h3 id=text-buffer><a aria-label="Anchor link for: text-buffer" class=zola-anchor href=#text-buffer>üîó</a>Text Buffer</h3><p>Now we can add structures to represent a screen character and the text buffer:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
</span><span>#[repr(C)]
</span><span style=color:#569cd6;>struct </span><span>ScreenChar {
</span><span>    ascii_character: </span><span style=color:#569cd6;>u8</span><span>,
</span><span>    color_code: ColorCode,
</span><span>}
</span><span>
</span><span style=color:#569cd6;>const </span><span style=color:#b4cea8;>BUFFER_HEIGHT</span><span>: </span><span style=color:#569cd6;>usize </span><span>= </span><span style=color:#b5cea8;>25</span><span>;
</span><span style=color:#569cd6;>const </span><span style=color:#b4cea8;>BUFFER_WIDTH</span><span>: </span><span style=color:#569cd6;>usize </span><span>= </span><span style=color:#b5cea8;>80</span><span>;
</span><span>
</span><span>#[repr(transparent)]
</span><span style=color:#569cd6;>struct </span><span>Buffer {
</span><span>    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
</span><span>}
</span></code></pre><p>Since the field ordering in default structs is undefined in Rust, we need the <a href=https://doc.rust-lang.org/nightly/nomicon/other-reprs.html#reprc><code>repr(C)</code></a> attribute. It guarantees that the struct‚Äôs fields are laid out exactly like in a C struct and thus guarantees the correct field ordering. For the <code>Buffer</code> struct, we use <a href=https://doc.rust-lang.org/nomicon/other-reprs.html#reprtransparent><code>repr(transparent)</code></a> again to ensure that it has the same memory layout as its single field.<p>To actually write to screen, we now create a writer type:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub struct </span><span>Writer {
</span><span>    column_position: </span><span style=color:#569cd6;>usize</span><span>,
</span><span>    color_code: ColorCode,
</span><span>    buffer: </span><span style=color:#569cd6;>&'static mut</span><span> Buffer,
</span><span>}
</span></code></pre><p>The writer will always write to the last line and shift lines up when a line is full (or on <code>\n</code>). The <code>column_position</code> field keeps track of the current position in the last row. The current foreground and background colors are specified by <code>color_code</code> and a reference to the VGA buffer is stored in <code>buffer</code>. Note that we need an <a href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotation-syntax>explicit lifetime</a> here to tell the compiler how long the reference is valid. The <a href=https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#the-static-lifetime><code>'static</code></a> lifetime specifies that the reference is valid for the whole program run time (which is true for the VGA text buffer).<h3 id=printing><a aria-label="Anchor link for: printing" class=zola-anchor href=#printing>üîó</a>Printing</h3><p>Now we can use the <code>Writer</code> to modify the buffer‚Äôs characters. First we create a method to write a single ASCII byte:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_byte(</span><span style=color:#569cd6;>&mut </span><span>self, byte: </span><span style=color:#569cd6;>u8</span><span>) {
</span><span>        </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>            </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.new_line(),
</span><span>            byte </span><span style=color:#569cd6;>=> </span><span>{
</span><span>                </span><span style=color:#569cd6;>if </span><span>self.column_position >= </span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>                    self.new_line();
</span><span>                }
</span><span>
</span><span>                </span><span style=color:#569cd6;>let</span><span> row = </span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>- </span><span style=color:#b5cea8;>1</span><span>;
</span><span>                </span><span style=color:#569cd6;>let</span><span> col = self.column_position;
</span><span>
</span><span>                </span><span style=color:#569cd6;>let</span><span> color_code = self.color_code;
</span><span>                self.buffer.chars[row][col] = ScreenChar {
</span><span>                    ascii_character: byte,
</span><span>                    color_code,
</span><span>                };
</span><span>                self.column_position += </span><span style=color:#b5cea8;>1</span><span>;
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new_line(</span><span style=color:#569cd6;>&mut </span><span>self) {</span><span style=color:#608b4e;>/* TODO */</span><span>}
</span><span>}
</span></code></pre><p>If the byte is the <a href=https://en.wikipedia.org/wiki/Newline>newline</a> byte <code>\n</code>, the writer does not print anything. Instead it calls a <code>new_line</code> method, which we‚Äôll implement later. Other bytes get printed to the screen in the second match case.<p>When printing a byte, the writer checks if the current line is full. In that case, a <code>new_line</code> call is required before to wrap the line. Then it writes a new <code>ScreenChar</code> to the buffer at the current position. Finally, the current column position is advanced.<p>To print whole strings, we can convert them to bytes and print them one-by-one:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_string(</span><span style=color:#569cd6;>&mut </span><span>self, s: </span><span style=color:#569cd6;>&str</span><span>) {
</span><span>        </span><span style=color:#569cd6;>for</span><span> byte </span><span style=color:#569cd6;>in</span><span> s.bytes() {
</span><span>            </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>                </span><span style=color:#608b4e;>// printable ASCII byte or newline
</span><span>                </span><span style=color:#b5cea8;>0x20</span><span style=color:#569cd6;>..</span><span>=</span><span style=color:#b5cea8;>0x7e </span><span style=color:#569cd6;>| b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.write_byte(byte),
</span><span>                </span><span style=color:#608b4e;>// not part of printable ASCII range
</span><span>                </span><span style=color:#569cd6;>_ => </span><span>self.write_byte(</span><span style=color:#b5cea8;>0xfe</span><span>),
</span><span>            }
</span><span>
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>The VGA text buffer only supports ASCII and the additional bytes of <a href=https://en.wikipedia.org/wiki/Code_page_437>code page 437</a>. Rust strings are <a href=https://www.fileformat.info/info/unicode/utf8.htm>UTF-8</a> by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a <code>~</code> character) and unprintable bytes. For unprintable bytes, we print a <code>‚ñ†</code> character, which has the hex code <code>0xfe</code> on the VGA hardware.<h4 id=try-it-out><a aria-label="Anchor link for: try-it-out" class=zola-anchor href=#try-it-out>üîó</a>Try it out!</h4><p>To write some characters to the screen, you can create a temporary function:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>print_something() {
</span><span>    </span><span style=color:#569cd6;>let mut</span><span> writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>
</span><span>    writer.write_byte(</span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'H'</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"ello "</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"W√∂rld!"</span><span>);
</span><span>}
</span></code></pre><p>It first creates a new Writer that points to the VGA buffer at <code>0xb8000</code>. The syntax for this might seem a bit strange: First, we cast the integer <code>0xb8000</code> as an mutable <a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer>raw pointer</a>. Then we convert it to a mutable reference by dereferencing it (through <code>*</code>) and immediately borrowing it again (through <code>&mut</code>). This conversion requires an <a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html><code>unsafe</code> block</a>, since the compiler can‚Äôt guarantee that the raw pointer is valid.<p>Then it writes the byte <code>b'H'</code> to it. The <code>b</code> prefix creates a <a href=https://doc.rust-lang.org/reference/tokens.html#byte-literals>byte literal</a>, which represents an ASCII character. By writing the strings <code>"ello "</code> and <code>"W√∂rld!"</code>, we test our <code>write_string</code> method and the handling of unprintable characters. To see the output, we need to call the <code>print_something</code> function from our <code>_start</code> function:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    vga_buffer::print_something();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>When we run our project now, a <code>Hello W‚ñ†‚ñ†rld!</code> should be printed in the <em>lower</em> left corner of the screen in yellow:<p><img alt="QEMU output with a yellow Hello W‚ñ†‚ñ†rld! in the lower left corner" src=vga-hello.png><p>Notice that the <code>√∂</code> is printed as two <code>‚ñ†</code> characters. That‚Äôs because <code>√∂</code> is represented by two bytes in <a href=https://www.fileformat.info/info/unicode/utf8.htm>UTF-8</a>, which both don‚Äôt fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.<h3 id=volatile><a aria-label="Anchor link for: volatile" class=zola-anchor href=#volatile>üîó</a>Volatile</h3><p>We just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.<p>The problem is that we only write to the <code>Buffer</code> and never read from it again. The compiler doesn‚Äôt know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as <em><a href=https://en.wikipedia.org/wiki/Volatile_(computer_programming)>volatile</a></em>. This tells the compiler that the write has side effects and should not be optimized away.<p>In order to use volatile writes for the VGA buffer, we use the <a href=https://docs.rs/volatile>volatile</a> library. This <em>crate</em> (this is how packages are called in the Rust world) provides a <code>Volatile</code> wrapper type with <code>read</code> and <code>write</code> methods. These methods internally use the <a href=https://doc.rust-lang.org/nightly/core/ptr/fn.read_volatile.html>read_volatile</a> and <a href=https://doc.rust-lang.org/nightly/core/ptr/fn.write_volatile.html>write_volatile</a> functions of the core library and thus guarantee that the reads/writes are not optimized away.<p>We can add a dependency on the <code>volatile</code> crate by adding it to the <code>dependencies</code> section of our <code>Cargo.toml</code>:<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>volatile </span><span>= </span><span style=color:#d69d85;>"0.2.6"
</span></code></pre><p>Make sure to specify <code>volatile</code> version <code>0.2.6</code>. Newer versions of the crate are not compatible with this post. The <code>0.2.6</code> is the <a href=https://semver.org/>semantic</a> version number. For more information, see the <a href=https://doc.crates.io/specifying-dependencies.html>Specifying Dependencies</a> guide of the cargo documentation.<p>Let‚Äôs use it to make writes to the VGA buffer volatile. We update our <code>Buffer</code> type as follows:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>volatile::Volatile;
</span><span>
</span><span style=color:#569cd6;>struct </span><span>Buffer {
</span><span>    chars: [[Volatile&LTScreenChar>; BUFFER_WIDTH]; BUFFER_HEIGHT],
</span><span>}
</span></code></pre><p>Instead of a <code>ScreenChar</code>, we‚Äôre now using a <code>Volatile&LTScreenChar></code>. (The <code>Volatile</code> type is <a href=https://doc.rust-lang.org/book/ch10-01-syntax.html>generic</a> and can wrap (almost) any type). This ensures that we can‚Äôt accidentally write to it through a ‚Äúnormal‚Äù write. Instead, we have to use the <code>write</code> method now.<p>This means that we have to update our <code>Writer::write_byte</code> method:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>pub fn </span><span>write_byte(</span><span style=color:#569cd6;>&mut </span><span>self, byte: </span><span style=color:#569cd6;>u8</span><span>) {
</span><span>        </span><span style=color:#569cd6;>match</span><span> byte {
</span><span>            </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>' </span><span style=color:#569cd6;>=> </span><span>self.new_line(),
</span><span>            byte </span><span style=color:#569cd6;>=> </span><span>{
</span><span>                </span><span style=color:#569cd6;>...
</span><span>
</span><span>                self.buffer.chars[row][col].write(ScreenChar {
</span><span>                    ascii_character: byte,
</span><span>                    color_code,
</span><span>                });
</span><span>                </span><span style=color:#569cd6;>...
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>    </span><span style=color:#569cd6;>...
</span><span>}
</span></code></pre><p>Instead of a normal assignment using <code>=</code>, we‚Äôre now using the <code>write</code> method. This guarantees that the compiler will never optimize away this write.<h3 id=formatting-macros><a aria-label="Anchor link for: formatting-macros" class=zola-anchor href=#formatting-macros>üîó</a>Formatting Macros</h3><p>It would be nice to support Rust‚Äôs formatting macros, too. That way, we can easily print different types like integers or floats. To support them, we need to implement the <a href=https://doc.rust-lang.org/nightly/core/fmt/trait.Write.html><code>core::fmt::Write</code></a> trait. The only required method of this trait is <code>write_str</code> that looks quite similar to our <code>write_string</code> method, just with a <code>fmt::Result</code> return type:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>core::fmt;
</span><span>
</span><span style=color:#569cd6;>impl </span><span>fmt::Write </span><span style=color:#569cd6;>for </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>write_str(</span><span style=color:#569cd6;>&mut </span><span>self, s: </span><span style=color:#569cd6;>&str</span><span>) -> fmt::Result {
</span><span>        self.write_string(s);
</span><span>        Ok(())
</span><span>    }
</span><span>}
</span></code></pre><p>The <code>Ok(())</code> is just a <code>Ok</code> Result containing the <code>()</code> type.<p>Now we can use Rust‚Äôs built-in <code>write!</code>/<code>writeln!</code> formatting macros:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub fn </span><span>print_something() {
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    </span><span style=color:#569cd6;>let mut</span><span> writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>
</span><span>    writer.write_byte(</span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>'H'</span><span>);
</span><span>    writer.write_string(</span><span style=color:#d69d85;>"ello! "</span><span>);
</span><span>    write!(writer, </span><span style=color:#d69d85;>"The numbers are </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;> and </span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#b5cea8;>42</span><span>, </span><span style=color:#b5cea8;>1.0</span><span>/</span><span style=color:#b5cea8;>3.0</span><span>).unwrap();
</span><span>}
</span></code></pre><p>Now you should see a <code>Hello! The numbers are 42 and 0.3333333333333333</code> at the bottom of the screen. The <code>write!</code> call returns a <code>Result</code> which causes a warning if not used, so we call the <a href=https://doc.rust-lang.org/core/result/enum.Result.html#method.unwrap><code>unwrap</code></a> function on it, which panics if an error occurs. This isn‚Äôt a problem in our case, since writes to the VGA buffer never fail.<h3 id=newlines><a aria-label="Anchor link for: newlines" class=zola-anchor href=#newlines>üîó</a>Newlines</h3><p>Right now, we just ignore newlines and characters that don‚Äôt fit into the line anymore. Instead we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the <code>new_line</code> method of <code>Writer</code>:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>new_line(</span><span style=color:#569cd6;>&mut </span><span>self) {
</span><span>        </span><span style=color:#569cd6;>for</span><span> row </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>1</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>{
</span><span>            </span><span style=color:#569cd6;>for</span><span> col </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>0</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>                </span><span style=color:#569cd6;>let</span><span> character = self.buffer.chars[row][col].read();
</span><span>                self.buffer.chars[row - </span><span style=color:#b5cea8;>1</span><span>][col].write(character);
</span><span>            }
</span><span>        }
</span><span>        self.clear_row(</span><span style=color:#b4cea8;>BUFFER_HEIGHT </span><span>- </span><span style=color:#b5cea8;>1</span><span>);
</span><span>        self.column_position = </span><span style=color:#b5cea8;>0</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#569cd6;>fn </span><span>clear_row(</span><span style=color:#569cd6;>&mut </span><span>self, row: </span><span style=color:#569cd6;>usize</span><span>) {</span><span style=color:#608b4e;>/* TODO */</span><span>}
</span><span>}
</span></code></pre><p>We iterate over all screen characters and move each character one row up. Note that the range notation (<code>..</code>) is exclusive the upper bound. We also omit the 0th row (the first range starts at <code>1</code>) because it‚Äôs the row that is shifted off screen.<p>To finish the newline code, we add the <code>clear_row</code> method:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>impl </span><span>Writer {
</span><span>    </span><span style=color:#569cd6;>fn </span><span>clear_row(</span><span style=color:#569cd6;>&mut </span><span>self, row: </span><span style=color:#569cd6;>usize</span><span>) {
</span><span>        </span><span style=color:#569cd6;>let</span><span> blank = ScreenChar {
</span><span>            ascii_character: </span><span style=color:#569cd6;>b</span><span style=color:#d69d85;>' '</span><span>,
</span><span>            color_code: self.color_code,
</span><span>        };
</span><span>        </span><span style=color:#569cd6;>for</span><span> col </span><span style=color:#569cd6;>in </span><span style=color:#b5cea8;>0</span><span style=color:#569cd6;>..</span><span style=color:#b4cea8;>BUFFER_WIDTH </span><span>{
</span><span>            self.buffer.chars[row][col].write(blank);
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre><p>This method clears a row by overwriting all of its characters with a space character.<h2 id=a-global-interface><a aria-label="Anchor link for: a-global-interface" class=zola-anchor href=#a-global-interface>üîó</a>A Global Interface</h2><p>To provide a global writer that can be used as an interface from other modules without carrying a <code>Writer</code> instance around, we try to create a static <code>WRITER</code>:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>pub static </span><span style=color:#b4cea8;>WRITER</span><span>: Writer = Writer {
</span><span>    column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>    color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>    buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>};
</span></code></pre><p>However, if we try to compile it now, the following errors occur:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
</span><span> --> src/vga_buffer.rs:7:17
</span><span>  |
</span><span>7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span>
</span><span>error[E0396]: raw pointers cannot be dereferenced in statics
</span><span> --> src/vga_buffer.rs:8:22
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant
</span><span>
</span><span>error[E0017]: references in statics may only refer to immutable values
</span><span> --> src/vga_buffer.rs:8:22
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
</span><span>
</span><span>error[E0017]: references in statics may only refer to immutable values
</span><span> --> src/vga_buffer.rs:8:13
</span><span>  |
</span><span>8 |     buffer: unsafe { &mut *(0xb8000 as *mut Buffer) },
</span><span>  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
</span></code></pre><p>To understand what‚Äôs happening here, we need to know that statics are initialized at compile time, in contrast to normal variables that are initialized at run time. The component of the Rust compiler that evaluates such initialization expressions is called the ‚Äú<a href=https://rustc-dev-guide.rust-lang.org/const-eval.html>const evaluator</a>‚Äù. Its functionality is still limited, but there is ongoing work to expand it, for example in the ‚Äú<a href=https://github.com/rust-lang/rfcs/pull/2345>Allow panicking in constants</a>‚Äù RFC.<p>The issue about <code>ColorCode::new</code> would be solvable by using <a href=https://doc.rust-lang.org/reference/const_eval.html#const-functions><code>const</code> functions</a>, but the fundamental problem here is that Rust‚Äôs const evaluator is not able to convert raw pointers to references at compile time. Maybe it will work someday, but until then, we have to find another solution.<h3 id=lazy-statics><a aria-label="Anchor link for: lazy-statics" class=zola-anchor href=#lazy-statics>üîó</a>Lazy Statics</h3><p>The one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named <a href=https://docs.rs/lazy_static/1.0.1/lazy_static/>lazy_static</a>. This crate provides a <code>lazy_static!</code> macro that defines a lazily initialized <code>static</code>. Instead of computing its value at compile time, the <code>static</code> laziliy initializes itself when it‚Äôs accessed the first time. Thus, the initialization happens at runtime so that arbitrarily complex initialization code is possible.<p>Let‚Äôs add the <code>lazy_static</code> crate to our project:<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>dependencies.lazy_static</span><span>]
</span><span style=color:#569cd6;>version </span><span>= </span><span style=color:#d69d85;>"1.0"
</span><span style=color:#569cd6;>features </span><span>= [</span><span style=color:#d69d85;>"spin_no_std"</span><span>]
</span></code></pre><p>We need the <code>spin_no_std</code> feature, since we don‚Äôt link the standard library.<p>With <code>lazy_static</code>, we can define our static <code>WRITER</code> without problems:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>lazy_static::lazy_static;
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>pub static ref </span><span style=color:#b4cea8;>WRITER</span><span>: Writer = Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    };
</span><span>}
</span></code></pre><p>However, this <code>WRITER</code> is pretty useless since it is immutable. This means that we can‚Äôt write anything to it (since all the write methods take <code>&mut self</code>). One possible solution would be to use a <a href=https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable>mutable static</a>. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using <code>static mut</code> is highly discouraged, there were even proposals to <a href=https://internals.rust-lang.org/t/pre-rfc-remove-static-mut/1437>remove it</a>. But what are the alternatives? We could try to use a immutable static with a cell type like <a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#keeping-track-of-borrows-at-runtime-with-refcellt>RefCell</a> or even <a href=https://doc.rust-lang.org/nightly/core/cell/struct.UnsafeCell.html>UnsafeCell</a> that provides <a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html>interior mutability</a>. But these types aren‚Äôt <a href=https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html>Sync</a> (with good reason), so we can‚Äôt use them in statics.<h3 id=spinlocks><a aria-label="Anchor link for: spinlocks" class=zola-anchor href=#spinlocks>üîó</a>Spinlocks</h3><p>To get synchronized interior mutability, users of the standard library can use <a href=https://doc.rust-lang.org/nightly/std/sync/struct.Mutex.html>Mutex</a>. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can‚Äôt use it either. However there is a really basic kind of mutex in computer science that requires no operating system features: the <a href=https://en.wikipedia.org/wiki/Spinlock>spinlock</a>. Instead of blocking, the threads simply try to lock it again and again in a tight loop and thus burn CPU time until the mutex is free again.<p>To use a spinning mutex, we can add the <a href=https://crates.io/crates/spin>spin crate</a> as a dependency:<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># in Cargo.toml
</span><span>[</span><span style=color:#808080;>dependencies</span><span>]
</span><span style=color:#569cd6;>spin </span><span>= </span><span style=color:#d69d85;>"0.5.2"
</span></code></pre><p>Then we can use the spinning Mutex to add safe <a href=https://doc.rust-lang.org/book/ch15-05-interior-mutability.html>interior mutability</a> to our static <code>WRITER</code>:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span style=color:#569cd6;>use </span><span>spin::Mutex;
</span><span style=color:#569cd6;>...
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>pub static ref </span><span style=color:#b4cea8;>WRITER</span><span>: Mutex&LTWriter> = Mutex::new(Writer {
</span><span>        column_position: </span><span style=color:#b5cea8;>0</span><span>,
</span><span>        color_code: ColorCode::new(Color::Yellow, Color::Black),
</span><span>        buffer: </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&mut </span><span>*(</span><span style=color:#b5cea8;>0xb8000 </span><span style=color:#569cd6;>as *mut</span><span> Buffer) },
</span><span>    });
</span><span>}
</span></code></pre><p>Now we can delete the <code>print_something</code> function and print directly from our <code>_start</code> function:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    vga_buffer::</span><span style=color:#b4cea8;>WRITER</span><span>.lock().write_str(</span><span style=color:#d69d85;>"Hello again"</span><span>).unwrap();
</span><span>    write!(vga_buffer::WRITER.lock(), </span><span style=color:#d69d85;>", some numbers: </span><span style=color:#b4cea8;>{} {}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#b5cea8;>42</span><span>, </span><span style=color:#b5cea8;>1.337</span><span>).unwrap();
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>We need to import the <code>fmt::Write</code> trait in order to be able to use its functions.<h3 id=safety><a aria-label="Anchor link for: safety" class=zola-anchor href=#safety>üîó</a>Safety</h3><p>Note that we only have a single unsafe block in our code, which is needed to create a <code>Buffer</code> reference pointing to <code>0xb8000</code>. Afterwards, all operations are safe. Rust uses bounds checking for array accesses by default, so we can‚Äôt accidentally write outside the buffer. Thus, we encoded the required conditions in the type system and are able to provide a safe interface to the outside.<h3 id=a-println-macro><a aria-label="Anchor link for: a-println-macro" class=zola-anchor href=#a-println-macro>üîó</a>A println Macro</h3><p>Now that we have a global writer, we can add a <code>println</code> macro that can be used from anywhere in the codebase. Rust‚Äôs <a href=https://doc.rust-lang.org/nightly/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming>macro syntax</a> is a bit strange, so we won‚Äôt try to write a macro from scratch. Instead we look at the source of the <a href=https://doc.rust-lang.org/nightly/std/macro.println!.html><code>println!</code> macro</a> in the standard library:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[macro_export]
</span><span>macro_rules! println {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>(print!(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>));
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>(print!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span></code></pre><p>Macros are defined through one or more rules, which are similar to <code>match</code> arms. The <code>println</code> macro has two rules: The first rule for is invocations without arguments (e.g <code>println!()</code>), which is expanded to <code>print!("\n")</code> and thus just prints a newline. the second rule is for invocations with parameters such as <code>println!("Hello")</code> or <code>println!("Number: {}", 4)</code>. It is also expanded to an invocation of the <code>print!</code> macro, passing all arguments and an additional newline <code>\n</code> at the end.<p>The <code>#[macro_export]</code> attribute makes the macro available to the whole crate (not just the module it is defined) and external crates. It also places the macro at the crate root, which means that we have to import the macro through <code>use std::println</code> instead of <code>std::macros::println</code>.<p>The <a href=https://doc.rust-lang.org/nightly/std/macro.print!.html><code>print!</code> macro</a> is defined as:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[macro_export]
</span><span>macro_rules! print {
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::io::_print(format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span></code></pre><p>The macro expands to a call of the <a href=https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698><code>_print</code> function</a> in the <code>io</code> module. The <a href=https://doc.rust-lang.org/1.30.0/book/first-edition/macros.html#the-variable-crate><code>$crate</code> variable</a> ensures that the macro also works from outside the <code>std</code> crate by expanding to <code>std</code> when it‚Äôs used in other crates.<p>The <a href=https://doc.rust-lang.org/nightly/std/macro.format_args.html><code>format_args</code> macro</a> builds a <a href=https://doc.rust-lang.org/nightly/core/fmt/struct.Arguments.html>fmt::Arguments</a> type from the passed arguments, which is passed to <code>_print</code>. The <a href=https://github.com/rust-lang/rust/blob/29f5c699b11a6a148f097f82eaa05202f8799bbc/src/libstd/io/stdio.rs#L698><code>_print</code> function</a> of libstd calls <code>print_to</code>, which is rather complicated because it supports different <code>Stdout</code> devices. We don‚Äôt need that complexity since we just want to print to the VGA buffer.<p>To print to the VGA buffer, we just copy the <code>println!</code> and <code>print!</code> macros, but modify them to use our own <code>_print</code> function:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/vga_buffer.rs
</span><span>
</span><span>#[macro_export]
</span><span>macro_rules! print {
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::vga_buffer::_print(format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span><span>
</span><span>#[macro_export]
</span><span>macro_rules! println {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>($crate::print</span><span style=color:#569cd6;>!</span><span>(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>));
</span><span>    (</span><span style=color:#569cd6;>$</span><span>($arg:</span><span style=color:#569cd6;>tt</span><span>)</span><span style=color:#569cd6;>*</span><span>) </span><span style=color:#569cd6;>=> </span><span>($crate::print</span><span style=color:#569cd6;>!</span><span>(</span><span style=color:#d69d85;>"{}</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>"</span><span>, format_args!(</span><span style=color:#569cd6;>$</span><span>($arg)*)));
</span><span>}
</span><span>
</span><span>#[doc(hidden)]
</span><span style=color:#569cd6;>pub fn </span><span>_print(args: fmt::Arguments) {
</span><span>    </span><span style=color:#569cd6;>use </span><span>core::fmt::Write;
</span><span>    </span><span style=color:#b4cea8;>WRITER</span><span>.lock().write_fmt(args).unwrap();
</span><span>}
</span></code></pre><p>One thing that we changed from the original <code>println</code> definition is that we prefixed the invocations of the <code>print!</code> macro with <code>$crate</code> too. This ensures that we don‚Äôt need to have to import the <code>print!</code> macro too if we only want to use <code>println</code>.<p>Like in the standard library, we add the <code>#[macro_export]</code> attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via <code>use crate::vga_buffer::println</code> does not work. Instead, we have to do <code>use crate::println</code>.<p>The <code>_print</code> function locks our static <code>WRITER</code> and calls the <code>write_fmt</code> method on it. This method is from the <code>Write</code> trait, we need to import that trait. The additional <code>unwrap()</code> at the end panics if printing isn‚Äôt successful. But since we always return <code>Ok</code> in <code>write_str</code>, that should not happen.<p>Since the macros need to be able to call <code>_print</code> from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the <a href=https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#dochidden><code>doc(hidden)</code> attribute</a> to hide it from the generated documentation.<h3 id=hello-world-using-println><a aria-label="Anchor link for: hello-world-using-println" class=zola-anchor href=#hello-world-using-println>üîó</a>Hello World using <code>println</code></h3><p>Now we can use <code>println</code> in our <code>_start</code> function:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/main.rs
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>_start() {
</span><span>    println!(</span><span style=color:#d69d85;>"Hello World</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, </span><span style=color:#d69d85;>"!"</span><span>);
</span><span>
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>Note that we don‚Äôt have to import the macro in the main function, because it already lives in the root namespace.<p>As expected, we now see a <em>‚ÄúHello World!‚Äù</em> on the screen:<p><img alt="QEMU printing ‚ÄúHello World!‚Äù" src=vga-hello-world.png><h3 id=printing-panic-messages><a aria-label="Anchor link for: printing-panic-messages" class=zola-anchor href=#printing-panic-messages>üîó</a>Printing Panic Messages</h3><p>Now that we have a <code>println</code> macro, we can use it in our panic function to print the panic message and the location of the panic:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in main.rs
</span><span>
</span><span style=color:#608b4e;>/// This function is called on panic.
</span><span>#[panic_handler]
</span><span style=color:#569cd6;>fn </span><span>panic(info: </span><span style=color:#569cd6;>&</span><span>PanicInfo) -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#b4cea8;>{}</span><span style=color:#d69d85;>"</span><span>, info);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>When we now insert <code>panic!("Some panic message");</code> in our <code>_start</code> function, we get the following output:<p><img alt="QEMU printing ‚Äúpanicked at ‚ÄòSome panic message‚Äô, src/main.rs:28:5" src=vga-panic.png><p>So we know not only that a panic has occurred, but also the panic message and where in the code it happened.<h2 id=summary><a aria-label="Anchor link for: summary" class=zola-anchor href=#summary>üîó</a>Summary</h2><p>In this post we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address <code>0xb8000</code>. We created a Rust module that encapsulates the unsafety of writing to this memory mapped buffer and presents a safe and convenient interface to the outside.<p>We also saw how easy it is to add dependencies on third-party libraries, thanks to cargo. The two dependencies that we added, <code>lazy_static</code> and <code>spin</code>, are very useful in OS development and we will use them in more places in future posts.<h2 id=what-s-next><a aria-label="Anchor link for: what-s-next" class=zola-anchor href=#what-s-next>üîó</a>What‚Äôs next?</h2><p>The next post explains how to set up Rust‚Äôs built in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.</div><div class=post-footer-support><h2>Support Me</h2><p>Creating and <a href=https://os.phil-opp.com/status-update/>maintaining</a> this blog and the associated libraries is a lot of work, but I really enjoy doing it. By supporting me, you allow me to invest more time in new content, new features, and continuous maintenance.<p>The best way to support me is to <a href=https://github.com/sponsors/phil-opp><em>sponsor me on GitHub</em></a>, since they don't charge any fees. If you prefer other platforms, I also have <a href=https://www.patreon.com/phil_opp><em>Patreon</em></a> and <a href=https://donorbox.org/phil-opp><em>Donorbox</em></a> accounts. The latter is the most flexible as it supports multiple currencies and one-time contributions.<p>Thank you!</div><hr><div class=PageNavigation><a class=prev href=/minimal-rust-kernel/>¬´ A Minimal Rust Kernel</a><a class=next href=/testing/>Testing ¬ª</a></div><hr><section><h2 id=comments>Comments</h2><p class=comment-note>Do you have a problem, want to share feedback, or discuss further ideas? Feel free to leave a comment here! Please stick to English and follow Rust's <a href=https://www.rust-lang.org/policies/code-of-conduct>code of conduct</a>. This comment thread directly maps to a <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="VGA Text Mode"'><em>discussion on GitHub</em></a>, so you can also comment there if you prefer.<div class=giscus></div><script data-category="Post Comments" data-repo-id="MDEwOlJlcG9zaXRvcnkzOTU3NTEwMQ==" data-term="VGA Text Mode" async crossorigin=anonymous data-category-id=MDE4OkRpc2N1c3Npb25DYXRlZ29yeTMzMDE4OTg1 data-emit-metadata=1 data-mapping=specific data-reactions-enabled=1 data-repo=phil-opp/blog_os data-theme=preferred_color_scheme src=https://giscus.app/client.js></script><p class=comment-directly-on-github>Instead of authenticating the <a href=https://giscus.app>giscus</a> application, you can also comment directly <a href='https://github.com/phil-opp/blog_os/discussions/categories/post-comments?discussions_q="VGA Text Mode"'><em>on GitHub</em></a>.</section><aside class=page-aside-right><div class=block id=language-selector><h2>Other Languages</h2><ul><li data-lang-switch-to=zh-CN><a href=https://os.phil-opp.com/zh-CN/vga-text-mode/> Chinese (simplified) </a><li data-lang-switch-to=ja><a href=https://os.phil-opp.com/ja/vga-text-mode/> Japanese </a><li data-lang-switch-to=fa><a href=https://os.phil-opp.com/fa/vga-text-mode/> Persian </a></ul></div><div class="dark-mode-note warning"><h2>Dark Mode is Experimental</h2><p>We're still working on adjusting text colors, fixing images, and removing inconsistencies. If you have any problems, please <a href=https://github.com/phil-opp/blog_os/issues>file an issue</a>.<aside></aside><main><div><div></div><footer class=footer><hr><small> ¬© <time datetime=2021>2021</time>. All rights reserved. <a href=https://os.phil-opp.com/contact/>Contact</a> </small></footer></div><script async data-goatcounter=https://phil-opp.goatcounter.com/count src=//gc.zgo.at/count.js></script>