<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Writing an OS in Rust</title>
        <link>https://os.phil-opp.com</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://os.phil-opp.com/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 09 Sep 2019 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Updates in August 2019</title>
                <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-09-09/</link>
                <guid>https://os.phil-opp.com/status-update/2019-09-09/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2f;em&gt; blog and the used libraries and tools.&lt;&#x2f;p&gt;
&lt;p&gt;I was very busy with finishing my master&#x27;s thesis, so I didn&#x27;t have any to implement any notable changes myself. Thanks to contributions by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt;, we were still able to publish new versions of the &lt;code&gt;x86_64&lt;&#x2f;code&gt;, &lt;code&gt;bootimage&lt;&#x2f;code&gt; and &lt;code&gt;bootloader&lt;&#x2f;code&gt; crates.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;&lt;code&gt;blog_os&lt;&#x2f;code&gt;&lt;&#x2f;h2&gt;
&lt;p&gt;Apart from &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;650&quot;&gt;rewriting the section about no-harness tests&lt;&#x2f;a&gt; of the &lt;em&gt;Testing&lt;&#x2f;em&gt; post, there were no notable changes to the blog in August. Now that I have some more free time again, I plan to upgrade the blog to the latest versions of &lt;code&gt;bootloader&lt;&#x2f;code&gt; and &lt;code&gt;bootimage&lt;&#x2f;code&gt;, evaluate the use of &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;features&#x2f;actions&quot;&gt;GitHub Actions&lt;&#x2f;a&gt; for the repository, and continue the work on the upcoming post about heap allocator implementations.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;&lt;code&gt;x86_64&lt;&#x2f;code&gt;&lt;&#x2f;h2&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;vinaychandra&quot;&gt;@vinaychandra&lt;&#x2f;a&gt;, the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate now has &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;87&quot;&gt;support for the &lt;code&gt;FsBase&lt;&#x2f;code&gt; and &lt;code&gt;GsBase&lt;&#x2f;code&gt; registers&lt;&#x2f;a&gt;. The change was published as version 0.7.5.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;&lt;code&gt;bootimage&lt;&#x2f;code&gt;&lt;&#x2f;h2&gt;
&lt;p&gt;To allow bootloaders to read configuration from the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; file of the kernel, the &lt;code&gt;bootimage&lt;&#x2f;code&gt; crate now &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;45&quot;&gt;passes the location of the kernel&#x27;s Cargo.toml to bootloader crates&lt;&#x2f;a&gt;. This change was implemented by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; and published as version 0.7.7.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2f;code&gt;&lt;&#x2f;h2&gt;
&lt;p&gt;Apart from initializing the CPU and loading the kernel, the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate is also responsible for creating several memory regions for the kernel, for example a program stack and the boot information struct. These regions must be mapped at some address in the virtual address space.&lt;&#x2f;p&gt;
&lt;p&gt;As a stop-gap solution, the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate used fixed virtual addresses for these regions, which resulted in errors if the kernel tried to use the same address ranges itself. For example, the (optional) recursive mapping of page tables often conflicted with so-called &lt;em&gt;higher half kernels&lt;&#x2f;em&gt;, which live at the upper end of the address space. To avoid these conflicts, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; updated the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;71&quot;&gt;dynamically map the kernel stack, boot info, physical memory, and recursive table regions&lt;&#x2f;a&gt; at an unused virtual address range.&lt;&#x2f;p&gt;
&lt;p&gt;To also support specifying explicit addresses for these regions, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; further added support for &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;73&quot;&gt;parsing bootloader configuration from the kernel&#x27;s Cargo.toml&lt;&#x2f;a&gt;. This way, the virtual addresses of the kernel stack and physical memory mapping can now be configured using a &lt;code&gt;package.metadata.bootloader&lt;&#x2f;code&gt; key in the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; of the kernel. In a third pull request, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; also made the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;72&quot;&gt;kernel stack size configurable&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The changes were published together as version 0.8.0. This is a breaking update because the new configuration system requires at least version 0.7.7 of &lt;code&gt;bootimage&lt;&#x2f;code&gt;, which is the first version that passes the location of the kernel&#x27;s &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; file.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in July 2019</title>
                <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-08-02/</link>
                <guid>https://os.phil-opp.com/status-update/2019-08-02/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2f;em&gt; blog and the used libraries and tools.&lt;&#x2f;p&gt;
&lt;p&gt;Since I&#x27;m still very busy with my master thesis, I haven&#x27;t had the time to work on a new post. But there were quite a few maintenance updates this month and also a few new features such as the new &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt; type in the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate.&lt;&#x2f;p&gt;
&lt;p&gt;We also had some great contributions this month. Thanks to the efforts of &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt;, we were able to considerably lower the compile times of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; and &lt;code&gt;bootloader&lt;&#x2f;code&gt; crates. Thanks to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2f;a&gt;, the &lt;code&gt;cargo-xbuild&lt;&#x2f;code&gt; crate now has a  &lt;code&gt;cargo xdoc&lt;&#x2f;code&gt; subcommands and support for the &lt;code&gt;cargo {c, b, t, r}&lt;&#x2f;code&gt; aliases.&lt;&#x2f;p&gt;
&lt;p&gt;The following list gives a short overview of notable changes to the different projects.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;638&quot;&gt;Fix a lot of dead links in both the second and first edition&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;644&quot;&gt;Update paging introduction post to use page fault error code&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;82&quot;&gt;Reexport MappedPageTable on non-x86_64 platforms too&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;78&quot;&gt;Update GDT docs, add user_data_segment function and WRITABLE flag&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; (published as version 0.7.2)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;83&quot;&gt;Add a new &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt; mapper type&lt;&#x2f;a&gt; (published as version 0.7.3)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;86&quot;&gt;Update integration tests to use new testing framework&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;85&quot;&gt;Remove raw-cpuid dependency and use rdrand intrinsics&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; (published as version 0.7.4)&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;62&quot;&gt;Remove stabilized publish-lockfile feature&lt;&#x2f;a&gt; (published as version 0.6.2)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;63&quot;&gt;Update CI badge, use latest version of x86_64 crate and rustfmt&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt; (published as version 0.6.3)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;67&quot;&gt;Use volatile accesses in VGA code and make font dependency optional&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt;
&lt;ul&gt;
&lt;li&gt;Making the dependency optional should improve compile times when the VGA text mode is used&lt;&#x2f;li&gt;
&lt;li&gt;Published as version 0.6.4&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Breaking&lt;&#x2f;strong&gt;: &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;68&quot;&gt;Only include dependencies when &lt;code&gt;binary&lt;&#x2f;code&gt; feature is enabled&lt;&#x2f;a&gt; (published as version 0.7.0)&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;bootimage&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;43&quot;&gt;If the bootloader has a feature named &lt;code&gt;binary&lt;&#x2f;code&gt;, enable it&lt;&#x2f;a&gt; (published as version 0.7.6)
&lt;ul&gt;
&lt;li&gt;This is required for building &lt;code&gt;bootloader 0.7.0&lt;&#x2f;code&gt; or later&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;39&quot;&gt;Add &lt;code&gt;cargo xdoc&lt;&#x2f;code&gt; command for invoking &lt;code&gt;cargo doc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2f;a&gt; (published as version 0.5.13)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;40&quot;&gt;Don&#x27;t append a &lt;code&gt;--sysroot&lt;&#x2f;code&gt; argument to &lt;code&gt;RUSTFLAGS&lt;&#x2f;code&gt; if it already contains one&lt;&#x2f;a&gt; (published as version 0.5.14)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;42&quot;&gt;Add xb, xt, xc, and xr subcommands&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;Aehmlo&quot;&gt;@Aehmlo&lt;&#x2f;a&gt; (published as version 0.5.15)&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in June 2019</title>
                <pubDate>Sat, 06 Jul 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-07-06/</link>
                <guid>https://os.phil-opp.com/status-update/2019-07-06/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2f;em&gt; blog and the used libraries and tools.&lt;&#x2f;p&gt;
&lt;p&gt;My focus this month was to finish the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;&quot;&gt;&lt;em&gt;Heap Allocation&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post, on which I had been working since March. I originally wanted to include a section about different allocator designs (bump, linked list, slab, â€¦) and how to implement them, but I decided to split it out into a separate post because it became much too long. I try to release this half-done post soon.&lt;&#x2f;p&gt;
&lt;p&gt;Apart from the new post, there were some minor updates to the &lt;code&gt;x86_64&lt;&#x2f;code&gt;, &lt;code&gt;bootloader&lt;&#x2f;code&gt; and &lt;code&gt;cargo-xbuild&lt;&#x2f;code&gt; crates. The following gives a short overview of notable changes to the different projects.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;blog_os&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;617&quot;&gt;Use misspell tool to look for common typos&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;625&quot;&gt;New post about heap allocation&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;77&quot;&gt;Add ring-3 flag to GDT descriptor&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;mark-i-m&quot;&gt;@mark-i-m&lt;&#x2f;a&gt; (released as version 0.7.1)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;79&quot;&gt;Add bochs magic breakpoint, read instruction pointer, inline instructions&lt;&#x2f;a&gt; by &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;64&quot;&gt;@64&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;bootloader&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;58&quot;&gt;Make the physical memory offset configurable through a &lt;code&gt;BOOTLOADER_PHYSICAL_MEMORY_OFFSET&lt;&#x2f;code&gt; environment variable&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;59&quot;&gt;Use a stripped copy of the kernel binary (debug info removed) to reduce load times&lt;&#x2f;a&gt; (released as version 0.6.1)&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;!-- ## Bootimage --&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;cargo-xbuild&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;commit&#x2f;994b5e75e1a4062cf506700e0ff38d5404338a37&quot;&gt;Document the XBUILD_SYSROOT_PATH environment variable&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;commit&#x2f;a1ff03311dd74447e8e845b4b96f2e137850027d&quot;&gt;Fix incorrect joining of paths that caused some problems on Windows&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
</description>
            </item>
        
            <item>
                <title>Heap Allocation</title>
                <pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/heap-allocation/</link>
                <guid>https://os.phil-opp.com/heap-allocation/</guid>
                <description>&lt;p&gt;This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post all the allocation and collection types of the built-in &lt;code&gt;alloc&lt;&#x2f;code&gt; crate will be available to our kernel.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-10&quot;&gt;&lt;code&gt;post-10&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;local-and-static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-and-static-variables&quot; aria-label=&quot;Anchor link for: local-and-static-variables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Local and Static Variables&lt;&#x2f;h2&gt;
&lt;p&gt;We currently use two types of variables in our kernel: local variables and &lt;code&gt;static&lt;&#x2f;code&gt; variables. Local variables are stored on the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Call_stack&quot;&gt;call stack&lt;&#x2f;a&gt; and are only valid until the surrounding function returns. Static variables are stored at a fixed memory location and always live for the complete lifetime of the program.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;local-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#local-variables&quot; aria-label=&quot;Anchor link for: local-variables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Local Variables&lt;&#x2f;h3&gt;
&lt;p&gt;Local variables are stored on the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Call_stack&quot;&gt;call stack&lt;&#x2f;a&gt;, which is a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Stack_(abstract_data_type)&quot;&gt;stack data structure&lt;&#x2f;a&gt; that supports &lt;code&gt;push&lt;&#x2f;code&gt; and &lt;code&gt;pop&lt;&#x2f;code&gt; operations. On each function entry, the parameters, the return address, and the local variables of the called function are pushed by the compiler:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;call-stack.svg&quot; alt=&quot;An outer() and an inner(i: usize) function. Both have some local variables. Outer calls inner(1). The call stack contains the following slots: the local variables of outer, then the argument i = 1, then the return address, then the local variables of inner.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The above example shows the call stack after an &lt;code&gt;outer&lt;&#x2f;code&gt; function called an &lt;code&gt;inner&lt;&#x2f;code&gt; function. We see that the call stack contains the local variables of &lt;code&gt;outer&lt;&#x2f;code&gt; first. On the &lt;code&gt;inner&lt;&#x2f;code&gt; call, the parameter &lt;code&gt;1&lt;&#x2f;code&gt; and the return address for the function were pushed. Then control was transferred to &lt;code&gt;inner&lt;&#x2f;code&gt;, which pushed its local variables.&lt;&#x2f;p&gt;
&lt;p&gt;After the &lt;code&gt;inner&lt;&#x2f;code&gt; function returns, its part of the call stack is popped again and only the local variables of &lt;code&gt;outer&lt;&#x2f;code&gt; remain:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;call-stack-return.svg&quot; alt=&quot;The call stack containing only the local variables of outer&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that the local variables of &lt;code&gt;inner&lt;&#x2f;code&gt; only live until the function returns. The Rust compiler enforces these lifetimes and throws an error when we use a value too long, for example when we try to return a reference to a local variable:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;inner(i: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static u32 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; z &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;z[i]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;(&lt;a href=&quot;https:&#x2f;&#x2f;play.rust-lang.org&#x2f;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=6186a0f3a54f468e1de8894996d12819&quot;&gt;run the example on the playground&lt;&#x2f;a&gt;)&lt;&#x2f;p&gt;
&lt;p&gt;While returning a reference makes no sense in this example, there are cases where we want a variable to live longer than the function. We already saw such a case in our kernel when we tried to &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#loading-the-idt&quot;&gt;load an interrupt descriptor table&lt;&#x2f;a&gt; and had to use a &lt;code&gt;static&lt;&#x2f;code&gt; variable to extend the lifetime.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;static-variables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#static-variables&quot; aria-label=&quot;Anchor link for: static-variables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Static Variables&lt;&#x2f;h3&gt;
&lt;p&gt;Static variables are stored at a fixed memory location separate from the stack. This memory location is assigned at compile time by the linker and encoded in the executable. Statics live for the complete runtime of the program, so they have the &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime and can always be referenced from local variables:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;call-stack-static.svg&quot; alt=&quot;The same outer&#x2f;inner example with the difference that inner has a static Z: [u32; 3] = [1,2,3]; and returns a &amp;amp;Z[i] reference&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;When the &lt;code&gt;inner&lt;&#x2f;code&gt; function returns in the above example, it&#x27;s part of the call stack is destroyed. The static variables live in a separate memory range that is never destroyed, so the &lt;code&gt;&amp;amp;Z[1]&lt;&#x2f;code&gt; reference is still valid after the return.&lt;&#x2f;p&gt;
&lt;p&gt;Apart from the &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime, static variables also have the useful property that their location is known at compile time, so that no reference is needed for accessing it. We utilized that property for our &lt;code&gt;println&lt;&#x2f;code&gt; macro: By using a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#a-global-interface&quot;&gt;static &lt;code&gt;Writer&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; internally there is no &lt;code&gt;&amp;amp;mut Writer&lt;&#x2f;code&gt; reference needed to invoke the macro, which is very useful in &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#implementation&quot;&gt;exception handlers&lt;&#x2f;a&gt; where we don&#x27;t have access to any additional variables.&lt;&#x2f;p&gt;
&lt;p&gt;However, this property of static variables brings a crucial drawback: They are read-only by default. Rust enforces this because a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;races.html&quot;&gt;data race&lt;&#x2f;a&gt; would occur if e.g. two threads modify a static variable at the same time. The only way to modify a static variable is to encapsulate it in a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.5.2&#x2f;spin&#x2f;struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type, which ensures that only a single &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; reference exists at any point in time. We already used a &lt;code&gt;Mutex&lt;&#x2f;code&gt; for our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#spinlocks&quot;&gt;static VGA buffer &lt;code&gt;Writer&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;dynamic-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dynamic-memory&quot; aria-label=&quot;Anchor link for: dynamic-memory&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Dynamic Memory&lt;&#x2f;h2&gt;
&lt;p&gt;Local and static variables are already very powerful together and enable most use cases. However, we saw that they both have their limitations:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Local variables only live until the end of the surrounding function or block. This is because they live on the call stack and are destroyed after the surrounding function returns.&lt;&#x2f;li&gt;
&lt;li&gt;Static variables always live for the complete runtime of the program, so there is no way to reclaim and reuse their memory when they&#x27;re no longer needed. Also, they have unclear ownership semantics and are accessible from all functions, so they need to be protected by a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.5.2&#x2f;spin&#x2f;struct.Mutex.html&quot;&gt;&lt;code&gt;Mutex&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; when we want to modify them.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Another limitation of local and static variables is that they have a fixed size. So they can&#x27;t store a collection that dynamically grows when more elements are added. (There are proposals for &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;48055&quot;&gt;unsized rvalues&lt;&#x2f;a&gt; in Rust that would allow dynamically sized local variables, but they only work in some specific cases.)&lt;&#x2f;p&gt;
&lt;p&gt;To circumvent these drawbacks, programming languages often support a third memory region for storing variables called the &lt;strong&gt;heap&lt;&#x2f;strong&gt;. The heap supports &lt;em&gt;dynamic memory allocation&lt;&#x2f;em&gt; at runtime through two functions called &lt;code&gt;allocate&lt;&#x2f;code&gt; and &lt;code&gt;deallocate&lt;&#x2f;code&gt;. It works in the following way: The &lt;code&gt;allocate&lt;&#x2f;code&gt; function returns a free chunk of memory of the specified size that can be used to store a variable. This variable then lives until it is freed by calling the &lt;code&gt;deallocate&lt;&#x2f;code&gt; function with a reference to the variable.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s go through an example:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;call-stack-heap.svg&quot; alt=&quot;The inner function calls allocate(size_of([u32; 3])), writes z.write([1,2,3]);, and returns (z as *mut u32).offset(i). The outer function does deallocate(y, size_of(u32)) on the returned value y.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Here the &lt;code&gt;inner&lt;&#x2f;code&gt; function uses heap memory instead of static variables for storing &lt;code&gt;z&lt;&#x2f;code&gt;. It first allocates a memory block of the required size, which returns a &lt;code&gt;*mut u8&lt;&#x2f;code&gt; &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2f;a&gt;. It then uses the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;ptr&#x2f;fn.write.html&quot;&gt;&lt;code&gt;ptr::write&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to write the array &lt;code&gt;[1,2,3]&lt;&#x2f;code&gt; to it. In the last step, it uses the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;primitive.pointer.html#method.offset&quot;&gt;&lt;code&gt;offset&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function to calculate a pointer to the &lt;code&gt;i&lt;&#x2f;code&gt;th element and then returns it. (Note that we omitted some required casts and unsafe blocks in this example function for brevity.)&lt;&#x2f;p&gt;
&lt;p&gt;The allocated memory lives until it is explicitly freed through a call to &lt;code&gt;deallocate&lt;&#x2f;code&gt;. Thus, the returned pointer is still valid even after &lt;code&gt;inner&lt;&#x2f;code&gt; returned and its part of the call stack was destroyed. The advantage of using heap memory compared to static memory is that the memory can be reused after it is freed, which we do through the &lt;code&gt;deallocate&lt;&#x2f;code&gt; call in &lt;code&gt;outer&lt;&#x2f;code&gt;. After that call, the situation looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;call-stack-heap-freed.svg&quot; alt=&quot;The call stack contains the local variables of outer, the heap contains z[0] and z[2], but no longer z[1].&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that the &lt;code&gt;z[1]&lt;&#x2f;code&gt; slot is free again and can be reused for the next &lt;code&gt;allocate&lt;&#x2f;code&gt; call. However, we also see that &lt;code&gt;z[0]&lt;&#x2f;code&gt; and &lt;code&gt;z[2]&lt;&#x2f;code&gt; are never freed because we never deallocate them. Such a bug is called a &lt;em&gt;memory leak&lt;&#x2f;em&gt; and often the cause of excessive memory consumption of programs (just imagine what happens when we call &lt;code&gt;inner&lt;&#x2f;code&gt; repeatedly in a loop). This might seem bad, but there are much more dangerous types of bugs that can happen with dynamic allocation.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;common-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#common-errors&quot; aria-label=&quot;Anchor link for: common-errors&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Common Errors&lt;&#x2f;h3&gt;
&lt;p&gt;Apart from memory leaks, which are unfortunate but don&#x27;t make the program vulnerable to attackers, there are two common types of bugs with more severe consequences:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;When we accidentally continue to use a variable after calling &lt;code&gt;deallocate&lt;&#x2f;code&gt; on it, we have a so-called &lt;strong&gt;use-after-free&lt;&#x2f;strong&gt; vulnerability. Such a bug causes undefined behavior and can often exploited by attackers to execute arbitrary code.&lt;&#x2f;li&gt;
&lt;li&gt;When we accidentally free a variable twice, we have a &lt;strong&gt;double-free&lt;&#x2f;strong&gt; vulnerability. This is problematic because it might free a different allocation that was allocated in the same spot after the first &lt;code&gt;deallocate&lt;&#x2f;code&gt; call. Thus, it can lead to an use-after-free vulnerability again.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;These types of vulnerabilities are commonly known, so one might expect that people learned how to avoid them by now. But no, such vulnerabilities are still regularly found, for example this recent &lt;a href=&quot;https:&#x2f;&#x2f;securityboulevard.com&#x2f;2019&#x2f;02&#x2f;linux-use-after-free-vulnerability-found-in-linux-2-6-through-4-20-11&#x2f;&quot;&gt;use-after-free vulnerability in Linux&lt;&#x2f;a&gt; that allowed arbitrary code execution. This shows that even the best programmers are not always able to correctly handle dynamic memory in complex projects.&lt;&#x2f;p&gt;
&lt;p&gt;To avoid these issues, many languages such as Java or Python manage dynamic memory automatically using a technique called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Garbage_collection_(computer_science)&quot;&gt;&lt;em&gt;garbage collection&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. The idea is that the programmer never invokes &lt;code&gt;deallocate&lt;&#x2f;code&gt; manually. Instead, the program is regularly paused and scanned for unused heap variables, which are then automatically deallocated. Thus, the above vulnerabilities can never occur. The drawbacks are the performance overhead of the regular scan and the probably long pause times.&lt;&#x2f;p&gt;
&lt;p&gt;Rust takes a different approach to the problem: It uses a concept called &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch04-01-what-is-ownership.html&quot;&gt;&lt;em&gt;ownership&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; that is able to check the correctness of dynamic memory operations at compile time. Thus no garbage collection is needed to avoid the mentioned vulnerabilities, which means that there is no performance overhead. Another advantage of this approach is that the programmer still has fine-grained control over the use of dynamic memory, just like with C or C++.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;allocations-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocations-in-rust&quot; aria-label=&quot;Anchor link for: allocations-in-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocations in Rust&lt;&#x2f;h3&gt;
&lt;p&gt;Instead of letting the programmer manually call &lt;code&gt;allocate&lt;&#x2f;code&gt; and &lt;code&gt;deallocate&lt;&#x2f;code&gt;, the Rust standard library provides abstraction types that call these functions implicitly. The most important type is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;boxed&#x2f;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Box&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;&lt;&#x2f;a&gt;, which is an abstraction for a heap-allocated value. It provides a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; constructor function that takes a value, calls &lt;code&gt;allocate&lt;&#x2f;code&gt; with the size of the value, and then moves the value to the newly allocated slot on the heap. To free the heap memory again, the &lt;code&gt;Box&lt;&#x2f;code&gt; type implements the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch15-03-drop.html&quot;&gt;&lt;code&gt;Drop&lt;&#x2f;code&gt; trait&lt;&#x2f;a&gt; to call &lt;code&gt;deallocate&lt;&#x2f;code&gt; when it goes out of scope:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; z &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new([&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    [â€¦]
} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; z goes out of scope and `deallocate` is called
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This pattern has the strange name &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Resource_acquisition_is_initialization&quot;&gt;&lt;em&gt;resource acquisition is initialization&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; (or &lt;em&gt;RAII&lt;&#x2f;em&gt; for short). It originated in C++, where it is used to implement a similar abstraction type called &lt;a href=&quot;https:&#x2f;&#x2f;en.cppreference.com&#x2f;w&#x2f;cpp&#x2f;memory&#x2f;unique_ptr&quot;&gt;&lt;code&gt;std::unique_ptr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Such a type alone does not suffice to prevent all use-after-free bugs since programmers can still hold on to references after the &lt;code&gt;Box&lt;&#x2f;code&gt; goes out of scope and the corresponding heap memory slot is deallocated:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; z &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new([&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;z[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
}; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; z goes out of scope and `deallocate` is called
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, x);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This is where Rust&#x27;s ownership comes in. It assigns an abstract &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-03-lifetime-syntax.html&quot;&gt;lifetime&lt;&#x2f;a&gt; to each reference, which is the scope in which the reference is valid. In the above example, the &lt;code&gt;x&lt;&#x2f;code&gt; reference is taken from the &lt;code&gt;z&lt;&#x2f;code&gt; array, so it becomes invalid after &lt;code&gt;z&lt;&#x2f;code&gt; goes out of scope. When you &lt;a href=&quot;https:&#x2f;&#x2f;play.rust-lang.org&#x2f;?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=28180d8de7b62c6b4a681a7b1f745a48&quot;&gt;run the above example on the playground&lt;&#x2f;a&gt; you see that the Rust compiler indeed throws an error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0597]: `z[_]` does not live long enough
 --&amp;gt; src&#x2f;main.rs:4:9
  |
2 |     let x = {
  |         - borrow later stored here
3 |         let z = Box::new([1,2,3]);
4 |         &amp;amp;z[1]
  |         ^^^^^ borrowed value does not live long enough
5 |     }; &#x2f;&#x2f; z goes out of scope and `deallocate` is called
  |     - `z[_]` dropped here while still borrowed
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The terminology can be a bit confusing at first. Taking a reference to a value is called &lt;em&gt;borrowing&lt;&#x2f;em&gt; the value since it&#x27;s similar to a borrow in real life: You have temporary access to an object but need to return it sometime and you must not destroy it. By checking that all borrows end before an object is destroyed, the Rust compiler can guarantee that no use-after-free situation can occur.&lt;&#x2f;p&gt;
&lt;p&gt;Rust&#x27;s ownership system goes even further and does not only prevent use-after-free bugs, but provides complete &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory_safety&quot;&gt;&lt;em&gt;memory safety&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; like garbage collected languages like Java or Python do. Additionally, it guarantees &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Thread_safety&quot;&gt;&lt;em&gt;thread safety&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and is thus even safer than those languages in multi-threaded code. And most importantly, all these checks happen at compile time, so there is no runtime overhead compared to hand written memory management in C.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;use-cases&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#use-cases&quot; aria-label=&quot;Anchor link for: use-cases&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Use Cases&lt;&#x2f;h3&gt;
&lt;p&gt;We now know the basics of dynamic memory allocation in Rust, but when should we use it? We&#x27;ve come really far with our kernel without dynamic memory allocation, so why do we need it now?&lt;&#x2f;p&gt;
&lt;p&gt;First, dynamic memory allocation always comes with a bit of performance overhead, since we need to find a free slot on the heap for every allocation. For this reason local variables are generally preferable, especially in performance sensitive kernel code. However, there are cases where dynamic memory allocation is the best choice.&lt;&#x2f;p&gt;
&lt;p&gt;As a basic rule, dynamic memory is required for variables that have a dynamic lifetime or a variable size. The most important type with a dynamic lifetime is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;rc&#x2f;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Rc&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;&lt;&#x2f;a&gt;, which counts the references to its wrapped value and deallocates it after all references went out of scope. Examples for types with a variable size are &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;vec&#x2f;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;Vec&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;string&#x2f;index.html&quot;&gt;&lt;strong&gt;&lt;code&gt;String&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;&lt;&#x2f;a&gt;, and other &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;index.html&quot;&gt;collection types&lt;&#x2f;a&gt; that dynamically grow when more elements are added. These types work by allocating a larger amount of memory when they become full, copying all elements over, and then deallocating the old allocation.&lt;&#x2f;p&gt;
&lt;p&gt;For our kernel we will mostly need the collection types, for example for storing a list of active tasks when implementing multitasking in future posts.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-allocator-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-interface&quot; aria-label=&quot;Anchor link for: the-allocator-interface&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Allocator Interface&lt;&#x2f;h2&gt;
&lt;p&gt;The first step in implementing a heap allocator is to add a dependency on the built-in &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;&quot;&gt;&lt;code&gt;alloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate. Like the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;&quot;&gt;&lt;code&gt;core&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate, it is a subset of the standard library that additionally contains the allocation and collection types. To add the dependency on &lt;code&gt;alloc&lt;&#x2f;code&gt;, we add the following to our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Contrary to normal dependencies, we don&#x27;t need to modify the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;. The reason is that the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate ships with the Rust compiler as part of the standard library, so we just need to enable it. This is what this &lt;code&gt;extern crate&lt;&#x2f;code&gt; statement does. (Historically, all dependencies needed an &lt;code&gt;extern crate&lt;&#x2f;code&gt; statement, which is now optional).&lt;&#x2f;p&gt;
&lt;p&gt;The reason that the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate is disabled by default in &lt;code&gt;#[no_std]&lt;&#x2f;code&gt; crates is that it has additional requirements. We can see these requirements as errors when we try to compile our project now:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: no global memory allocator found but one is required; link to std or add
       #[global_allocator] to a static item that implements the GlobalAlloc trait.

error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The first error occurs because the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate requires an heap allocator, which is an object that provides the &lt;code&gt;allocate&lt;&#x2f;code&gt; and &lt;code&gt;deallocate&lt;&#x2f;code&gt; functions. In Rust, heap allocators are described by the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait, which is mentioned in the error message. To set the heap allocator for the crate, the &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; attribute must be applied to a &lt;code&gt;static&lt;&#x2f;code&gt; variable that implements the &lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt; trait.&lt;&#x2f;p&gt;
&lt;p&gt;The second error occurs because calls to &lt;code&gt;allocate&lt;&#x2f;code&gt; can fail, most commonly when there is no more memory available. Our program must be able to react to this case, which is what the &lt;code&gt;#[alloc_error_handler]&lt;&#x2f;code&gt; function is for.&lt;&#x2f;p&gt;
&lt;p&gt;We will describe these traits and attributes in detail in the following sections.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-globalalloc-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-globalalloc-trait&quot; aria-label=&quot;Anchor link for: the-globalalloc-trait&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt; Trait&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html&quot;&gt;&lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait defines the functions that a heap allocator must provide. The trait is special because it is almost never used directly by the programmer. Instead, the compiler will automatically insert the appropriate calls to the trait methods when using the allocation and collection types of &lt;code&gt;alloc&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Since we will need to implement the trait for all our allocator types, it is worth taking a closer look at its declaration:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalAlloc {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_zeroed(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;realloc(
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
        ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        layout: Layout,
        new_size: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It defines the two required methods &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;&quot;&gt;&lt;code&gt;alloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, which correspond to the &lt;code&gt;allocate&lt;&#x2f;code&gt; and &lt;code&gt;deallocate&lt;&#x2f;code&gt; functions we used in our examples:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;&quot;&gt;&lt;code&gt;alloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method takes a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;struct.Layout.html&quot;&gt;&lt;code&gt;Layout&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instance as argument, which describes the desired size and alignment that the allocated memory should have. It returns a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2f;a&gt; to the first byte of the allocated memory block. Instead of an explicit error value, the &lt;code&gt;alloc&lt;&#x2f;code&gt; method returns a null pointer to signal an allocation error. This is a bit non-idiomatic, but it has the advantage that wrapping existing system allocators is easy, since they use the same convention.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#tymethod.dealloc&quot;&gt;&lt;code&gt;dealloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method is the counterpart and responsible for freeing a memory block again. It receives two arguments, the pointer returned by &lt;code&gt;alloc&lt;&#x2f;code&gt; and the &lt;code&gt;Layout&lt;&#x2f;code&gt; that was used for the allocation.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The trait additionally defines the two methods &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; with default implementations:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#method.alloc_zeroed&quot;&gt;&lt;code&gt;alloc_zeroed&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method is equivalent to calling &lt;code&gt;alloc&lt;&#x2f;code&gt; and then setting the allocated memory block to zero, which is exactly what the provided default implementation does. An allocator implementations can override the default implementations with a more efficient custom implementation if possible.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;alloc&#x2f;trait.GlobalAlloc.html#method.realloc&quot;&gt;&lt;code&gt;realloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method allows to grow or shrink an allocation. The default implementation allocates a new memory block with the desired size and copies over all the content from the previous allocation. Again, an allocator implementation can probably provide a more efficient implementation of this method, for example by growing&#x2f;shrinking the allocation in-place if possible.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h4 id=&quot;unsafety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unsafety&quot; aria-label=&quot;Anchor link for: unsafety&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Unsafety&lt;&#x2f;h4&gt;
&lt;p&gt;One thing to notice is that both the trait itself and all trait methods are declared as &lt;code&gt;unsafe&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The reason for declaring the trait as &lt;code&gt;unsafe&lt;&#x2f;code&gt; is that the programmer must guarantee that the trait implementation for an allocator type is correct. For example, the &lt;code&gt;alloc&lt;&#x2f;code&gt; method must never return a memory block that is already used somewhere else because this would cause undefined behavior.&lt;&#x2f;li&gt;
&lt;li&gt;Similarly, the reason that the methods are &lt;code&gt;unsafe&lt;&#x2f;code&gt; is that the caller must ensure various invariants when calling the methods, for example that the &lt;code&gt;Layout&lt;&#x2f;code&gt; passed to &lt;code&gt;alloc&lt;&#x2f;code&gt; specifies a non-zero size. This is not really relevant in practice since the methods are normally called directly by the compiler, which ensures that the requirements are met.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;a-dummyallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummyallocator&quot; aria-label=&quot;Anchor link for: a-dummyallocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A &lt;code&gt;DummyAllocator&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;Now that we know what an allocator type should provide, we can create a simple dummy allocator. For that we create a new &lt;code&gt;allocator&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocator;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our dummy allocator does the absolute minimum to implement the trait and always return an error when &lt;code&gt;alloc&lt;&#x2f;code&gt; is called. It looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::alloc::{GlobalAlloc, Layout};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ptr::null_mut;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Dummy;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalAlloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Dummy {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, _layout: Layout) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        null_mut()
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, _ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, _layout: Layout) {
        panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dealloc should be never called&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The struct does not need any fields, so we create it as a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero sized type&lt;&#x2f;a&gt;. As mentioned above, we always return the null pointer from &lt;code&gt;alloc&lt;&#x2f;code&gt;, which corresponds to an allocation error. Since the allocator never returns any memory, a call to &lt;code&gt;dealloc&lt;&#x2f;code&gt; should never occur. For this reason we simply panic in the &lt;code&gt;dealloc&lt;&#x2f;code&gt; method. The &lt;code&gt;alloc_zeroed&lt;&#x2f;code&gt; and &lt;code&gt;realloc&lt;&#x2f;code&gt; methods have default implementations, so we don&#x27;t need to provide implementations for them.&lt;&#x2f;p&gt;
&lt;p&gt;We now have a simple allocator, but we still have to tell the Rust compiler that it should use this allocator. This is where the &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; attribute comes in.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-global-allocator-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-allocator-attribute&quot; aria-label=&quot;Anchor link for: the-global-allocator-attribute&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; Attribute&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; attribute tells the Rust compiler which allocator instance it should use as the global heap allocator. The attribute is only applicable to a &lt;code&gt;static&lt;&#x2f;code&gt; that implements the &lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt; trait. Let&#x27;s register an instance of our &lt;code&gt;Dummy&lt;&#x2f;code&gt; allocator as the global allocator:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: allocator::Dummy &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocator::Dummy;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since the &lt;code&gt;Dummy&lt;&#x2f;code&gt; allocator is a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;exotic-sizes.html#zero-sized-types-zsts&quot;&gt;zero sized type&lt;&#x2f;a&gt;, we don&#x27;t need to specify any fields in the initialization expression. Note that the &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; module &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;pull&#x2f;51335&quot;&gt;cannot be used in submodules&lt;&#x2f;a&gt;, so we need to put it into the &lt;code&gt;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;When we now try to compile it, the first error should be gone. Let&#x27;s fix the remaining second error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `#[alloc_error_handler]` function required, but not found
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;the-alloc-error-handler-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-alloc-error-handler-attribute&quot; aria-label=&quot;Anchor link for: the-alloc-error-handler-attribute&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;#[alloc_error_handler]&lt;&#x2f;code&gt; Attribute&lt;&#x2f;h3&gt;
&lt;p&gt;As we learned when discussing the &lt;code&gt;GlobalAlloc&lt;&#x2f;code&gt; trait, the &lt;code&gt;alloc&lt;&#x2f;code&gt; function can signal an allocation error by returning a null pointer. The question is: how should the Rust runtime react to such an allocation failure? This is where the &lt;code&gt;#[alloc_error_handler]&lt;&#x2f;code&gt; attribute comes in. It specifies a function that is called when an allocation error occurs, similar to how our panic handler is called when a panic occurs.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add such a function to fix the compilation error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(alloc_error_handler)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; at the top of the file

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[alloc_error_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_error_handler(layout: alloc::alloc::Layout) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;allocation error: {:?}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;alloc_error_handler&lt;&#x2f;code&gt; function is still unstable, so we need a feature gate to enable it. The function receives a single argument: the &lt;code&gt;Layout&lt;&#x2f;code&gt; instance that was passed to &lt;code&gt;alloc&lt;&#x2f;code&gt; when the allocation failure occurred. There&#x27;s nothing we can do to resolve the failure, so we just panic with a message that contains the &lt;code&gt;Layout&lt;&#x2f;code&gt; instance.&lt;&#x2f;p&gt;
&lt;p&gt;With this function, the compilation errors should be fixed. Now we can use the allocation and collection types of &lt;code&gt;alloc&lt;&#x2f;code&gt;, for example we can use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; to allocate a value on the heap:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] print &amp;quot;Hello World!&amp;quot;, call `init`, create `mapper` and `frame_allocator`

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] call `test_main` in test mode

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we need to specify the &lt;code&gt;extern crate alloc&lt;&#x2f;code&gt; statement in our &lt;code&gt;main.rs&lt;&#x2f;code&gt; too. This is required because the &lt;code&gt;lib.rs&lt;&#x2f;code&gt; and &lt;code&gt;main.rs&lt;&#x2f;code&gt; part are treated as separate crates. However, we don&#x27;t need to create another &lt;code&gt;#[global_allocator]&lt;&#x2f;code&gt; static because the global allocator applies to all crates in the project. In fact, specifying an additional allocator in another crate would be an error.&lt;&#x2f;p&gt;
&lt;p&gt;When we run the above code, we see that our &lt;code&gt;alloc_error_handler&lt;&#x2f;code&gt; function is called:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;qemu-dummy-output.png&quot; alt=&quot;QEMU printing &amp;quot;panicked at `allocation error: Layout { size_: 4, align_: 4 }, src&#x2f;lib.rs:89:5&amp;quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The error handler is called because the &lt;code&gt;Box::new&lt;&#x2f;code&gt; function implicitly calls the &lt;code&gt;alloc&lt;&#x2f;code&gt; function of the global allocator. Our dummy allocator always returns a null pointer, so every allocation fails. To fix this we need to create an allocator that actually returns usable memory.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;creating-a-kernel-heap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-kernel-heap&quot; aria-label=&quot;Anchor link for: creating-a-kernel-heap&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a Kernel Heap&lt;&#x2f;h2&gt;
&lt;p&gt;Before we can create a proper allocator, we first need to create a heap memory region from which the allocator can allocate memory. To do this, we need to define a virtual memory range for the heap region and then map this region to physical frames. See the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;&quot;&gt;&lt;em&gt;&amp;quot;Introduction To Paging&amp;quot;&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post for an overview of virtual memory and page tables.&lt;&#x2f;p&gt;
&lt;p&gt;The first step is to define a virtual memory region for the heap. We can choose any virtual address range that we like, as long as it is not already used for a different memory region. Let&#x27;s define it as the memory starting at address &lt;code&gt;0x_4444_4444_0000&lt;&#x2f;code&gt; so that we can easily recognize a heap pointer later:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x_4444_4444_0000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; 100 KiB
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We set the heap size to 100 KiB for now. If we need more space in the future, we can simply increase it.&lt;&#x2f;p&gt;
&lt;p&gt;If we tried to use this heap region now, a page fault would occur since the virtual memory region is not mapped to physical memory yet. To resolve this, we create an &lt;code&gt;init_heap&lt;&#x2f;code&gt; function that maps the heap pages using the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#using-mappedpagetable&quot;&gt;&lt;code&gt;Mapper&lt;&#x2f;code&gt; API&lt;&#x2f;a&gt; that we introduced in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;&quot;&gt;&lt;em&gt;&amp;quot;Paging Implementation&amp;quot;&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{
    structures::paging::{
        mapper::MapToError, FrameAllocator, Mapper, Page, PageTableFlags, Size4KiB,
    },
    VirtAddr,
};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_heap(
    mapper: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
    frame_allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) -&amp;gt; Result&amp;lt;(), MapToError&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_range &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(heap_start);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(heap_end);
        Page::range_inclusive(heap_start_page, heap_end_page)
    };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_range {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator
            .allocate_frame()
            .ok_or(MapToError::FrameAllocationFailed)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageTableFlags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageTableFlags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ mapper.map_to(page, frame, flags, frame_allocator)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.flush() };
    }

    Ok(())
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The function takes mutable references to a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instance, both limited to 4KiB pages by using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;enum.Size4KiB.html&quot;&gt;&lt;code&gt;Size4KiB&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; as generic parameter. The return value of the function is a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; with the unit type &lt;code&gt;()&lt;&#x2f;code&gt; as success variant and a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;enum.MapToError.html&quot;&gt;&lt;code&gt;MapToError&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; as error variant, which is the error type returned by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method. Reusing the error type makes sense here because the &lt;code&gt;map_to&lt;&#x2f;code&gt; method is the main source of errors in this function.&lt;&#x2f;p&gt;
&lt;p&gt;The implementation can be broken down into two parts:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Creating the page range:&lt;&#x2f;strong&gt;: To create a range of the pages that we want to map, we convert the &lt;code&gt;HEAP_START&lt;&#x2f;code&gt; pointer to a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type. Then we calculate the heap end address from it by adding the &lt;code&gt;HEAP_SIZE&lt;&#x2f;code&gt;. We want an inclusive bound (the address of the last byte of the heap), so we subtract 1. Next, we convert the addresses into &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;struct.Page.html&quot;&gt;&lt;code&gt;Page&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; types using the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;struct.Page.html#method.containing_address&quot;&gt;&lt;code&gt;containing_address&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function. Finally, we create a page range from the start and end pages using the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;struct.Page.html#method.range_inclusive&quot;&gt;&lt;code&gt;Page::range_inclusive&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mapping the pages:&lt;&#x2f;strong&gt; The second step is to map all pages of the page range we just created. For that we iterate over the pages in that range using a &lt;code&gt;for&lt;&#x2f;code&gt; loop. For each page, we do the following:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;We allocate a physical frame that the page should be mapped to using the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;trait.FrameAllocator.html#tymethod.allocate_frame&quot;&gt;&lt;code&gt;FrameAllocator::allocate_frame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method. This method returns &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;option&#x2f;enum.Option.html#variant.None&quot;&gt;&lt;code&gt;None&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; when there are no more frames left. We deal with that case by mapping it to a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;enum.MapToError.html#variant.FrameAllocationFailed&quot;&gt;&lt;code&gt;MapToError::FrameAllocationFailed&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; error through the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;option&#x2f;enum.Option.html#method.ok_or&quot;&gt;&lt;code&gt;Option::ok_or&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method and then apply the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;edition-guide&#x2f;rust-2018&#x2f;error-handling-and-panics&#x2f;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2f;a&gt; to return early in the case of an error.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;We set the required &lt;code&gt;PRESENT&lt;&#x2f;code&gt; flag and the &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flag for the page. With these flags both read and write accesses are allowed, which makes sense for heap memory.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;We use the unsafe &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;Mapper::map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method for creating the mapping in the active page table. The method can fail, therefore we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;edition-guide&#x2f;rust-2018&#x2f;error-handling-and-panics&#x2f;the-question-mark-operator-for-easier-error-handling.html&quot;&gt;question mark operator&lt;&#x2f;a&gt; again to forward the error to the caller. On success, the method returns a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instance that we can use to update the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#the-translation-lookaside-buffer&quot;&gt;&lt;em&gt;translation lookaside buffer&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; using the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The final step is to call this function from our &lt;code&gt;kernel_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::allocator; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new import
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::{self, BootInfoFrameAllocator};

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(boot_info.physical_memory_offset) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map)
    };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocator::init_heap(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] call `test_main` in test mode

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We show the full function for context here. The only new lines are the &lt;code&gt;blog_os::allocator&lt;&#x2f;code&gt; import and the call to &lt;code&gt;allocator::init_heap&lt;&#x2f;code&gt; function. In case the &lt;code&gt;init_heap&lt;&#x2f;code&gt; function returns an error, we panic using the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;Result::expect&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method since there is currently no sensible way for us to handle this error.&lt;&#x2f;p&gt;
&lt;p&gt;We now have a mapped heap memory region that is ready to be used. The &lt;code&gt;Box::new&lt;&#x2f;code&gt; call still uses our old &lt;code&gt;Dummy&lt;&#x2f;code&gt; allocator, so you will still see the &amp;quot;out of memory&amp;quot; error when you run it. Let&#x27;s fix this by using a proper allocator.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;using-an-allocator-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-an-allocator-crate&quot; aria-label=&quot;Anchor link for: using-an-allocator-crate&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using an Allocator Crate&lt;&#x2f;h2&gt;
&lt;p&gt;Since implementing an allocator is somewhat complex, we start by using an external allocator crate. We will learn how to implement our own allocator in the next post.&lt;&#x2f;p&gt;
&lt;p&gt;A simple allocator crate for &lt;code&gt;no_std&lt;&#x2f;code&gt; applications is the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;linked-list-allocator&#x2f;&quot;&gt;&lt;code&gt;linked_list_allocator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate. It&#x27;s name comes from the fact that it uses a linked list data structure to keep track of deallocated memory regions. See the next post for a more detailed explanation of this approach.&lt;&#x2f;p&gt;
&lt;p&gt;To use the crate, we first need to add a dependency on it in our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;linked_list_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.6.4&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Then we can replace our dummy allocator with the allocator provided by the crate:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linked_list_allocator::LockedHeap;

#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: LockedHeap &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;LockedHeap::empty();
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The struct is named &lt;code&gt;LockedHeap&lt;&#x2f;code&gt; because it uses a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.5.2&#x2f;spin&#x2f;struct.Mutex.html&quot;&gt;&lt;code&gt;spin::Mutex&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for synchronization. This is required because multiple threads could access the &lt;code&gt;ALLOCATOR&lt;&#x2f;code&gt; static at the same time. As always when using a &lt;code&gt;Mutex&lt;&#x2f;code&gt;, we need to be careful to not accidentally cause a deadlock. This means that we shouldn&#x27;t perform any allocations in interrupt handlers, since they can run at an arbitrary time and might interrupt an in-progress allocation.&lt;&#x2f;p&gt;
&lt;p&gt;Setting the &lt;code&gt;LockedHeap&lt;&#x2f;code&gt; as global allocator is not enough. The reason is that we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.6.4&#x2f;linked_list_allocator&#x2f;struct.LockedHeap.html#method.empty&quot;&gt;&lt;code&gt;empty&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; constructor function, which creates an allocator without any backing memory. Like our dummy allocator, it always returns an error on &lt;code&gt;alloc&lt;&#x2f;code&gt;. To fix this, we need to initialize the allocator after creating the heap:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_heap(
    mapper: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl Mapper&amp;lt;Size4KiB&amp;gt;,
    frame_allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) -&amp;gt; Result&amp;lt;(), MapToError&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] map all heap pages to physical frames

    &#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }

    Ok(())
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.6.4&#x2f;linked_list_allocator&#x2f;struct.LockedHeap.html#method.lock&quot;&gt;&lt;code&gt;LockedHeap::lock&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to get an exclusive reference to the wrapped &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.6.4&#x2f;linked_list_allocator&#x2f;struct.Heap.html&quot;&gt;&lt;code&gt;Heap&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instance, on which we then call the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.6.4&#x2f;linked_list_allocator&#x2f;struct.Heap.html#method.init&quot;&gt;&lt;code&gt;init&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method with the heap bounds as arguments. It is important that we initialize the heap &lt;em&gt;after&lt;&#x2f;em&gt; mapping the heap pages, since the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.6.4&#x2f;linked_list_allocator&#x2f;struct.Heap.html#method.init&quot;&gt;&lt;code&gt;init&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function already tries to write to the heap memory.&lt;&#x2f;p&gt;
&lt;p&gt;After initializing the heap, we can now use all allocation and collection types of the built-in &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;&quot;&gt;&lt;code&gt;alloc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate without error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::{boxed::Box, vec, vec::Vec, rc::Rc};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] initialize interrupts, mapper, frame_allocator, heap

    &#x2f;&#x2f; allocate a number on the heap
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_value &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap_value at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, heap_value);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create a dynamically sized vector
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vec &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Vec::new();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;500 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        vec.push(i);
    }
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;vec at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:p}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, vec.as_slice());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create a reference counted vector -&amp;gt; will be freed when count reaches 0
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; reference_counted &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Rc::new(vec![&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; cloned_reference &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; reference_counted.clone();
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;current reference count is &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Rc::strong_count(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cloned_reference));
    core::mem::drop(reference_counted);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;reference count is &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; now&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Rc::strong_count(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cloned_reference));

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; [â€¦] call `test_main` in test context
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This code example shows some uses of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;vec&#x2f;&quot;&gt;&lt;code&gt;Vec&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;rc&#x2f;&quot;&gt;&lt;code&gt;Rc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; types. For the &lt;code&gt;Box&lt;&#x2f;code&gt; and &lt;code&gt;Vec&lt;&#x2f;code&gt; types we print the underlying heap pointers using the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;fmt&#x2f;trait.Pointer.html&quot;&gt;&lt;code&gt;{:p}&lt;&#x2f;code&gt; formatting specifier&lt;&#x2f;a&gt;. For showcasing &lt;code&gt;Rc&lt;&#x2f;code&gt;, we create a reference counted heap value and use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;rc&#x2f;struct.Rc.html#method.strong_count&quot;&gt;&lt;code&gt;Rc::strong_count&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function to print the current reference count, before and after dropping an instance (using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;mem&#x2f;fn.drop.html&quot;&gt;&lt;code&gt;core::mem::drop&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;When we run it, we see the following:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;heap-allocation&#x2f;qemu-alloc-showcase.png&quot; alt=&quot;QEMU printing ` heap_value at 0x444444440000 vec at 0x4444444408000 current reference count is 2 reference count is 1 now &quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As expected, we see that the &lt;code&gt;Box&lt;&#x2f;code&gt; and &lt;code&gt;Vec&lt;&#x2f;code&gt; values live on the heap, as indicated by the pointer starting with &lt;code&gt;0x_4444_4444&lt;&#x2f;code&gt;. The reference counted value also behaves as expected, with the reference count being 2 after the &lt;code&gt;clone&lt;&#x2f;code&gt; call, and 1 again after one of the instances was dropped.&lt;&#x2f;p&gt;
&lt;p&gt;The reason that the vector starts at offset &lt;code&gt;0x800&lt;&#x2f;code&gt; is not that the boxed value is &lt;code&gt;0x800&lt;&#x2f;code&gt; bytes large, but the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;vec&#x2f;struct.Vec.html#capacity-and-reallocation&quot;&gt;reallocations&lt;&#x2f;a&gt; that occur when the vector needs to increase its capacity. For example, when the vector&#x27;s capacity is 32 and we try to add the next element, the vector allocates a new backing array with capacity 64 behind the scenes and copies all elements over. Then it frees the old allocation.&lt;&#x2f;p&gt;
&lt;p&gt;Of course there are many more allocation and collection types in the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate that we can now all use in our kernel, including:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the thread-safe reference counted pointer &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;sync&#x2f;struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the owned string type &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;string&#x2f;struct.String.html&quot;&gt;&lt;code&gt;String&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;macro.format.html&quot;&gt;&lt;code&gt;format!&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; macro&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;linked_list&#x2f;struct.LinkedList.html&quot;&gt;&lt;code&gt;LinkedList&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the growable ring buffer &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;vec_deque&#x2f;struct.VecDeque.html&quot;&gt;&lt;code&gt;VecDeque&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;binary_heap&#x2f;struct.BinaryHeap.html&quot;&gt;&lt;code&gt;BinaryHeap&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; priority queue&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;btree_map&#x2f;struct.BTreeMap.html&quot;&gt;&lt;code&gt;BTreeMap&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;btree_set&#x2f;struct.BTreeSet.html&quot;&gt;&lt;code&gt;BTreeSet&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;These types will become very useful when we want to implement thread lists, scheduling queues, or support for async&#x2f;await.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;adding-a-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-a-test&quot; aria-label=&quot;Anchor link for: adding-a-test&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Adding a Test&lt;&#x2f;h2&gt;
&lt;p&gt;To ensure that we don&#x27;t accidentally break our new allocation code, we should add an integration test for it. We start by creating a new &lt;code&gt;tests&#x2f;heap_allocation.rs&lt;&#x2f;code&gt; file with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;heap_allocation.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(blog_os::test_runner)]
#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::{entry_point, BootInfo};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

entry_point!(main);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    unimplemented!();
}

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    blog_os::test_panic_handler(info)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We reuse the &lt;code&gt;test_runner&lt;&#x2f;code&gt; and &lt;code&gt;test_panic_handler&lt;&#x2f;code&gt; functions from our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;. Since we want to test allocations, we enable the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate through the &lt;code&gt;extern crate alloc&lt;&#x2f;code&gt; statement. For more information about the test boilerplate check out the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;&quot;&gt;&lt;em&gt;Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post.&lt;&#x2f;p&gt;
&lt;p&gt;The implementation of the &lt;code&gt;main&lt;&#x2f;code&gt; function looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;heap_allocation.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::allocator;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::{self, BootInfoFrameAllocator};
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtAddr;

    blog_os::init();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(phys_mem_offset) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map)
    };
    allocator::init_heap(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;heap initialization failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    test_main();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It is very similar to the &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;, with the differences that we don&#x27;t invoke &lt;code&gt;println&lt;&#x2f;code&gt;, don&#x27;t include any example allocations, and call &lt;code&gt;test_main&lt;&#x2f;code&gt; unconditionally.&lt;&#x2f;p&gt;
&lt;p&gt;Now we&#x27;re ready to add a few test cases. First, we add a test that performs a simple allocation using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and checks the allocated value, to ensure that basic allocations work:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;heap_allocation.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{serial_print, serial_println};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;simple_allocation() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;simple_allocation... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_value &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;heap_value, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;41&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most importantly, this test verifies that no allocation error occurs.&lt;&#x2f;p&gt;
&lt;p&gt;Next, we iteratively build a large vector, to test both large allocations and multiple allocations (due to reallocations):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;heap_allocation.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::vec::Vec;

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;large_vec() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;large_vec... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; n &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vec &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Vec::new();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;n {
        vec.push(i);
    }
    assert_eq!(vec.iter().sum::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;(), (n &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; n &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We verify the sum by comparing it with the formula for the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums&quot;&gt;n-th partial sum&lt;&#x2f;a&gt;. This gives us some confidence that the allocated values are all correct.&lt;&#x2f;p&gt;
&lt;p&gt;As a third test, we create ten thousand allocations after each other:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;heap_allocation.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;many_boxes() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;many_boxes... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10_000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(i);
        assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x, i);
    }
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This test ensures that the allocator reuses freed memory for subsequent allocations since it would run out of memory otherwise. This might seem like an obvious requirement for an allocator, but there are allocator designs that don&#x27;t do this. An example is the bump allocator design that will be explained in the next post.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s run our new integration test:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest --test heap_allocation
[â€¦]
Running 3 tests
simple_allocation... [ok]
large_vec... [ok]
many_boxes... [ok]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;All three tests succeeded! You can also invoke &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; (without &lt;code&gt;--test&lt;&#x2f;code&gt; argument) to run all unit and integration tests.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;This post gave an introduction to dynamic memory and explained why and where it is needed. We saw how Rust&#x27;s borrow checker prevents common vulnerabilities and learned how Rust&#x27;s allocation API works.&lt;&#x2f;p&gt;
&lt;p&gt;After creating a minimal implementation of Rust&#x27;s allocator interface using a dummy allocator, we created a proper heap memory region for our kernel. For that we defined a virtual address range for the heap and then mapped all pages of that range to physical frames using the &lt;code&gt;Mapper&lt;&#x2f;code&gt; and &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; from the previous post.&lt;&#x2f;p&gt;
&lt;p&gt;Finally, we added a dependency on the &lt;code&gt;linked_list_allocator&lt;&#x2f;code&gt; crate to add a proper allocator to our kernel. With this allocator, we were able to use &lt;code&gt;Box&lt;&#x2f;code&gt;, &lt;code&gt;Vec&lt;&#x2f;code&gt;, and other allocation and collection types from the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;While we already added heap allocation support in this post, we left most of the work to the &lt;code&gt;linked_list_allocator&lt;&#x2f;code&gt; crate. The next post will show in detail how an allocator can be implemented from scratch. It will present multiple possible allocator designs, shows how to implement simple versions of them, and explain their advantages and drawbacks.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Updates in May 2019</title>
                <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-06-03/</link>
                <guid>https://os.phil-opp.com/status-update/2019-06-03/</guid>
                <description>&lt;p&gt;This post gives an overview of the recent updates to the &lt;em&gt;Writing an OS in Rust&lt;&#x2f;em&gt; blog and to the used tools. I was quite busy with my master thesis this month, so I didn&#x27;t have the time to create new content or major new features. However, there were quite a few minor updates.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;x86-64&quot;&gt;x86_64&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;70&quot;&gt;Use cast crate instead of usize_conversions crate&lt;&#x2f;a&gt; (released as version 0.5.5).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;71&quot;&gt;Make FrameAllocator an unsafe trait&lt;&#x2f;a&gt; (released as version 0.6.0).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;pull&#x2f;76&quot;&gt;Change Port::read and PortReadOnly::read to take &amp;amp;mut self&lt;&#x2f;a&gt; (released as version 0.7.0).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;npmccallum&quot;&gt;@npmccallum&lt;&#x2f;a&gt; started working on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;issues&#x2f;72&quot;&gt;moving the type declarations to a separate crate&lt;&#x2f;a&gt; to make them usable for more projects. We created the experimental &lt;a href=&quot;http:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64_types&#x2f;&quot;&gt;x86_64_types&lt;&#x2f;a&gt; crate for this.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;cargo-xbuild&quot;&gt;Cargo-Xbuild&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;commit&#x2f;bd73f5a1b975f1938abd5b4c17a048d2018741b7&quot;&gt;Make backtraces optional&lt;&#x2f;a&gt; to remove the transitive dependency on the &lt;code&gt;cc&lt;&#x2f;code&gt; crate, which has additional &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;alexcrichton&#x2f;cc-rs#compile-time-requirements&quot;&gt;compile-time requirements&lt;&#x2f;a&gt; (e.g. a working &lt;code&gt;gcc&lt;&#x2f;code&gt; installation). These requirements caused &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;612&quot;&gt;problems for some people&lt;&#x2f;a&gt;, so we decided to disable backtraces by default. Released as version 0.5.9.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;32&quot;&gt;Error when the sysroot path contains spaces&lt;&#x2f;a&gt;: This pull request adds a special error message that points to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;cargo&#x2f;issues&#x2f;6139&quot;&gt;rust-lang&#x2f;cargo#6139&lt;&#x2f;a&gt; when a sysroot path contains spaces. This should avoid the regular confusion, e.g. &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;464#issuecomment-427793367&quot;&gt;here&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;403#issuecomment-483046786&quot;&gt;here&lt;&#x2f;a&gt;, or &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;403#issuecomment-487313363&quot;&gt;here&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;33&quot;&gt;Add a &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2f;code&gt; environment variable to override sysroot path&lt;&#x2f;a&gt;: This feature is useful when the default sysroot path contains a space. Released as version 0.5.10.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&#x2f;pull&#x2f;34&quot;&gt;Fix the new &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2f;code&gt; environment variable&lt;&#x2f;a&gt;. Released as version 0.5.11.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;40&quot;&gt;Update Azure Pipelines CI script&lt;&#x2f;a&gt;
&lt;ul&gt;
&lt;li&gt;Build all branches instead of just &lt;code&gt;master&lt;&#x2f;code&gt; and the &lt;a href=&quot;https:&#x2f;&#x2f;bors.tech&#x2f;&quot;&gt;bors&lt;&#x2f;a&gt; &lt;code&gt;staging&lt;&#x2f;code&gt; branch.&lt;&#x2f;li&gt;
&lt;li&gt;Rustup is now included in the official Windows image of Azure Pipelines, so we don&#x27;t need to install it again.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rybot666&quot;&gt;@rybot666&lt;&#x2f;a&gt; started working on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;issues&#x2f;24&quot;&gt;porting the 16-bit assembly of the bootloader to Rust&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;toothbrush7777777&quot;&gt;@toothbrush7777777&lt;&#x2f;a&gt; landed a pull request to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;39&quot;&gt;pad the boot image to a hard disk block size&lt;&#x2f;a&gt;. This is required for booting the image in VirtualBox. Released as version 0.7.4.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;41&quot;&gt;Set &lt;code&gt;XBUILD_SYSROOT_PATH&lt;&#x2f;code&gt; when building bootloader&lt;&#x2f;a&gt;. Released as version 0.7.5.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;600&quot;&gt;Update to version 0.6.0 of x86_64&lt;&#x2f;a&gt;, which made the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait unsafe to implement.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;604&quot;&gt;Use &lt;code&gt;-serial stdio&lt;&#x2f;code&gt; instead of &lt;code&gt;-serial mon:stdio&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; as QEMU arguments when testing.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;606&quot;&gt;Update x86_64 to version 0.7.0&lt;&#x2f;a&gt;, which changed the &lt;code&gt;Port::read&lt;&#x2f;code&gt; method to take &lt;code&gt;&amp;amp;mut self&lt;&#x2f;code&gt; instead of &lt;code&gt;&amp;amp;self&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;josephlr&quot;&gt;@josephlr&lt;&#x2f;a&gt; &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;609&quot;&gt;replaced some leftover tabs with spaces&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;611&quot;&gt;Rewrite &lt;code&gt;CompareMessage&lt;&#x2f;code&gt; struct to check the whole string&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
</description>
            </item>
        
            <item>
                <title>Updates in April 2019</title>
                <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/status-update/2019-05-01/</link>
                <guid>https://os.phil-opp.com/status-update/2019-05-01/</guid>
                <description>&lt;p&gt;Lot&#x27;s of things changed in the &lt;em&gt;Writing an OS in Rust&lt;&#x2f;em&gt; series in the past month, both on the blog itself and in the tools behind the scenes. This post gives an overview of the most important updates.&lt;&#x2f;p&gt;
&lt;p&gt;This post is an experiment inspired by &lt;a href=&quot;https:&#x2f;&#x2f;this-week-in-rust.org&#x2f;&quot;&gt;&lt;em&gt;This Week in Rust&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and similar series. The goal is to provide a resource that allows following the project more closely and staying up-to-date with the changes in the tools&#x2f;libraries behind the scenes. If enough people find this useful, I will try to turn this in a semi-regular series.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;bootloader&quot;&gt;Bootloader&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;The build system of the bootloader was rewritten to do a proper linking instead of appending the kernel executable manually like before. The relevant pull requests are &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;51&quot;&gt;&lt;em&gt;Rewrite build system&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;53&quot;&gt;&lt;em&gt;Updates for new build system&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. These (breaking) changes were released as version &lt;code&gt;0.5.0&lt;&#x2f;code&gt; (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;blob&#x2f;master&#x2f;Changelog.md#050&quot;&gt;changelog&lt;&#x2f;a&gt;).&lt;&#x2f;li&gt;
&lt;li&gt;To make the bootloader work with future versions of &lt;code&gt;bootimage&lt;&#x2f;code&gt;, a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;commit&#x2f;33b8ce6059e90485c56883b23d4834d06ddfd517&quot;&gt;&lt;code&gt;package.metadata.bootloader.target&lt;&#x2f;code&gt; key was added&lt;&#x2f;a&gt; to the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; of the bootloader. This key specifies the name of the target JSON file, so that &lt;code&gt;bootimage&lt;&#x2f;code&gt; knows which &lt;code&gt;--target&lt;&#x2f;code&gt; argument to pass. This change was released as version &lt;code&gt;0.5.1&lt;&#x2f;code&gt; (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;blob&#x2f;master&#x2f;Changelog.md#051&quot;&gt;changelog&lt;&#x2f;a&gt;)&lt;&#x2f;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;pull&#x2f;55&quot;&gt;&lt;em&gt;Version 0.6.0&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request, the &lt;code&gt;#[cfg(not(test))]&lt;&#x2f;code&gt; attribute was removed from the &lt;code&gt;entry_point&lt;&#x2f;code&gt; macro. This makes it possible to use the macro together with &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; and a custom test framework. Since the change is breaking, it was released as version &lt;code&gt;0.6.0&lt;&#x2f;code&gt; (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&#x2f;blob&#x2f;master&#x2f;Changelog.md#060&quot;&gt;changelog&lt;&#x2f;a&gt;).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootimage&quot;&gt;Bootimage&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;34&quot;&gt;&lt;em&gt;Rewrite bootimage for new bootloader build system&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request completely revamped the implementation of the crate. This was released as version &lt;code&gt;0.7.0&lt;&#x2f;code&gt;. See the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;blob&#x2f;master&#x2f;Changelog.md#070&quot;&gt;changelog&lt;&#x2f;a&gt; for a list of changes.
&lt;ul&gt;
&lt;li&gt;The rewrite had the unintended side-effect that &lt;code&gt;bootimage run&lt;&#x2f;code&gt; no longer ignored executables named &lt;code&gt;test-*&lt;&#x2f;code&gt;, so that an additional &lt;code&gt;--bin&lt;&#x2f;code&gt; argument was required for specifying which executable to run. To avoid breaking users of &lt;code&gt;bootimage test&lt;&#x2f;code&gt;, we yanked version &lt;code&gt;0.7.0&lt;&#x2f;code&gt;. After &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;commit&#x2f;8746c15bf326cf8438a4e64ffdda332fbe59e30d&quot;&gt;fixing the issue&lt;&#x2f;a&gt;, version &lt;code&gt;0.7.1&lt;&#x2f;code&gt; was released (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;blob&#x2f;master&#x2f;Changelog.md#071&quot;&gt;changelog&lt;&#x2f;a&gt;).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;pull&#x2f;36&quot;&gt;&lt;em&gt;New features for &lt;code&gt;bootimage runner&lt;&#x2f;code&gt;&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request added support for additional arguments and various functionality for supporting &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;. The changes were released as version &lt;code&gt;0.7.2&lt;&#x2f;code&gt; (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;blob&#x2f;master&#x2f;Changelog.md#072&quot;&gt;changelog&lt;&#x2f;a&gt;).&lt;&#x2f;li&gt;
&lt;li&gt;An argument parsing bug that broke the new &lt;code&gt;cargo bootimage&lt;&#x2f;code&gt; subcommand on Windows was &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&#x2f;commit&#x2f;101eb43de403fd9f3cb3f044e2c263356d2c179a&quot;&gt;fixed&lt;&#x2f;a&gt;. The fix was released as version &lt;code&gt;0.7.3&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;blog-os&quot;&gt;Blog OS&lt;&#x2f;h2&gt;
&lt;ul&gt;
&lt;li&gt;Performed an &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;575&quot;&gt;&lt;em&gt;Update to new bootloader 0.5.1 and bootimage 0.7.2&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. Apart from requiring the &lt;code&gt;llvm-tools-preview&lt;&#x2f;code&gt; rustup component, this only changes version numbers.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;577&quot;&gt;&lt;em&gt;Rewrite the linking section of &amp;quot;A Freestanding Rust Binary&amp;quot;&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request updated the first post to compile for the bare-metal &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2f;code&gt; target instead of adding linker arguments for Linux&#x2f;Windows&#x2f;macOS.&lt;&#x2f;li&gt;
&lt;li&gt;Since the blog came close to the free bandwidth limit of Netlify, we needed to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;579&quot;&gt;&lt;em&gt;Migrate from Netlify to Github Pages&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; to avoid additional fees.&lt;&#x2f;li&gt;
&lt;li&gt;With the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;582&quot;&gt;&lt;em&gt;Minimal Rust Kernel: Use a runner to make cargo xrun work&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request, we integrated the new &lt;code&gt;bootimage runner&lt;&#x2f;code&gt; into the blog.
&lt;ul&gt;
&lt;li&gt;The required updates to the &lt;code&gt;post-02&lt;&#x2f;code&gt; and &lt;code&gt;post-03&lt;&#x2f;code&gt; branches were performed in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;585&quot;&gt;&lt;em&gt;Add &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; file to post-02 branch&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;586&quot;&gt;&lt;em&gt;Merge the changes from #585 into the post-03 branch&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull requests.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;584&quot;&gt;&lt;em&gt;New testing post&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request, we replaced the previous &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;integration-tests&#x2f;&quot;&gt;&lt;em&gt;Integration Tests&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; with the new &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;&quot;&gt;&lt;em&gt;Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post, which uses &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; and a custom test framework for running tests.
&lt;ul&gt;
&lt;li&gt;The required updates for the &lt;code&gt;post-04&lt;&#x2f;code&gt; branch were performed in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;587&quot;&gt;&lt;em&gt;Implement code for new testing post in post-xx branches&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request. The updates for the other &lt;code&gt;post-*&lt;&#x2f;code&gt; branches were pushed manually to avoid spamming the repository with pull requests. You can find a list of the commits in the pull request description.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;595&quot;&gt;&lt;em&gt;Avoid generic impl trait parameters in BootInfoFrameAllocator&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; pull request made the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt; non-generic by reconstructing the frame iterator on every allocation. This way, we avoid using a &lt;code&gt;impl Trait&lt;&#x2f;code&gt; type parameter, which makes it &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;593&quot;&gt;impossible to store the type in a &lt;code&gt;static&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. See &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;60367&quot;&gt;rust-lang&#x2f;rust#60367&lt;&#x2f;a&gt; for the fundamental problem.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
</description>
            </item>
        
            <item>
                <title>Testing</title>
                <pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/testing/</link>
                <guid>https://os.phil-opp.com/testing/</guid>
                <description>&lt;p&gt;This post explores unit and integration testing in &lt;code&gt;no_std&lt;&#x2f;code&gt; executables. We will use Rust&#x27;s support for custom test frameworks to execute test functions inside our kernel. To report the results out of QEMU, we will use different features of QEMU and the &lt;code&gt;bootimage&lt;&#x2f;code&gt; tool.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Requirements&lt;&#x2f;h2&gt;
&lt;p&gt;This post replaces the (now deprecated) &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;integration-tests&#x2f;&quot;&gt;&lt;em&gt;Integration Tests&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; posts. It assumes that you have followed the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;&quot;&gt;&lt;em&gt;A Minimal Rust Kernel&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post after 2019-04-27. Mainly, it requires that you have a &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; file that &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;#set-a-default-target&quot;&gt;sets a default target&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;#using-cargo-run&quot;&gt;defines a runner executable&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;testing-in-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-in-rust&quot; aria-label=&quot;Anchor link for: testing-in-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing in Rust&lt;&#x2f;h2&gt;
&lt;p&gt;Rust has a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch11-00-testing.html&quot;&gt;built-in test framework&lt;&#x2f;a&gt; that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the &lt;code&gt;#[test]&lt;&#x2f;code&gt; attribute to the function header. Then &lt;code&gt;cargo test&lt;&#x2f;code&gt; will automatically find and execute all test functions of your crate.&lt;&#x2f;p&gt;
&lt;p&gt;Unfortunately it&#x27;s a bit more complicated for &lt;code&gt;no_std&lt;&#x2f;code&gt; applications such as our kernel. The problem is that Rust&#x27;s test framework implicitly uses the built-in &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;test&#x2f;index.html&quot;&gt;&lt;code&gt;test&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; library, which depends on the standard library. This means that we can&#x27;t use the default test framework for our &lt;code&gt;#[no_std]&lt;&#x2f;code&gt; kernel.&lt;&#x2f;p&gt;
&lt;p&gt;We can see this when we try to run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; in our project:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest
   Compiling blog_os v0.1.0 (&#x2f;â€¦&#x2f;blog_os)
error[E0463]: can&amp;#39;t find crate for `test`
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since the &lt;code&gt;test&lt;&#x2f;code&gt; crate depends on the standard library, it is not available for our bare metal target. While porting the &lt;code&gt;test&lt;&#x2f;code&gt; crate to a &lt;code&gt;#[no_std]&lt;&#x2f;code&gt; context &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;japaric&#x2f;utest&quot;&gt;is possible&lt;&#x2f;a&gt;, it is highly unstable and requires some hacks such as redefining the &lt;code&gt;panic&lt;&#x2f;code&gt; macro.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;custom-test-frameworks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#custom-test-frameworks&quot; aria-label=&quot;Anchor link for: custom-test-frameworks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Custom Test Frameworks&lt;&#x2f;h3&gt;
&lt;p&gt;Fortunately, Rust supports replacing the default test framework through the unstable &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;custom-test-frameworks.html&quot;&gt;&lt;code&gt;custom_test_frameworks&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; feature. This feature requires no external libraries and thus also works in &lt;code&gt;#[no_std]&lt;&#x2f;code&gt; environments. It works by collecting all functions annotated with a &lt;code&gt;#[test_case]&lt;&#x2f;code&gt; attribute and then invoking a user-specified runner function with the list of tests as argument. Thus it gives the implementation maximal control over the test process.&lt;&#x2f;p&gt;
&lt;p&gt;The disadvantage compared to the default test framework is that many advanced features such as &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch11-01-writing-tests.html#checking-for-panics-with-should_panic&quot;&gt;&lt;code&gt;should_panic&lt;&#x2f;code&gt; tests&lt;&#x2f;a&gt; are not available. Instead, it is up to the implementation to provide such features itself if needed. This is ideal for us since we have a very special execution environment where the default implementations of such advanced features probably wouldn&#x27;t work anyway. For example, the &lt;code&gt;#[should_panic]&lt;&#x2f;code&gt; attribute relies on stack unwinding to catch the panics, which we disabled for our kernel.&lt;&#x2f;p&gt;
&lt;p&gt;To implement a custom test framework for our kernel, we add the following to our &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]

#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; tests&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, tests.len());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tests {
        test();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our runner just prints a short debug message and then calls each test function in the list. The argument type &lt;code&gt;&amp;amp;[&amp;amp;dyn Fn()]&lt;&#x2f;code&gt; is a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;primitive.slice.html&quot;&gt;&lt;em&gt;slice&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; of &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;trait-objects.html&quot;&gt;&lt;em&gt;trait object&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; references of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;ops&#x2f;trait.Fn.html&quot;&gt;&lt;em&gt;Fn()&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; trait. It is basically a list of references to types that can be called like a function. Since the function is useless for non-test runs, we use the &lt;code&gt;#[cfg(test)]&lt;&#x2f;code&gt; attribute to include it only for tests.&lt;&#x2f;p&gt;
&lt;p&gt;When we run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now, we see that it now succeeds. However, we still see our &amp;quot;Hello World&amp;quot; instead of the message from our &lt;code&gt;test_runner&lt;&#x2f;code&gt;. The reason is that our &lt;code&gt;_start&lt;&#x2f;code&gt; function is still used as entry point. The custom test frameworks feature generates a &lt;code&gt;main&lt;&#x2f;code&gt; function that calls &lt;code&gt;test_runner&lt;&#x2f;code&gt;, but this function is ignored because we use the &lt;code&gt;#[no_main]&lt;&#x2f;code&gt; attribute and provide our own entry point.&lt;&#x2f;p&gt;
&lt;p&gt;To fix this, we first need to change the name of the generated function to something different than &lt;code&gt;main&lt;&#x2f;code&gt; through the &lt;code&gt;reexport_test_harness_main&lt;&#x2f;code&gt; attribute. Then we can call the renamed function from our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    #[cfg(test)]
    test_main();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We set the name of the test framework entry function to &lt;code&gt;test_main&lt;&#x2f;code&gt; and call it from our &lt;code&gt;_start&lt;&#x2f;code&gt; entry point. We use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2f;a&gt; to add the call to &lt;code&gt;test_main&lt;&#x2f;code&gt; only in test contexts because the function is not generated on a normal run.&lt;&#x2f;p&gt;
&lt;p&gt;When we now execute &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;, we see the &amp;quot;Running 0 tests&amp;quot; message from our &lt;code&gt;test_runner&lt;&#x2f;code&gt; on the screen. We are now ready to create our first test function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;trivial_assertion() {
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;trivial assertion... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;qemu-test-runner-output.png&quot; alt=&quot;QEMU printing &amp;quot;Hello World!&amp;quot;, &amp;quot;Running 1 tests&amp;quot;, and &amp;quot;trivial assertion... [ok]&amp;quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;tests&lt;&#x2f;code&gt; slice passed to our &lt;code&gt;test_runner&lt;&#x2f;code&gt; function now contains a reference to the &lt;code&gt;trivial_assertion&lt;&#x2f;code&gt; function. From the &lt;code&gt;trivial assertion... [ok]&lt;&#x2f;code&gt; output on the screen we see that the test was called and that it succeeded.&lt;&#x2f;p&gt;
&lt;p&gt;After executing the tests, our &lt;code&gt;test_runner&lt;&#x2f;code&gt; returns to the &lt;code&gt;test_main&lt;&#x2f;code&gt; function, which in turn returns to our &lt;code&gt;_start&lt;&#x2f;code&gt; entry point function. At the end of &lt;code&gt;_start&lt;&#x2f;code&gt;, we enter an endless loop because the entry point function is not allowed to return. This is a problem, because we want &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; to exit after running all tests.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;exiting-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exiting-qemu&quot; aria-label=&quot;Anchor link for: exiting-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exiting QEMU&lt;&#x2f;h2&gt;
&lt;p&gt;Right now we have an endless loop at the end of our &lt;code&gt;_start&lt;&#x2f;code&gt; function and need to close QEMU manually on each execution of &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;. This is unfortunate because we also want to run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; in scripts without user interaction. The clean solution to this would be to implement a proper way to shutdown our OS. Unfortunately this is relatively complex, because it requires implementing support for either the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;APM&quot;&gt;APM&lt;&#x2f;a&gt; or &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;ACPI&quot;&gt;ACPI&lt;&#x2f;a&gt; power management standard.&lt;&#x2f;p&gt;
&lt;p&gt;Luckily, there is an escape hatch: QEMU supports a special &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device, which provides an easy way to exit QEMU from the guest system. To enable it, we need to pass a &lt;code&gt;-device&lt;&#x2f;code&gt; argument to QEMU. We can do so by adding a &lt;code&gt;package.metadata.bootimage.test-args&lt;&#x2f;code&gt; configuration key in our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;bootimage runner&lt;&#x2f;code&gt; appends the &lt;code&gt;test-args&lt;&#x2f;code&gt; to the default QEMU command for all test executables. For a normal &lt;code&gt;cargo xrun&lt;&#x2f;code&gt;, the arguments are ignored.&lt;&#x2f;p&gt;
&lt;p&gt;Together with the device name (&lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt;), we pass the two parameters &lt;code&gt;iobase&lt;&#x2f;code&gt; and &lt;code&gt;iosize&lt;&#x2f;code&gt; that specify the &lt;em&gt;I&#x2f;O port&lt;&#x2f;em&gt; through which the device can be reached from our kernel.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;i-o-ports&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#i-o-ports&quot; aria-label=&quot;Anchor link for: i-o-ports&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
I&#x2f;O Ports&lt;&#x2f;h3&gt;
&lt;p&gt;There are two different approaches for communicating between the CPU and peripheral hardware on x86, &lt;strong&gt;memory-mapped I&#x2f;O&lt;&#x2f;strong&gt; and &lt;strong&gt;port-mapped I&#x2f;O&lt;&#x2f;strong&gt;. We already used memory-mapped I&#x2f;O for accessing the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;&quot;&gt;VGA text buffer&lt;&#x2f;a&gt; through the memory address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. This address is not mapped to RAM, but to some memory on the VGA device.&lt;&#x2f;p&gt;
&lt;p&gt;In contrast, port-mapped I&#x2f;O uses a separate I&#x2f;O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I&#x2f;O port there are special CPU instructions called &lt;code&gt;in&lt;&#x2f;code&gt; and &lt;code&gt;out&lt;&#x2f;code&gt;, which take a port number and a data byte (there are also variations of these commands that allow sending an &lt;code&gt;u16&lt;&#x2f;code&gt; or &lt;code&gt;u32&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; devices uses port-mapped I&#x2f;O. The &lt;code&gt;iobase&lt;&#x2f;code&gt; parameter specifies on which port address the device should live (&lt;code&gt;0xf4&lt;&#x2f;code&gt; is a &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;I&#x2f;O_Ports#The_list&quot;&gt;generally unused&lt;&#x2f;a&gt; port on the x86&#x27;s IO bus) and the &lt;code&gt;iosize&lt;&#x2f;code&gt; specifies the port size (&lt;code&gt;0x04&lt;&#x2f;code&gt; means four bytes).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;using-the-exit-device&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-exit-device&quot; aria-label=&quot;Anchor link for: using-the-exit-device&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using the Exit Device&lt;&#x2f;h3&gt;
&lt;p&gt;The functionality of the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device is very simple. When a &lt;code&gt;value&lt;&#x2f;code&gt; is written to the I&#x2f;O port specified by &lt;code&gt;iobase&lt;&#x2f;code&gt;, it causes QEMU to exit with &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Exit_status&quot;&gt;exit status&lt;&#x2f;a&gt; &lt;code&gt;(value &amp;lt;&amp;lt; 1) | 1&lt;&#x2f;code&gt;. So when we write &lt;code&gt;0&lt;&#x2f;code&gt; to the port QEMU will exit with exit status &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2f;code&gt; and when we write &lt;code&gt;1&lt;&#x2f;code&gt; to the port it will exit with exit status &lt;code&gt;(1 &amp;lt;&amp;lt; 1) | 1 = 3&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Instead of manually invoking the &lt;code&gt;in&lt;&#x2f;code&gt; and &lt;code&gt;out&lt;&#x2f;code&gt; assembly instructions, we use the abstractions provided by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;&quot;&gt;&lt;code&gt;x86_64&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate. To add a dependency on that crate, we add it to the &lt;code&gt;dependencies&lt;&#x2f;code&gt; section in our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.7.5&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;port&#x2f;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type provided by the crate to create an &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;QemuExitCode {
    Success &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x10&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Failed &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu(exit_code: QemuExitCode) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        port.write(exit_code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The function creates a new &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;port&#x2f;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; at &lt;code&gt;0xf4&lt;&#x2f;code&gt;, which is the &lt;code&gt;iobase&lt;&#x2f;code&gt; of the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device. Then it writes the the passed exit code to the port. We use &lt;code&gt;u32&lt;&#x2f;code&gt; because we specified the &lt;code&gt;iosize&lt;&#x2f;code&gt; of the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device as 4 bytes. Both operations are unsafe, because writing to an I&#x2f;O port can generally result in arbitrary behavior.&lt;&#x2f;p&gt;
&lt;p&gt;For specifying the exit status, we create a &lt;code&gt;QemuExitCode&lt;&#x2f;code&gt; enum. The idea is to exit with the success exit code if all tests succeeded and with the failure exit code otherwise. The enum is marked as &lt;code&gt;#[repr(u32)]&lt;&#x2f;code&gt; to represent each variant by an &lt;code&gt;u32&lt;&#x2f;code&gt; integer. We use exit code &lt;code&gt;0x10&lt;&#x2f;code&gt; for success and &lt;code&gt;0x11&lt;&#x2f;code&gt; for failure. The actual exit codes do not matter much, as long as they don&#x27;t clash with the default exit codes of QEMU. For example, using exit code &lt;code&gt;0&lt;&#x2f;code&gt; for success is not a good idea because it becomes &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2f;code&gt; after the transformation, which is the default exit code when QEMU failed to run. So we could not differentiate a QEMU error from a successful test run.&lt;&#x2f;p&gt;
&lt;p&gt;We can now update our &lt;code&gt;test_runner&lt;&#x2f;code&gt; to exit QEMU after all tests ran:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; tests&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, tests.len());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tests {
        test();
    }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu(QemuExitCode::Success);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now, we see that QEMU immediately closes after executing the tests. The problem is that &lt;code&gt;cargo test&lt;&#x2f;code&gt; interprets the test as failed even though we passed our &lt;code&gt;Success&lt;&#x2f;code&gt; exit code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
     Running target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;deps&#x2f;blog_os-5804fc7d2dd4c9be
Building bootloader
   Compiling bootloader v0.5.3 (&#x2f;home&#x2f;philipp&#x2f;Documents&#x2f;bootloader)
    Finished release [optimized + debuginfo] target(s) in 1.07s
Running: `qemu-system-x86_64 -drive format=raw,file=&#x2f;â€¦&#x2f;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;
    deps&#x2f;bootimage-blog_os-5804fc7d2dd4c9be.bin -device isa-debug-exit,iobase=0xf4,
    iosize=0x04`
error: test failed, to rerun pass &amp;#39;--bin blog_os&amp;#39;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that &lt;code&gt;cargo test&lt;&#x2f;code&gt; considers all error codes other than &lt;code&gt;0&lt;&#x2f;code&gt; as failure.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;success-exit-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#success-exit-code&quot; aria-label=&quot;Anchor link for: success-exit-code&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Success Exit Code&lt;&#x2f;h3&gt;
&lt;p&gt;To work around this, &lt;code&gt;bootimage&lt;&#x2f;code&gt; provides a &lt;code&gt;test-success-exit-code&lt;&#x2f;code&gt; configuration key that maps a specified exit code to the exit code &lt;code&gt;0&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;â€¦&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-success-exit-code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;33         &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# (0x10 &amp;lt;&amp;lt; 1) | 1
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;With this configuration, &lt;code&gt;bootimage&lt;&#x2f;code&gt; maps our success exit code to exit code 0, so that &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; correctly recognizes the success case and does no count the test as failed.&lt;&#x2f;p&gt;
&lt;p&gt;Our test runner now automatically closes QEMU and correctly reports the test results out. We still see the QEMU window open for a very short time, but it does not suffice to read the results. It would be nice if we could print the test results to the console instead, so that we can still see them after QEMU exited.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;printing-to-the-console&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-to-the-console&quot; aria-label=&quot;Anchor link for: printing-to-the-console&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing to the Console&lt;&#x2f;h2&gt;
&lt;p&gt;To see the test output on the console, we need to send the data from our kernel to the host system somehow. There are various ways to achieve this, for example by sending the data over a TCP network interface. However, setting up a networking stack is a quite complex task, so we will choose a simpler solution instead.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;serial-port&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#serial-port&quot; aria-label=&quot;Anchor link for: serial-port&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Serial Port&lt;&#x2f;h3&gt;
&lt;p&gt;A simple way to send the data is to use the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Serial_port&quot;&gt;serial port&lt;&#x2f;a&gt;, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host&#x27;s standard output or a file.&lt;&#x2f;p&gt;
&lt;p&gt;The chips implementing a serial interface are called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Universal_asynchronous_receiver-transmitter&quot;&gt;UARTs&lt;&#x2f;a&gt;. There are &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Universal_asynchronous_receiver-transmitter#UART_models&quot;&gt;lots of UART models&lt;&#x2f;a&gt; on x86, but fortunately the only differences between them are some advanced features we don&#x27;t need. The common UARTs today are all compatible to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;16550_UART&quot;&gt;16550 UART&lt;&#x2f;a&gt;, so we will use that model for our testing framework.&lt;&#x2f;p&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;uart_16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; and &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;uart_16550 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2f;code&gt; crate contains a &lt;code&gt;SerialPort&lt;&#x2f;code&gt; struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that we create a new &lt;code&gt;serial&lt;&#x2f;code&gt; module with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;serial.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;uart_16550::SerialPort;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;SerialPort&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; serial_port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ SerialPort::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x3F8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };
        serial_port.init();
        Mutex::new(serial_port)
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like with the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#lazy-statics&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;, we use &lt;code&gt;lazy_static&lt;&#x2f;code&gt; and a spinlock to create a &lt;code&gt;static&lt;&#x2f;code&gt; writer instance. By using &lt;code&gt;lazy_static&lt;&#x2f;code&gt; we can ensure that the &lt;code&gt;init&lt;&#x2f;code&gt; method is called exactly once on its first use.&lt;&#x2f;p&gt;
&lt;p&gt;Like the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device, the UART is programmed using port I&#x2f;O. Since the UART is more complex, it uses multiple I&#x2f;O ports for programming different device registers. The unsafe &lt;code&gt;SerialPort::new&lt;&#x2f;code&gt; function expects the address of the first I&#x2f;O port of the UART as argument, from which it can calculate the addresses of all needed ports. We&#x27;re passing the port address &lt;code&gt;0x3F8&lt;&#x2f;code&gt;, which is the standard port number for the first serial interface.&lt;&#x2f;p&gt;
&lt;p&gt;To make the serial port easily usable, we add &lt;code&gt;serial_print!&lt;&#x2f;code&gt; and &lt;code&gt;serial_println!&lt;&#x2f;code&gt; macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: ::core::fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Prints to the host through the serial interface.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        $crate::serial::_print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Prints to the host through the serial interface, appending a newline.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_println {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
        concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The implementation is very similar to the implementation of our &lt;code&gt;print&lt;&#x2f;code&gt; and &lt;code&gt;println&lt;&#x2f;code&gt; macros. Since the &lt;code&gt;SerialPort&lt;&#x2f;code&gt; type already implements the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Write.html&quot;&gt;&lt;code&gt;fmt::Write&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait, we don&#x27;t need to provide our own implementation.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can print to the serial interface instead of the VGA text buffer in our test code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, tests.len());
    [â€¦]
}

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;trivial_assertion() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;trivial assertion... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;serial_println&lt;&#x2f;code&gt; macro lives directly under the root namespace because we used the &lt;code&gt;#[macro_export]&lt;&#x2f;code&gt; attribute, so importing it through &lt;code&gt;use crate::serial::serial_println&lt;&#x2f;code&gt; will not work.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;qemu-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qemu-arguments&quot; aria-label=&quot;Anchor link for: qemu-arguments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
QEMU Arguments&lt;&#x2f;h3&gt;
&lt;p&gt;To see the serial output from QEMU, we need use the &lt;code&gt;-serial&lt;&#x2f;code&gt; argument to redirect the output to stdout:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-serial&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stdio&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now, we see the test output directly in the console:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;deps&#x2f;blog_os-7b7c37b4ad62551a
Building bootloader
    Finished release [optimized + debuginfo] target(s) in 0.02s
Running: `qemu-system-x86_64 -drive format=raw,file=&#x2f;â€¦&#x2f;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;
    deps&#x2f;bootimage-blog_os-7b7c37b4ad62551a.bin -device
    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
Running 1 tests
trivial assertion... [ok]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, when a test fails we still see the output inside QEMU because our panic handler still uses &lt;code&gt;println&lt;&#x2f;code&gt;. To simulate this, we can change the assertion in our &lt;code&gt;trivial_assertion&lt;&#x2f;code&gt; test to &lt;code&gt;assert_eq!(0, 1)&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;qemu-failed-test.png&quot; alt=&quot;QEMU printing &amp;quot;Hello World!&amp;quot; and &amp;quot;panicked at &#x27;assertion failed: (left == right) left: 0, right: 1&#x27;, src&#x2f;main.rs:55:5&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that the panic message is still printed to the VGA buffer, while the other test output is printed to the serial port. The panic message is quite useful, so it would be useful to see it in the console too.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;print-an-error-message-on-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#print-an-error-message-on-panic&quot; aria-label=&quot;Anchor link for: print-an-error-message-on-panic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Print an Error Message on Panic&lt;&#x2f;h3&gt;
&lt;p&gt;To exit QEMU with an error message on a panic, we can use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;conditional-compilation.html&quot;&gt;conditional compilation&lt;&#x2f;a&gt; to use a different panic handler in testing mode:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; our existing panic handler
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new attribute
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; our panic handler in test mode
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    exit_qemu(QemuExitCode::Failed);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For our test panic handler, we use &lt;code&gt;serial_println&lt;&#x2f;code&gt; instead of &lt;code&gt;println&lt;&#x2f;code&gt; and then exit QEMU with a failure exit code. Note that we still need an endless &lt;code&gt;loop&lt;&#x2f;code&gt; after the &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; call because the compiler does not know that the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device causes a program exit.&lt;&#x2f;p&gt;
&lt;p&gt;Now QEMU also exits for failed tests and prints a useful error message on the console:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest
    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;deps&#x2f;blog_os-7b7c37b4ad62551a
Building bootloader
    Finished release [optimized + debuginfo] target(s) in 0.02s
Running: `qemu-system-x86_64 -drive format=raw,file=&#x2f;â€¦&#x2f;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;
    deps&#x2f;bootimage-blog_os-7b7c37b4ad62551a.bin -device
    isa-debug-exit,iobase=0xf4,iosize=0x04 -serial stdio`
Running 1 tests
trivial assertion... [failed]

Error: panicked at &amp;#39;assertion failed: `(left == right)`
  left: `0`,
 right: `1`&amp;#39;, src&#x2f;main.rs:65:5
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since we see all test output on the console now, we no longer need the QEMU window that pops up for a short time. So we can hide it completely.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;hiding-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-qemu&quot; aria-label=&quot;Anchor link for: hiding-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hiding QEMU&lt;&#x2f;h3&gt;
&lt;p&gt;Since we report out the complete test results using the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device and the serial port, we don&#x27;t need the QEMU window anymore. We can hide it by passing the &lt;code&gt;-display none&lt;&#x2f;code&gt; argument to QEMU:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-args &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-device&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;isa-debug-exit,iobase=0xf4,iosize=0x04&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-serial&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stdio&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-display&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now QEMU runs completely in the background and no window is opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as CI services or &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Secure_Shell&quot;&gt;SSH&lt;&#x2f;a&gt; connections.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;timeouts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#timeouts&quot; aria-label=&quot;Anchor link for: timeouts&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Timeouts&lt;&#x2f;h3&gt;
&lt;p&gt;Since &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; waits until the test runner exits, a test that never returns can block the test runner forever. That&#x27;s unfortunate, but not a big problem in practice since it&#x27;s normally easy to avoid endless loops. In our case, however, endless loops can occur in various situations:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The bootloader fails to load our kernel, which causes the system to reboot endlessly.&lt;&#x2f;li&gt;
&lt;li&gt;The BIOS&#x2f;UEFI firmware fails to load the bootloader, which causes the same endless rebooting.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU enters a &lt;code&gt;loop {}&lt;&#x2f;code&gt; statement at the end of some of our functions, for example because the QEMU exit device doesn&#x27;t work properly.&lt;&#x2f;li&gt;
&lt;li&gt;The hardware causes a system reset, for example when a CPU exception is not caught (explained in a future post).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Since endless loops can occur in so many situations, the &lt;code&gt;bootimage&lt;&#x2f;code&gt; tool sets a timeout of 5 minutes for each test executable by default. If the test does not finish in this time, it is marked as failed and a &amp;quot;Timed Out&amp;quot; error is printed to the console. This feature ensures that tests that are stuck in an endless loop don&#x27;t block &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; forever.&lt;&#x2f;p&gt;
&lt;p&gt;You can try it yourself by adding a &lt;code&gt;loop {}&lt;&#x2f;code&gt; statement in the &lt;code&gt;trivial_assertion&lt;&#x2f;code&gt; test. When you run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;, you see that the test is marked as timed out after 5 minutes. The timeout duration is &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage#configuration&quot;&gt;configurable&lt;&#x2f;a&gt; through a &lt;code&gt;test-timeout&lt;&#x2f;code&gt; key in the Cargo.toml:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package.metadata.bootimage&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test-timeout &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;300          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# (in seconds)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If you don&#x27;t want to wait 5 minutes for the &lt;code&gt;trivial_assertion&lt;&#x2f;code&gt; test to time out, you can temporarily decrease the above value.&lt;&#x2f;p&gt;
&lt;p&gt;After this, we no longer need the &lt;code&gt;trivial_assertion&lt;&#x2f;code&gt; test, so we can delete it.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;testing-the-vga-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-the-vga-buffer&quot; aria-label=&quot;Anchor link for: testing-the-vga-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing the VGA Buffer&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we have a working test framework, we can create a few tests for our VGA buffer implementation. First, we create a very simple test to verify that &lt;code&gt;println&lt;&#x2f;code&gt; works without panicking:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::{serial_print, serial_println};

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println_simple() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_simple output&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The test just prints something to the VGA buffer. If it finishes without panicking, it means that the &lt;code&gt;println&lt;&#x2f;code&gt; invocation did not panic either. Since we only need the &lt;code&gt;serial_println&lt;&#x2f;code&gt; import in test mode, we add the &lt;code&gt;cfg(test)&lt;&#x2f;code&gt; attribute to avoid the unused import warning for a normal &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To ensure that no panic occurs even if many lines are printed and lines are shifted off the screen, we can create another test:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println_many() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_many... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for _ in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;200 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_many output&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can also create a test function to verify that the printed lines really appear on the screen:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println_output() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_output... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, s);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, c) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.chars().enumerate() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().buffer.chars[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;][i].read();
        assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(screen_char.ascii_character), c);
    }

    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The function defines a test string, prints it using &lt;code&gt;println&lt;&#x2f;code&gt;, and then iterates over the screen characters of the static &lt;code&gt;WRITER&lt;&#x2f;code&gt;, which represents the vga text buffer. Since &lt;code&gt;println&lt;&#x2f;code&gt; prints to the last screen line and then immediately appends a newline, the string should appear on line &lt;code&gt;BUFFER_HEIGHT - 2&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;By using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, we count the number of iterations in the variable &lt;code&gt;i&lt;&#x2f;code&gt;, which we then use for loading the screen character corresponding to &lt;code&gt;c&lt;&#x2f;code&gt;. By comparing the &lt;code&gt;ascii_character&lt;&#x2f;code&gt; of the screen character with &lt;code&gt;c&lt;&#x2f;code&gt;, we ensure that each character of the string really appears in the vga text buffer.&lt;&#x2f;p&gt;
&lt;p&gt;As you can imagine, we could create many more test functions, for example a function that tests that no panic occurs when printing very long lines and that they&#x27;re wrapped correctly. Or a function for testing that newlines, non-printable characters, and non-unicode characters are handled correctly.&lt;&#x2f;p&gt;
&lt;p&gt;For the rest of this post, however, we will explain how to create &lt;em&gt;integration tests&lt;&#x2f;em&gt; to test the interaction of different components together.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;integration-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#integration-tests&quot; aria-label=&quot;Anchor link for: integration-tests&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Integration Tests&lt;&#x2f;h2&gt;
&lt;p&gt;The convention for &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch11-03-test-organization.html#integration-tests&quot;&gt;integration tests&lt;&#x2f;a&gt; in Rust is to put them into a &lt;code&gt;tests&lt;&#x2f;code&gt; directory in the project root (i.e. next to the &lt;code&gt;src&lt;&#x2f;code&gt; directory). Both the default test framework and custom test frameworks will automatically pick up and execute all tests in that directory.&lt;&#x2f;p&gt;
&lt;p&gt;All integration tests are their own executables and completely separate from our &lt;code&gt;main.rs&lt;&#x2f;code&gt;. This means that each test needs to define its own entry point function. Let&#x27;s create an example integration test named &lt;code&gt;basic_boot&lt;&#x2f;code&gt; to see how it works in detail:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;basic_boot.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]
#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    test_main();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    unimplemented!();
}

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since integration tests are separate executables, we need to provide all the crate attributes (&lt;code&gt;no_std&lt;&#x2f;code&gt;, &lt;code&gt;no_main&lt;&#x2f;code&gt;, &lt;code&gt;test_runner&lt;&#x2f;code&gt;, etc.) again. We also need to create a new entry point function &lt;code&gt;_start&lt;&#x2f;code&gt;, which calls the test entry point function &lt;code&gt;test_main&lt;&#x2f;code&gt;. We don&#x27;t need any &lt;code&gt;cfg(test)&lt;&#x2f;code&gt; attributes because integration test executables are never built in non-test mode.&lt;&#x2f;p&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;macro.unimplemented.html&quot;&gt;&lt;code&gt;unimplemented&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; macro that always panics as a placeholder for the &lt;code&gt;test_runner&lt;&#x2f;code&gt; function and just &lt;code&gt;loop&lt;&#x2f;code&gt; in the &lt;code&gt;panic&lt;&#x2f;code&gt; handler for now. Ideally, we want to implement these functions exactly as we did in our &lt;code&gt;main.rs&lt;&#x2f;code&gt; using the &lt;code&gt;serial_println&lt;&#x2f;code&gt; macro and the &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; function. The problem is that we don&#x27;t have access to these functions since tests are built completely separately of our &lt;code&gt;main.rs&lt;&#x2f;code&gt; executable.&lt;&#x2f;p&gt;
&lt;p&gt;If you run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; at this stage, you will get an endless loop because the panic handler loops endlessly. You need to use the &lt;code&gt;Ctrl+c&lt;&#x2f;code&gt; keyboard shortcut for exiting QEMU.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;create-a-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#create-a-library&quot; aria-label=&quot;Anchor link for: create-a-library&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Create a Library&lt;&#x2f;h3&gt;
&lt;p&gt;To make the required functions available to our integration test, we need to split off a library from our &lt;code&gt;main.rs&lt;&#x2f;code&gt;, which can be included by other crates and integration test executables. To do this, we create a new &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt; file:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like the &lt;code&gt;main.rs&lt;&#x2f;code&gt;, the &lt;code&gt;lib.rs&lt;&#x2f;code&gt; is a special file that is automatically recognized by cargo. The library is a separate compilation unit, so we need to specify the &lt;code&gt;#![no_std]&lt;&#x2f;code&gt; attribute again.&lt;&#x2f;p&gt;
&lt;p&gt;To make our library work with &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;, we need to also add the test functions and attributes:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(test, no_main)]
#![feature(custom_test_frameworks)]
#![test_runner(crate::test_runner)]
#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, tests.len());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tests {
        test();
    }
    exit_qemu(QemuExitCode::Success);
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_panic_handler(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    exit_qemu(QemuExitCode::Failed);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Entry point for `cargo xtest`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    test_main();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(test)]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    test_panic_handler(info)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To make our &lt;code&gt;test_runner&lt;&#x2f;code&gt; available to executables and integration tests, we don&#x27;t apply the &lt;code&gt;cfg(test)&lt;&#x2f;code&gt; attribute to it and make it public. We also factor out the implementation of our panic handler into a public &lt;code&gt;test_panic_handler&lt;&#x2f;code&gt; function, so that it is available for executables too.&lt;&#x2f;p&gt;
&lt;p&gt;Since our &lt;code&gt;lib.rs&lt;&#x2f;code&gt; is tested independently of our &lt;code&gt;main.rs&lt;&#x2f;code&gt;, we need to add a &lt;code&gt;_start&lt;&#x2f;code&gt; entry point and a panic handler when the library is compiled in test mode. By using the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;conditional-compilation.html#the-cfg_attr-attribute&quot;&gt;&lt;code&gt;cfg_attr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate attribute, we conditionally enable the &lt;code&gt;no_main&lt;&#x2f;code&gt; attribute in this case.&lt;&#x2f;p&gt;
&lt;p&gt;We also move over the &lt;code&gt;QemuExitCode&lt;&#x2f;code&gt; enum and the &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; function and make them public:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;QemuExitCode {
    Success &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x10&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Failed &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu(exit_code: QemuExitCode) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        port.write(exit_code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now executables and integration tests can import these functions from the library and don&#x27;t need to define their own implementations. To also make &lt;code&gt;println&lt;&#x2f;code&gt; and &lt;code&gt;serial_println&lt;&#x2f;code&gt; available, we move the module declarations too:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We make the modules public to make them usable from outside of our library. This is also required for making our &lt;code&gt;println&lt;&#x2f;code&gt; and &lt;code&gt;serial_println&lt;&#x2f;code&gt; macros usable, since they use the &lt;code&gt;_print&lt;&#x2f;code&gt; functions of the modules.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can update our &lt;code&gt;main.rs&lt;&#x2f;code&gt; to use the library:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(blog_os::test_runner)]
#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::println;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    #[cfg(test)]
    test_main();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(test)]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    blog_os::test_panic_handler(info)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The library is usable like a normal external crate. It is called like our crate, which is &lt;code&gt;blog_os&lt;&#x2f;code&gt; in our case. The above code uses the &lt;code&gt;blog_os::test_runner&lt;&#x2f;code&gt; function in the &lt;code&gt;test_runner&lt;&#x2f;code&gt; attribute and the &lt;code&gt;blog_os::test_panic_handler&lt;&#x2f;code&gt; function in our &lt;code&gt;cfg(test)&lt;&#x2f;code&gt; panic handler. It also imports the &lt;code&gt;println&lt;&#x2f;code&gt; macro to make it available to our &lt;code&gt;_start&lt;&#x2f;code&gt; and &lt;code&gt;panic&lt;&#x2f;code&gt; functions.&lt;&#x2f;p&gt;
&lt;p&gt;At this point, &lt;code&gt;cargo xrun&lt;&#x2f;code&gt; and &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; should work again. Of course, &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; still loops endlessly (you can exit with &lt;code&gt;ctrl+c&lt;&#x2f;code&gt;). Let&#x27;s fix this by using the required library functions in our integration test.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;completing-the-integration-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#completing-the-integration-test&quot; aria-label=&quot;Anchor link for: completing-the-integration-test&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Completing the Integration Test&lt;&#x2f;h3&gt;
&lt;p&gt;Like our &lt;code&gt;src&#x2f;main.rs&lt;&#x2f;code&gt;, our &lt;code&gt;tests&#x2f;basic_boot.rs&lt;&#x2f;code&gt; executable can import types from our new library. This allows us to import the missing components to complete our test.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;basic_boot.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![test_runner(blog_os::test_runner)]

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    blog_os::test_panic_handler(info)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of reimplementing the test runner, we use the &lt;code&gt;test_runner&lt;&#x2f;code&gt; function from our library. For our &lt;code&gt;panic&lt;&#x2f;code&gt; handler, we call the &lt;code&gt;blog_os::test_panic_handler&lt;&#x2f;code&gt; function like we did in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; exits normally again. When you run it, you see that it builds and runs the tests for our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, &lt;code&gt;main.rs&lt;&#x2f;code&gt;, and &lt;code&gt;basic_boot.rs&lt;&#x2f;code&gt; separately after each other. For the &lt;code&gt;main.rs&lt;&#x2f;code&gt; and the &lt;code&gt;basic_boot&lt;&#x2f;code&gt; integration test, it reports &amp;quot;Running 0 tests&amp;quot; since these files don&#x27;t have any functions annotated with &lt;code&gt;#[test_case]&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We can now add tests to our &lt;code&gt;basic_boot.rs&lt;&#x2f;code&gt;. For example, we can test that &lt;code&gt;println&lt;&#x2f;code&gt; works without panicking, like we did in the vga buffer tests:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;basic_boot.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{println, serial_print, serial_println};

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println output&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now, we see that it finds and executes the test function.&lt;&#x2f;p&gt;
&lt;p&gt;The test might seem a bit useless right now since it&#x27;s almost identical to one of the VGA buffer tests. However, in the future the &lt;code&gt;_start&lt;&#x2f;code&gt; functions of our &lt;code&gt;main.rs&lt;&#x2f;code&gt; and &lt;code&gt;lib.rs&lt;&#x2f;code&gt; might grow and call various initialization routines before running the &lt;code&gt;test_main&lt;&#x2f;code&gt; function, so that the two tests are executed in very different environments.&lt;&#x2f;p&gt;
&lt;p&gt;By testing &lt;code&gt;println&lt;&#x2f;code&gt; in a &lt;code&gt;basic_boot&lt;&#x2f;code&gt; environment without calling any initialization routines in &lt;code&gt;_start&lt;&#x2f;code&gt;, we can ensure that &lt;code&gt;println&lt;&#x2f;code&gt; works right after booting. This is important because we rely on it e.g. for printing panic messages.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;future-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#future-tests&quot; aria-label=&quot;Anchor link for: future-tests&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Future Tests&lt;&#x2f;h3&gt;
&lt;p&gt;The power of integration tests is that they&#x27;re treated as completely separate executables. This gives them complete control over the environment, which makes it possible to test that the code interacts correctly with the CPU or hardware devices.&lt;&#x2f;p&gt;
&lt;p&gt;Our &lt;code&gt;basic_boot&lt;&#x2f;code&gt; test is a very simple example for an integration test. In the future, our kernel will become much more featureful and interact with the hardware in various ways. By adding integration tests, we can ensure that these interactions work (and keep working) as expected. Some ideas for possible future tests are:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU Exceptions&lt;&#x2f;strong&gt;: When the code performs invalid operations (e.g. divides by zero), the CPU throws an exception. The kernel can register handler functions for such exceptions. An integration test could verify that the correct exception handler is called when a CPU exception occurs or that the execution continues correctly after resolvable exceptions.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Page Tables&lt;&#x2f;strong&gt;: Page tables define which memory regions are valid and accessible. By modifying the page tables, it is possible to allocate new memory regions, for example when launching programs. An integration test could perform some modifications of the page tables in the &lt;code&gt;_start&lt;&#x2f;code&gt; function and then verify that the modifications have the desired effects in &lt;code&gt;#[test_case]&lt;&#x2f;code&gt; functions.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Userspace Programs&lt;&#x2f;strong&gt;: Userspace programs are programs with limited access to the system&#x27;s resources. For example, they don&#x27;t have access to kernel data structures or to the memory of other programs. An integration test could launch userspace programs that perform forbidden operations and verify that the kernel prevents them all.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;As you can imagine, many more tests are possible. By adding such tests, we can ensure that we don&#x27;t break them accidentally when we add new features to our kernel or refactor our code. This is especially important when our kernel becomes larger and more complex.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;tests-that-should-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tests-that-should-panic&quot; aria-label=&quot;Anchor link for: tests-that-should-panic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Tests that Should Panic&lt;&#x2f;h3&gt;
&lt;p&gt;The test framework of the standard library supports a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;testing&#x2f;unit_testing.html#testing-panics&quot;&gt;&lt;code&gt;#[should_panic]&lt;&#x2f;code&gt; attribute&lt;&#x2f;a&gt; that allows to construct tests that should fail. This is useful for example to verify that a function fails when an invalid argument is passed. Unfortunately this attribute isn&#x27;t supported in &lt;code&gt;#[no_std]&lt;&#x2f;code&gt; crates since it requires support from the standard library.&lt;&#x2f;p&gt;
&lt;p&gt;While we can&#x27;t use the &lt;code&gt;#[should_panic]&lt;&#x2f;code&gt; attribute in our kernel, we can get similar behavior by creating an integration test that exits with a success error code from the panic handler. Let&#x27;s start creating such a test with the name &lt;code&gt;should_panic&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;should_panic.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{QemuExitCode, exit_qemu, serial_println};

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    exit_qemu(QemuExitCode::Success);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This test is still incomplete as it doesn&#x27;t define a &lt;code&gt;_start&lt;&#x2f;code&gt; function or any of the custom test runner attributes yet. Let&#x27;s add the missing parts:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;should_panic.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(custom_test_frameworks)]
#![test_runner(test_runner)]
#![reexport_test_harness_main &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_main&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    test_main();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_runner(tests: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dyn Fn()]) {
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Running {} tests&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, tests.len());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tests {
        test();
        serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[test did not panic]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        exit_qemu(QemuExitCode::Failed);
    }
    exit_qemu(QemuExitCode::Success);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of reusing the &lt;code&gt;test_runner&lt;&#x2f;code&gt; from our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, the test defines its own &lt;code&gt;test_runner&lt;&#x2f;code&gt; function that exits with a failure exit code when a test returns without panicking (we want our tests to panic). If no test function is defined, the runner exits with a success error code. Since the runner always exits after running a single test, it does not make sense to define more than one &lt;code&gt;#[test_case]&lt;&#x2f;code&gt; function.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can create a test that should fail:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;should_panic.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::serial_print;

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;should_fail() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_fail... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The test uses the &lt;code&gt;assert_eq&lt;&#x2f;code&gt; to assert that &lt;code&gt;0&lt;&#x2f;code&gt; and &lt;code&gt;1&lt;&#x2f;code&gt; are equal. This of course fails, so that our test panics as desired.&lt;&#x2f;p&gt;
&lt;p&gt;When we run the test through &lt;code&gt;cargo xtest --test should_panic&lt;&#x2f;code&gt; we see that it is successful because the test panicked as expected. When we comment out the assertion and run the test again, we see that it indeed fails with the &lt;em&gt;&amp;quot;test did not panic&amp;quot;&lt;&#x2f;em&gt; message.&lt;&#x2f;p&gt;
&lt;p&gt;A significant drawback of this approach is that it only works for a single test function. With multiple &lt;code&gt;#[test_case]&lt;&#x2f;code&gt; functions, only the first function is executed because the execution cannot continue after the panic handler has been called. I currently don&#x27;t know of a good way to solve this problem, so let me know if you have an idea!&lt;&#x2f;p&gt;
&lt;h3 id=&quot;no-harness-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#no-harness-tests&quot; aria-label=&quot;Anchor link for: no-harness-tests&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
No Harness Tests&lt;&#x2f;h3&gt;
&lt;p&gt;For integration tests that only have a single test function (like our &lt;code&gt;should_panic&lt;&#x2f;code&gt; test), the test runner isn&#x27;t really needed. For cases like this, we can disable the test runner completely and run our test directly in the &lt;code&gt;_start&lt;&#x2f;code&gt; function.&lt;&#x2f;p&gt;
&lt;p&gt;The key to this is disable the &lt;code&gt;harness&lt;&#x2f;code&gt; flag for the test in the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;, which defines whether a test runner is used for an integration test. When it&#x27;s set to &lt;code&gt;false&lt;&#x2f;code&gt;, both the default test runner and the custom test runner feature are disabled, so that the test is treated like a normal executable.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s disable the &lt;code&gt;harness&lt;&#x2f;code&gt; flag for our &lt;code&gt;should_panic&lt;&#x2f;code&gt; test:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;test&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_panic&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;harness &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we vastly simplify our &lt;code&gt;should_panic&lt;&#x2f;code&gt; test by removing the test runner related code. The result looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;should_panic.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{QemuExitCode, exit_qemu, serial_println};

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    should_fail();
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[test did not panic]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    exit_qemu(QemuExitCode::Failed);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;should_fail() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;should_fail... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    exit_qemu(QemuExitCode::Success);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We now call the &lt;code&gt;should_fail&lt;&#x2f;code&gt; function directly from our &lt;code&gt;_start&lt;&#x2f;code&gt; function and exit with a failure exit code if it returns. When we run &lt;code&gt;cargo xtest --test should_panic&lt;&#x2f;code&gt; now, we see that the test behaves exactly as before.&lt;&#x2f;p&gt;
&lt;p&gt;Apart from creating &lt;code&gt;should_panic&lt;&#x2f;code&gt; tests, disabling the &lt;code&gt;harness&lt;&#x2f;code&gt; attribute can also be useful for complex integration tests, for example when the individual test functions have side effects and need to be run in a specified order.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;Testing is a very useful technique to ensure that certain components have a desired behavior. Even if they cannot show the absence of bugs, they&#x27;re still an useful tool for finding them and especially for avoiding regressions.&lt;&#x2f;p&gt;
&lt;p&gt;This post explained how to set up a test framework for our Rust kernel. We used the custom test frameworks feature of Rust to implement support for a simple &lt;code&gt;#[test_case]&lt;&#x2f;code&gt; attribute in our bare-metal environment. By using the &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device of QEMU, our test runner can exit QEMU after running the tests and report the test status out. To print error messages to the console instead of the VGA buffer, we created a basic driver for the serial port.&lt;&#x2f;p&gt;
&lt;p&gt;After creating some tests for our &lt;code&gt;println&lt;&#x2f;code&gt; macro, we explored integration tests in the second half of the post. We learned that they live in the &lt;code&gt;tests&lt;&#x2f;code&gt; directory and are treated as completely separate executables. To give them access to the &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; function and the &lt;code&gt;serial_println&lt;&#x2f;code&gt; macro, we moved most of our code into a library that can be imported by all executables and integration tests. Since integration tests run in their own separate environment, they make it possible to test interactions with the hardware or to create tests that should panic.&lt;&#x2f;p&gt;
&lt;p&gt;We now have a test framework that runs in a realistic environment inside QEMU. By creating more tests in future posts, we can keep our kernel maintainable when it becomes more complex.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2f;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called â€œpage faultâ€). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Paging Implementation</title>
                <pubDate>Thu, 14 Mar 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/paging-implementation/</link>
                <guid>https://os.phil-opp.com/paging-implementation/</guid>
                <description>&lt;p&gt;This post shows how to implement paging support in our kernel. It first explores different techniques to make the physical page table frames accessible to the kernel and discusses their respective advantages and drawbacks. It then implements an address translation function and a function to create a new mapping.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-09&quot;&gt;&lt;code&gt;post-09&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt; gave an introduction to the concept of paging. It motivated paging by comparing it with segmentation, explained how paging and page tables work, and then introduced the 4-level page table design of &lt;code&gt;x86_64&lt;&#x2f;code&gt;. We found out that the bootloader already set up a page table hierarchy for our kernel, which means that our kernel already runs on virtual addresses. This improves safety since illegal memory accesses cause page fault exceptions instead of modifying arbitrary physical memory.&lt;&#x2f;p&gt;
&lt;p&gt;The post ended with the problem that we &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#accessing-the-page-tables&quot;&gt;can&#x27;t access the page tables from our kernel&lt;&#x2f;a&gt; because they are stored in physical memory and our kernel already runs on virtual addresses. This post continues at this point and explores different approaches of making the page table frames accessible to our kernel. We will discuss the advantages and drawbacks of each approach and then decide for an approach for our kernel.&lt;&#x2f;p&gt;
&lt;p&gt;To implement the approach, we will need support from the bootloader, so we&#x27;ll configure it first. Afterward, we will implement a function that traverses the page table hierarchy in order to translate virtual to physical addresses. Finally, we learn how to create new mappings in the page tables and how to find unused memory frames for creating new page tables.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;dependency-updates&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dependency-updates&quot; aria-label=&quot;Anchor link for: dependency-updates&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Dependency Updates&lt;&#x2f;h3&gt;
&lt;p&gt;This post requires version 0.7.5 or later of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; dependency. You can update the dependency in your &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.7.5&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For an overview of the changes in recent versions, check out the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;blob&#x2f;master&#x2f;Changelog.md&quot;&gt;&lt;code&gt;x86_64&lt;&#x2f;code&gt; changelog&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;accessing-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-page-tables&quot; aria-label=&quot;Anchor link for: accessing-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Accessing Page Tables&lt;&#x2f;h2&gt;
&lt;p&gt;Accessing the page tables from our kernel is not as easy as it may seem. To understand the problem let&#x27;s take a look at the example 4-level page table hierarchy of the previous post again:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2f;paging-introduction&#x2f;x86_64-page-table-translation.svg&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The important thing here is that each page entry stores the &lt;em&gt;physical&lt;&#x2f;em&gt; address of the next table. This avoids the need to run a translation for these addresses too, which would be bad for performance and could easily cause endless translation loops.&lt;&#x2f;p&gt;
&lt;p&gt;The problem for us is that we can&#x27;t directly access physical addresses from our kernel since our kernel also runs on top of virtual addresses. For example, when we access address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt; we access the &lt;em&gt;virtual&lt;&#x2f;em&gt; address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, not the &lt;em&gt;physical&lt;&#x2f;em&gt; address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt; where the level 4 page table is stored. When we want to access the physical address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, we can only do so through some virtual address that maps to it.&lt;&#x2f;p&gt;
&lt;p&gt;So in order to access page table frames, we need to map some virtual pages to them. There are different ways to create these mappings that all allow us to access arbitrary page table frames.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;identity-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#identity-mapping&quot; aria-label=&quot;Anchor link for: identity-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Identity Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;A simple solution is to &lt;strong&gt;identity map all page tables&lt;&#x2f;strong&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;identity-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with various virtual pages mapped to the physical frame with the same address&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In this example, we see various identity-mapped page table frames. This way the physical addresses of page tables are also valid virtual addresses so that we can easily access the page tables of all levels starting from the CR3 register.&lt;&#x2f;p&gt;
&lt;p&gt;However, it clutters the virtual address space and makes it more difficult to find continuous memory regions of larger sizes. For example, imagine that we want to create a virtual memory region of size 1000â€¯KiB in the above graphic, e.g. for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory-mapped_file&quot;&gt;memory-mapping a file&lt;&#x2f;a&gt;. We can&#x27;t start the region at &lt;code&gt;28â€¯KiB&lt;&#x2f;code&gt; because it would collide with the already mapped page at &lt;code&gt;1004â€¯KiB&lt;&#x2f;code&gt;. So we have to look further until we find a large enough unmapped area, for example at &lt;code&gt;1008â€¯KiB&lt;&#x2f;code&gt;. This is a similar fragmentation problem as with &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#fragmentation&quot;&gt;segmentation&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Equally, it makes it much more difficult to create new page tables, because we need to find physical frames whose corresponding pages aren&#x27;t already in use. For example, let&#x27;s assume that we reserved the &lt;em&gt;virtual&lt;&#x2f;em&gt; 1000â€¯KiB memory region starting at &lt;code&gt;1008â€¯KiB&lt;&#x2f;code&gt; for our memory-mapped file. Now we can&#x27;t use any frame with a &lt;em&gt;physical&lt;&#x2f;em&gt; address between &lt;code&gt;1000â€¯KiB&lt;&#x2f;code&gt; and &lt;code&gt;2008â€¯KiB&lt;&#x2f;code&gt; anymore, because we can&#x27;t identity map it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;map-at-a-fixed-offset&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-at-a-fixed-offset&quot; aria-label=&quot;Anchor link for: map-at-a-fixed-offset&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Map at a Fixed Offset&lt;&#x2f;h3&gt;
&lt;p&gt;To avoid the problem of cluttering the virtual address space, we can &lt;strong&gt;use a separate memory region for page table mappings&lt;&#x2f;strong&gt;. So instead of identity mapping page table frames, we map them at a fixed offset in the virtual address space. For example, the offset could be 10 TiB:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;page-tables-mapped-at-offset.svg&quot; alt=&quot;The same figure as for the identity mapping, but each mapped virtual page is offset by 10 TiB.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;By using the virtual memory in the range &lt;code&gt;10TiB..(10TiB + physical memory size)&lt;&#x2f;code&gt; exclusively for page table mappings, we avoid the collision problems of the identity mapping. Reserving such a large region of the virtual address space is only possible if the virtual address space is much larger than the physical memory size. This isn&#x27;t a problem on x86_64 since the 48-bit address space is 256 TiB large.&lt;&#x2f;p&gt;
&lt;p&gt;This approach still has the disadvantage that we need to create a new mapping whenever we create a new page table. Also, it does not allow accessing page tables of other address spaces, which would be useful when creating a new process.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;map-the-complete-physical-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-the-complete-physical-memory&quot; aria-label=&quot;Anchor link for: map-the-complete-physical-memory&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Map the Complete Physical Memory&lt;&#x2f;h3&gt;
&lt;p&gt;We can solve these problems by &lt;strong&gt;mapping the complete physical memory&lt;&#x2f;strong&gt; instead of only page table frames:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;map-complete-physical-memory.svg&quot; alt=&quot;The same figure as for the offset mapping, but every physical frame has a mapping (at 10TiB + X) instead of only page table frames.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This approach allows our kernel to access arbitrary physical memory, including page table frames of other address spaces. The reserved virtual memory range has the same size as before, with the difference that it no longer contains unmapped pages.&lt;&#x2f;p&gt;
&lt;p&gt;The disadvantage of this approach is that additional page tables are needed for storing the mapping of the physical memory. These page tables need to be stored somewhere, so they use up a part of physical memory, which can be a problem on devices with a small amount of memory.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, however, we can use &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Page_%28computer_memory%29#Multiple_page_sizes&quot;&gt;huge pages&lt;&#x2f;a&gt; with size 2MiB for the mapping, instead of the default 4KiB pages. This way, mapping 32 GiB of physical memory only requires 132 KiB for page tables since only one level 3 table and 32 level 2 tables are needed. Huge pages are also more cache efficient since they use fewer entries in the translation lookaside buffer (TLB).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;temporary-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#temporary-mapping&quot; aria-label=&quot;Anchor link for: temporary-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Temporary Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;For devices with very small amounts of physical memory, we could &lt;strong&gt;map the page tables frames only temporarily&lt;&#x2f;strong&gt; when we need to access them. To be able to create the temporary mappings we only need a single identity-mapped level 1 table:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;temporarily-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with an identity mapped level 1 table, which maps its 0th entry to the level 2 table frame, thereby mapping that frame to page with address 0&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The level 1 table in this graphic controls the first 2â€¯MiB of the virtual address space. This is because it is reachable by starting at the CR3 register and following the 0th entry in the level 4, level 3, and level 2 page tables. The entry with index &lt;code&gt;8&lt;&#x2f;code&gt; maps the virtual page at address &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt; to the physical frame at address &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt;, thereby identity mapping the level 1 table itself. The graphic shows this identity-mapping by the horizontal arrow at &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;By writing to the identity-mapped level 1 table, our kernel can create up to 511 temporary mappings (512 minus the entry required for the identity mapping). In the above example, the kernel created two temporary mappings:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;By mapping the 0th entry of the level 1 table to the frame with address &lt;code&gt;24â€¯KiB&lt;&#x2f;code&gt;, it created a temporary mapping of the virtual page at &lt;code&gt;0â€¯KiB&lt;&#x2f;code&gt; to the physical frame of the level 2 page table, indicated by the dashed arrow.&lt;&#x2f;li&gt;
&lt;li&gt;By mapping the 9th entry of the level 1 table to the frame with address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, it created a temporary mapping of the virtual page at &lt;code&gt;36â€¯KiB&lt;&#x2f;code&gt; to the physical frame of the level 4 page table, indicated by the dashed arrow.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Now the kernel can access the level 2 page table by writing to page &lt;code&gt;0â€¯KiB&lt;&#x2f;code&gt; and the level 4 page table by writing to page &lt;code&gt;36â€¯KiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The process for accessing an arbitrary page table frame with temporary mappings would be:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Search for a free entry in the identity-mapped level 1 table.&lt;&#x2f;li&gt;
&lt;li&gt;Map that entry to the physical frame of the page table that we want to access.&lt;&#x2f;li&gt;
&lt;li&gt;Access the target frame through the virtual page that maps to the entry.&lt;&#x2f;li&gt;
&lt;li&gt;Set the entry back to unused thereby removing the temporary mapping again.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;This approach reuses the same 512 virtual pages for creating the mappings and thus requires only 4KiB of physical memory. The drawback is that it is a bit cumbersome, especially since a new mapping might require modifications of multiple table levels, which means that we would need to repeat the above process multiple times.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;recursive-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-page-tables&quot; aria-label=&quot;Anchor link for: recursive-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Recursive Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;Another interesting approach, that requires no additional page tables at all, is to &lt;strong&gt;map the page table recursively&lt;&#x2f;strong&gt;. The idea behind this approach is to map some entry of the level 4 page table to the level 4 table itself. By doing this, we effectively reserve a part of the virtual address space and map all current and future page table frames to that space.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s go through an example to understand how this all works:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;recursive-page-table.png&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory. Entry 511 of the level 4 page is mapped to frame 4KiB, the frame of the level 4 table itself.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The only difference to the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#accessing-page-tables&quot;&gt;example at the beginning of this post&lt;&#x2f;a&gt; is the additional entry at index &lt;code&gt;511&lt;&#x2f;code&gt; in the level 4 table, which is mapped to physical frame &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, the frame of the level 4 table itself.&lt;&#x2f;p&gt;
&lt;p&gt;By letting the CPU follow this entry on a translation, it doesn&#x27;t reach a level 3 table, but the same level 4 table again. This is similar to a recursive function that calls itself, therefore this table is called a &lt;em&gt;recursive page table&lt;&#x2f;em&gt;. The important thing is that the CPU assumes that every entry in the level 4 table points to a level 3 table, so it now treats the level 4 table as a level 3 table. This works because tables of all levels have the exact same layout on x86_64.&lt;&#x2f;p&gt;
&lt;p&gt;By following the recursive entry one or multiple times before we start the actual translation, we can effectively shorten the number of levels that the CPU traverses. For example, if we follow the recursive entry once and then proceed to the level 3 table, the CPU thinks that the level 3 table is a level 2 table. Going further, it treats the level 2 table as a level 1 table and the level 1 table as the mapped frame. This means that we can now read and write the level 1 page table because the CPU thinks that it is the mapped frame. The graphic below illustrates the 5 translation steps:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;recursive-page-table-access-level-1.png&quot; alt=&quot;The above example 4-level page hierarchy with 5 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Step 1&amp;quot; from level 4 table to level 4 table, &amp;quot;Step 2&amp;quot; from level 4 table to level 3 table, &amp;quot;Step 3&amp;quot; from level 3 table to level 2 table, and &amp;quot;Step 4&amp;quot; from level 2 table to level 1 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Similarly, we can follow the recursive entry twice before starting the translation to reduce the number of traversed levels to two:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;recursive-page-table-access-level-2.png&quot; alt=&quot;The same 4-level page hierarchy with the following 4 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Steps 1&amp;amp;2&amp;quot; from level 4 table to level 4 table, &amp;quot;Step 3&amp;quot; from level 4 table to level 3 table, and &amp;quot;Step 4&amp;quot; from level 3 table to level 2 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s go through it step by step: First, the CPU follows the recursive entry on the level 4 table and thinks that it reaches a level 3 table. Then it follows the recursive entry again and thinks that it reaches a level 2 table. But in reality, it is still on the level 4 table. When the CPU now follows a different entry, it lands on a level 3 table but thinks it is already on a level 1 table. So while the next entry points at a level 2 table, the CPU thinks that it points to the mapped frame, which allows us to read and write the level 2 table.&lt;&#x2f;p&gt;
&lt;p&gt;Accessing the tables of levels 3 and 4 works in the same way. For accessing the level 3 table, we follow the recursive entry three times, tricking the CPU into thinking it is already on a level 1 table. Then we follow another entry and reach a level 3 table, which the CPU treats as a mapped frame. For accessing the level 4 table itself, we just follow the recursive entry four times until the CPU treats the level 4 table itself as the mapped frame (in blue in the graphic below).&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;recursive-page-table-access-level-3.png&quot; alt=&quot;The same 4-level page hierarchy with the following 3 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Steps 1,2,3&amp;quot; from level 4 table to level 4 table, and &amp;quot;Step 4&amp;quot; from level 4 table to level 3 table. In blue the alternative &amp;quot;Steps 1,2,3,4&amp;quot; arrow from level 4 table to level 4 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It might take some time to wrap your head around the concept, but it works quite well in practice.&lt;&#x2f;p&gt;
&lt;p&gt;In the section below we explain how to construct virtual addresses for following the recursive entry one or multiple times. We will not use recursive paging for our implementation, so you don&#x27;t need to read it to continue with the post. If it interests you, just click on &lt;em&gt;&amp;quot;Address Calculation&amp;quot;&lt;&#x2f;em&gt; to expand it.&lt;&#x2f;p&gt;
&lt;hr &#x2f;&gt;
&lt;details&gt;
&lt;summary&gt;&lt;h4&gt;Address Calculation&lt;&#x2f;h4&gt;&lt;&#x2f;summary&gt;
&lt;p&gt;We saw that we can access tables of all levels by following the recursive entry once or multiple times before the actual translation. Since the indexes into the tables of the four levels are derived directly from the virtual address, we need to construct special virtual addresses for this technique. Remember, the page table indexes are derived from the address in the following way:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2f;paging-introduction&#x2f;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0â€“12 are the page offset, bits 12â€“21 the level 1 index, bits 21â€“30 the level 2 index, bits 30â€“39 the level 3 index, and bits 39â€“48 the level 4 index&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s assume that we want to access the level 1 page table that maps a specific page. As we learned above, this means that we have to follow the recursive entry one time before continuing with the level 4, level 3, and level 2 indexes. To do that we move each block of the address one block to the right and set the original level 4 index to the index of the recursive entry:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;table-indices-from-address-recursive-level-1.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 1 table frame, bits 12â€“21 the level 2 index, bits 21â€“30 the level 3 index, bits 30â€“39 the level 4 index, and bits 39â€“48 the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;For accessing the level 2 table of that page, we move each index block two blocks to the right and set both the blocks of the original level 4 index and the original level 3 index to the index of the recursive entry:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;table-indices-from-address-recursive-level-2.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 2 table frame, bits 12â€“21 the level 3 index, bits 21â€“30 the level 4 index, and bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Accessing the level 3 table works by moving each block three blocks to the right and using the recursive index for the original level 4, level 3, and level 2 address blocks:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;table-indices-from-address-recursive-level-3.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 3 table frame, bits 12â€“21 the level 4 index, and bits 21â€“30, bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Finally, we can access the level 4 table by moving each block four blocks to the right and using the recursive index for all address blocks except for the offset:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;table-indices-from-address-recursive-level-4.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level l table frame and bits 12â€“21, bits 21â€“30, bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We can now calculate virtual addresses for the page tables of all four levels. We can even calculate an address that points exactly to a specific page table entry by multiplying its index by 8, the size of a page table entry.&lt;&#x2f;p&gt;
&lt;p&gt;The table below summarizes the address structure for accessing the different kinds of frames:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Virtual Address for &lt;&#x2f;th&gt;&lt;th&gt;Address Structure (&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Octal&quot;&gt;octal&lt;&#x2f;a&gt;)&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Page                &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 1 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 2 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 3 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 4 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Whereas &lt;code&gt;AAA&lt;&#x2f;code&gt; is the level 4 index, &lt;code&gt;BBB&lt;&#x2f;code&gt; the level 3 index, &lt;code&gt;CCC&lt;&#x2f;code&gt; the level 2 index, and &lt;code&gt;DDD&lt;&#x2f;code&gt; the level 1 index of the mapped frame, and &lt;code&gt;EEEE&lt;&#x2f;code&gt; the offset into it. &lt;code&gt;RRR&lt;&#x2f;code&gt; is the index of the recursive entry. When an index (three digits) is transformed to an offset (four digits), it is done by multiplying it by 8 (the size of a page table entry). With this offset, the resulting address directly points to the respective page table entry.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;code&gt;SSSSSS&lt;&#x2f;code&gt; are sign extension bits, which means that they are all copies of bit 47. This is a special requirement for valid addresses on the x86_64 architecture. We explained it in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#paging-on-x86&quot;&gt;previous post&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Octal&quot;&gt;octal&lt;&#x2f;a&gt; numbers for representing the addresses since each octal character represents three bits, which allows us to clearly separate the 9-bit indexes of the different page table levels. This isn&#x27;t possible with the hexadecimal system where each character represents four bits.&lt;&#x2f;p&gt;
&lt;h5 id=&quot;in-rust-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#in-rust-code&quot; aria-label=&quot;Anchor link for: in-rust-code&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
In Rust Code&lt;&#x2f;h5&gt;
&lt;p&gt;To construct such addresses in Rust code, you can use bitwise operations:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the virtual address whose corresponding page tables you want to access
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦];

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; recursive index
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o177777 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;48&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; sign extension

&#x2f;&#x2f; retrieve the page table indices of the address that we want to translate
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 4 index
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 3 index
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l2_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 2 index
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l1_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 1 index
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o7777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; calculate the table addresses
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_3_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_2_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_1_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l2_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The above code assumes that the last level 4 entry with index &lt;code&gt;0o777&lt;&#x2f;code&gt; (511) is recursively mapped. This isn&#x27;t the case currently, so the code won&#x27;t work yet. See below on how to tell the bootloader to set up the recursive mapping.&lt;&#x2f;p&gt;
&lt;p&gt;Alternatively to performing the bitwise operations by hand, you can use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate, which provides safe abstractions for various page table operations. For example, the code below shows how to translate a virtual address to its mapped physical address:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{VirtAddr, PhysAddr};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Creates a RecursivePageTable instance from the level 4 address.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦];
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;level_4_table_ptr;
    RecursivePageTable::new(level_4_table).unwrap();
}


&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Retrieve the physical address for the given virtual address
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64 = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(addr);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page: Page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(addr);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; perform the translation
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table.translate_page(page);
frame.map(|frame| frame.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(addr.page_offset()))
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Again, a valid recursive mapping is required for this code. With such a mapping, the missing &lt;code&gt;level_4_table_addr&lt;&#x2f;code&gt; can be calculated as in the first code example.&lt;&#x2f;p&gt;
&lt;&#x2f;details&gt;
&lt;hr &#x2f;&gt;
&lt;p&gt;Recursive Paging is an interesting technique that shows how powerful a single mapping in a page table can be. It is relatively easy to implement and only requires a minimal amount of setup (just a single recursive entry), so it&#x27;s a good choice for first experiments with paging.&lt;&#x2f;p&gt;
&lt;p&gt;However, it also has some disadvantages:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;It occupies a large amount of virtual memory (512GiB). This isn&#x27;t a big problem in the large 48-bit address space, but it might lead to suboptimal cache behavior.&lt;&#x2f;li&gt;
&lt;li&gt;It only allows accessing the currently active address space easily. Accessing other address spaces is still possible by changing the recursive entry, but a temporary mapping is required for switching back. We described how to do this in the (outdated) &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#overview&quot;&gt;&lt;em&gt;Remap The Kernel&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post.&lt;&#x2f;li&gt;
&lt;li&gt;It heavily relies on the page table format of x86 and might not work on other architectures.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;bootloader-support&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bootloader-support&quot; aria-label=&quot;Anchor link for: bootloader-support&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Bootloader Support&lt;&#x2f;h2&gt;
&lt;p&gt;All of these approaches require page table modifications for their setup. For example, mappings for the physical memory need to be created or an entry of the level 4 table needs to be mapped recursively. The problem is that we can&#x27;t create these required mappings without an existing way to access the page tables.&lt;&#x2f;p&gt;
&lt;p&gt;This means that we need the help of the bootloader, which creates the page tables that our kernel runs on. The bootloader has access to the page tables, so it can create any mappings that we need. In its current implementation, the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate has support for two of the above approaches, controlled through &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;manifest.html#the-features-section&quot;&gt;cargo features&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;map_physical_memory&lt;&#x2f;code&gt; feature maps the complete physical memory somewhere into the virtual address space. Thus, the kernel can access all physical memory and can follow the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#map-the-complete-physical-memory&quot;&gt;&lt;em&gt;Map the Complete Physical Memory&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; approach.&lt;&#x2f;li&gt;
&lt;li&gt;With the &lt;code&gt;recursive_page_table&lt;&#x2f;code&gt; feature, the bootloader maps an entry of the level 4 page table recursively. This allows the kernel to access the page tables as described in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#recursive-page-tables&quot;&gt;&lt;em&gt;Recursive Page Tables&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; section.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;We choose the first approach for our kernel since it is simple, platform-independent, and more powerful (it also allows to access non-page-table-frames). To enable the required bootloader support, we add the &lt;code&gt;map_physical_memory&lt;&#x2f;code&gt; feature to our &lt;code&gt;bootloader&lt;&#x2f;code&gt; dependency:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= { &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.8.0&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_physical_memory&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;With this feature enabled, the bootloader maps the complete physical memory to some unused virtual address range. To communicate the virtual address range to our kernel, the bootloader passes a &lt;em&gt;boot information&lt;&#x2f;em&gt; structure.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;boot-information&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#boot-information&quot; aria-label=&quot;Anchor link for: boot-information&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Boot Information&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate defines a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.3.11&#x2f;bootloader&#x2f;bootinfo&#x2f;struct.BootInfo.html&quot;&gt;&lt;code&gt;BootInfo&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct that contains all the information it passes to our kernel. The struct is still in an early stage, so expect some breakage when updating to future &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;cargo&#x2f;reference&#x2f;specifying-dependencies.html#caret-requirements&quot;&gt;semver-incompatible&lt;&#x2f;a&gt; bootloader versions. With the &lt;code&gt;map_physical_memory&lt;&#x2f;code&gt; feature enabled, it currently has the two fields &lt;code&gt;memory_map&lt;&#x2f;code&gt; and &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;memory_map&lt;&#x2f;code&gt; field contains an overview of the available physical memory. This tells our kernel how much physical memory is available in the system and which memory regions are reserved for devices such as the VGA hardware. The memory map can be queried from the BIOS or UEFI firmware, but only very early in the boot process. For this reason, it must be provided by the bootloader because there is no way for the kernel to retrieve it later. We will need the memory map later in this post.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; tells us the virtual start address of the physical memory mapping. By adding this offset to a physical address, we get the corresponding virtual address. This allows us to access arbitrary physical memory from our kernel.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The bootloader passes the &lt;code&gt;BootInfo&lt;&#x2f;code&gt; struct to our kernel in the form of a &lt;code&gt;&amp;amp;&#x27;static BootInfo&lt;&#x2f;code&gt; argument to our &lt;code&gt;_start&lt;&#x2f;code&gt; function. We don&#x27;t have this argument declared in our function yet, so let&#x27;s add it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::BootInfo;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new argument
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It wasn&#x27;t a problem to leave off this argument before because the x86_64 calling convention passes the first argument in a CPU register. Thus, the argument is simply ignored when it isn&#x27;t declared. However, it would be a problem if we accidentally used a wrong argument type, since the compiler doesn&#x27;t know the correct type signature of our entry point function.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-entry-point-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-entry-point-macro&quot; aria-label=&quot;Anchor link for: the-entry-point-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;entry_point&lt;&#x2f;code&gt; Macro&lt;&#x2f;h3&gt;
&lt;p&gt;Since our &lt;code&gt;_start&lt;&#x2f;code&gt; function is called externally from the bootloader, no checking of our function signature occurs. This means that we could let it take arbitrary arguments without any compilation errors, but it would fail or cause undefined behavior at runtime.&lt;&#x2f;p&gt;
&lt;p&gt;To make sure that the entry point function has always the correct signature that the bootloader expects, the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate provides an &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.6.4&#x2f;bootloader&#x2f;macro.entry_point.html&quot;&gt;&lt;code&gt;entry_point&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; macro that provides a type-checked way to define a Rust function as the entry point. Let&#x27;s rewrite our entry point function to use this macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::{BootInfo, entry_point};

entry_point!(kernel_main);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We no longer need to use &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2f;code&gt; or &lt;code&gt;no_mangle&lt;&#x2f;code&gt; for our entry point, as the macro defines the real lower level &lt;code&gt;_start&lt;&#x2f;code&gt; entry point for us. The &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function is now a completely normal Rust function, so we can choose an arbitrary name for it. The important thing is that it is type-checked so that a compilation error occurs when we use a wrong function signature, for example by adding an argument or changing the argument type.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s perform the same change in our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::{entry_point, BootInfo};

#[cfg(test)]
entry_point!(test_kernel_main);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Entry point for `cargo xtest`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_kernel_main(_boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; like before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init();
    test_main();
    hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since the entry point is only used in test mode, we add the &lt;code&gt;#[cfg(test)]&lt;&#x2f;code&gt; attribute to all items. We give our test entry point the distinct name &lt;code&gt;test_kernel_main&lt;&#x2f;code&gt; to avoid confusion with the &lt;code&gt;kernel_main&lt;&#x2f;code&gt; of our &lt;code&gt;main.rs&lt;&#x2f;code&gt;. We don&#x27;t use the &lt;code&gt;BootInfo&lt;&#x2f;code&gt; parameter for now, so we prefix the parameter name with a &lt;code&gt;_&lt;&#x2f;code&gt; to silence the unused variable warning.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we have access to physical memory, we can finally start to implement our page table code. First, we will take a look at the currently active page tables that our kernel runs on. In the second step, we will create a translation function that returns the physical address that a given virtual address is mapped to. As the last step, we will try to modify the page tables in order to create a new mapping.&lt;&#x2f;p&gt;
&lt;p&gt;Before we begin, we create a new &lt;code&gt;memory&lt;&#x2f;code&gt; module for our code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For the module we create an empty &lt;code&gt;src&#x2f;memory.rs&lt;&#x2f;code&gt; file.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;accessing-the-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-the-page-tables&quot; aria-label=&quot;Anchor link for: accessing-the-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Accessing the Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;At the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#accessing-the-page-tables&quot;&gt;end of the previous post&lt;&#x2f;a&gt;, we tried to take a look at the page tables our kernel runs on, but failed since we couldn&#x27;t access the physical frame that the &lt;code&gt;CR3&lt;&#x2f;code&gt; register points to. We&#x27;re now able to continue from there by creating an &lt;code&gt;active_level_4_table&lt;&#x2f;code&gt; function that returns a reference to the active level 4 page table:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{
    structures::paging::PageTable,
    VirtAddr,
};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Returns a mutable reference to the active level 4 table.
&#x2f;&#x2f;&#x2f;
&#x2f;&#x2f;&#x2f; This function is unsafe because the caller must guarantee that the
&#x2f;&#x2f;&#x2f; complete physical memory is mapped to virtual memory at the passed
&#x2f;&#x2f;&#x2f; `physical_memory_offset`. Also, this function must be only called once
&#x2f;&#x2f;&#x2f; to avoid aliasing `&amp;amp;mut` references (which is undefined behavior).
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;active_level_4_table(physical_memory_offset: VirtAddr)
    -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control::Cr3;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_4_table_frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Cr3::read();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_frame.start_address();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; physical_memory_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys.as_u64();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_table_ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt.as_mut_ptr();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_table_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; unsafe
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we read the physical frame of the active level 4 table from the &lt;code&gt;CR3&lt;&#x2f;code&gt; register. We then take its physical start address, convert it to an &lt;code&gt;u64&lt;&#x2f;code&gt;, and add it to &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; to get the virtual address where the page table frame is mapped. Finally, we convert the virtual address to a &lt;code&gt;*mut PageTable&lt;&#x2f;code&gt; raw pointer through the &lt;code&gt;as_mut_ptr&lt;&#x2f;code&gt; method and then unsafely create a &lt;code&gt;&amp;amp;mut PageTable&lt;&#x2f;code&gt; reference from it. We create a &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; reference instead of a &lt;code&gt;&amp;amp;&lt;&#x2f;code&gt; reference because we will mutate the page tables later in this post.&lt;&#x2f;p&gt;
&lt;p&gt;We don&#x27;t need to use an unsafe block here because Rust treats the complete body of an &lt;code&gt;unsafe fn&lt;&#x2f;code&gt; like a large &lt;code&gt;unsafe&lt;&#x2f;code&gt; block. This makes our code more dangerous since we could accidentally introduce an unsafe operation in previous lines without noticing. It also makes it much more difficult to spot the unsafe operations. There is an &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;2585&quot;&gt;RFC&lt;&#x2f;a&gt; to change this behavior.&lt;&#x2f;p&gt;
&lt;p&gt;We can now use this function to print the entries of the level 4 table:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::active_level_4_table;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtAddr;

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ active_level_4_table(phys_mem_offset) };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, entry) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l4_table.iter().enumerate() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;entry.is_unused() {
            println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;L4 Entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, i, entry);
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
    test_main();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we convert the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; of the &lt;code&gt;BootInfo&lt;&#x2f;code&gt; struct to a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and pass it to the &lt;code&gt;active_level_4_table&lt;&#x2f;code&gt; function. We then use the &lt;code&gt;iter&lt;&#x2f;code&gt; function to iterate over the page table entries and the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; combinator to additionally add an index &lt;code&gt;i&lt;&#x2f;code&gt; to each element. We only print non-empty entries because all 512 entries wouldn&#x27;t fit on the screen.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;qemu-print-level-4-table.png&quot; alt=&quot;QEMU printing entry 0 (0x2000, PRESENT, WRITABLE, ACCESSED), entry 1 (0x894000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 31 (0x88e000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 175 (0x891000, PRESENT, WRITABLE, ACCESSED, DIRTY), and entry 504 (0x897000, PRESENT, WRITABLE, ACCESSED, DIRTY)&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that there are various non-empty entries, which all map to different level 3 tables. There are so many regions because kernel code, kernel stack, the physical memory mapping, and the boot information all use separate memory areas.&lt;&#x2f;p&gt;
&lt;p&gt;To traverse the page tables further and take a look at a level 3 table, we can take the mapped frame of an entry convert it to a virtual address again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in the `for` loop in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::PageTable;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;entry.is_unused() {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;L4 Entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, i, entry);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; get the physical address from the entry and convert it
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry.frame().unwrap().start_address();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys.as_u64() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.physical_memory_offset;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(virt).as_mut_ptr();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l3_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; print non-empty entries of the level 3 table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, entry) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l3_table.iter().enumerate() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;entry.is_unused() {
            println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;  L3 Entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, i, entry);
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For looking at the level 2 and level 1 tables, we repeat that process for the level 3 and level 2 entries. As you can imagine, this gets very verbose quickly, so we don&#x27;t show the full code here.&lt;&#x2f;p&gt;
&lt;p&gt;Traversing the page tables manually is interesting because it helps to understand how the CPU performs the translation. However, most of the time we are only interested in the mapped physical address for a given virtual address, so let&#x27;s create a function for that.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Translating Addresses&lt;&#x2f;h3&gt;
&lt;p&gt;For translating a virtual to a physical address, we have to traverse the four-level page table until we reach the mapped frame. Let&#x27;s create a function that performs this translation:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::PhysAddr;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Translates the given virtual address to the mapped physical address, or
&#x2f;&#x2f;&#x2f; `None` if the address is not mapped.
&#x2f;&#x2f;&#x2f;
&#x2f;&#x2f;&#x2f; This function is unsafe because the caller must guarantee that the
&#x2f;&#x2f;&#x2f; complete physical memory is mapped to virtual memory at the passed
&#x2f;&#x2f;&#x2f; `physical_memory_offset`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate_addr(addr: VirtAddr, physical_memory_offset: VirtAddr)
    -&amp;gt; Option&amp;lt;PhysAddr&amp;gt;
{
    translate_addr_inner(addr, physical_memory_offset)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We forward the function to a safe &lt;code&gt;translate_addr_inner&lt;&#x2f;code&gt; function to limit the scope of &lt;code&gt;unsafe&lt;&#x2f;code&gt;. As we noted above, Rust treats the complete body of an unsafe fn like a large unsafe block. By calling into a private safe function, we make each &lt;code&gt;unsafe&lt;&#x2f;code&gt; operation explicit again.&lt;&#x2f;p&gt;
&lt;p&gt;The private inner function contains the real implementation:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&#x2f;&#x2f;&#x2f; Private function that is called by `translate_addr`.
&#x2f;&#x2f;&#x2f;
&#x2f;&#x2f;&#x2f; This function is safe to limit the scope of `unsafe` because Rust treats
&#x2f;&#x2f;&#x2f; the whole body of unsafe functions as an unsafe block. This function must
&#x2f;&#x2f;&#x2f; only be reachable through `unsafe fn` from outside of this module.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate_addr_inner(addr: VirtAddr, physical_memory_offset: VirtAddr)
    -&amp;gt; Option&amp;lt;PhysAddr&amp;gt;
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::page_table::FrameError;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control::Cr3;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; read the active level 4 frame from the CR3 register
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_4_table_frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Cr3::read();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; table_indexes &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[
        addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index()
    ];
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_frame;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; traverse the multi-level page table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;table_indexes {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; convert the frame into a page table reference
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; physical_memory_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame.start_address().as_u64();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; table_ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*const&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt.as_ptr();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;table_ptr};

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; read the page table entry and update `frame`
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;table[index];
        frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry.frame() {
            Ok(frame) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame,
            Err(FrameError::FrameNotPresent) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None,
            Err(FrameError::HugeFrame) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;huge pages not supported&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        };
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; calculate the physical address by adding the page offset
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(frame.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(addr.page_offset()))
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of reusing our &lt;code&gt;active_level_4_table&lt;&#x2f;code&gt; function, we read the level 4 frame from the &lt;code&gt;CR3&lt;&#x2f;code&gt; register again. We do this because it simplifies this prototype implementation. Don&#x27;t worry, we will create a better solution in a moment.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;VirtAddr&lt;&#x2f;code&gt; struct already provides methods to compute the indexes into the page tables of the four levels. We store these indexes in a small array because it allows us to traverse the page tables using a &lt;code&gt;for&lt;&#x2f;code&gt; loop. Outside of the loop, we remember the last visited &lt;code&gt;frame&lt;&#x2f;code&gt; to calculate the physical address later. The &lt;code&gt;frame&lt;&#x2f;code&gt; points to page table frames while iterating, and to the mapped frame after the last iteration, i.e. after following the level 1 entry.&lt;&#x2f;p&gt;
&lt;p&gt;Inside the loop, we again use the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; to convert the frame into a page table reference. We then read the entry of the current page table and use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page_table&#x2f;struct.PageTableEntry.html#method.frame&quot;&gt;&lt;code&gt;PageTableEntry::frame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function to retrieve the mapped frame. If the entry is not mapped to a frame we return &lt;code&gt;None&lt;&#x2f;code&gt;. If the entry maps a huge 2MiB or 1GiB page we panic for now.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s test our translation function by translating some addresses:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new imports
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::translate_addr;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtAddr;

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; hello world and blog_os::init

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(boot_info.physical_memory_offset);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the identity-mapped vga buffer page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some code page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x201008&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some stack page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0100_0020_1a10&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; virtual address mapped to physical address 0
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        boot_info.physical_memory_offset,
    ];

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;addresses {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(address);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ translate_addr(virt, phys_mem_offset) };
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, virt, phys);
    }

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;qemu-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x201008 -&amp;gt; 0x401008, 0x10000201a10 -&amp;gt; 0x279a10, &amp;quot;panicked at &#x27;huge pages not supported&#x27;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As expected, the identity-mapped address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; translates to the same physical address. The code page and the stack page translate to some arbitrary physical addresses, which depend on how the bootloader created the initial mapping for our kernel. It&#x27;s worth noting that the last 12 bits always stay the same after translation, which makes sense because these bits are the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#paging-on-x86-64&quot;&gt;&lt;em&gt;page offset&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and not part of the translation.&lt;&#x2f;p&gt;
&lt;p&gt;Since each physical address can be accessed by adding the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt;, the translation of the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; address itself should point to physical address &lt;code&gt;0&lt;&#x2f;code&gt;. However, the translation fails because the mapping uses huge pages for efficiency, which is not supported in our implementation yet.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;using-offsetpagetable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-offsetpagetable&quot; aria-label=&quot;Anchor link for: using-offsetpagetable&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;Translating virtual to physical addresses is a common task in an OS kernel, therefore the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate provides an abstraction for it. The implementation already supports huge pages and several other page table functions apart from &lt;code&gt;translate_addr&lt;&#x2f;code&gt;, so we will use it in the following instead of adding huge page support to our own implementation.&lt;&#x2f;p&gt;
&lt;p&gt;The base of the abstraction are two traits that define various page table mapping functions:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait is generic over the page size and provides functions that operate on pages. Examples are &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.translate_page&quot;&gt;&lt;code&gt;translate_page&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, which translates a given page to a frame of the same size, and &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, which creates a new mapping in the page table.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.MapperAllSizes.html&quot;&gt;&lt;code&gt;MapperAllSizes&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait implies that the implementor implements &lt;code&gt;Mapper&lt;&#x2f;code&gt; for all pages sizes. In addition, it provides functions that work with multiple page sizes such as &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.MapperAllSizes.html#method.translate_addr&quot;&gt;&lt;code&gt;translate_addr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; or the general &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.MapperAllSizes.html#tymethod.translate&quot;&gt;&lt;code&gt;translate&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The traits only define the interface, they don&#x27;t provide any implementation. The &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate currently provides three types that implement the traits with different requirements. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.OffsetPageTable.html&quot;&gt;&lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type assumes that the complete physical memory is mapped to the virtual address space at some offset. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MappedPageTable.html&quot;&gt;&lt;code&gt;MappedPageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; is a bit more flexible: It only requires that each page table frame is mapped to the virtual address space at a calculable address. Finally, the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type can be used to access page table frames through &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#recursive-page-tables&quot;&gt;recursive page tables&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;In our case, the bootloader maps the complete physical memory at an virtual address specfied by the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; variable, so we can use the &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt; type. To initialize it, we create a new &lt;code&gt;init&lt;&#x2f;code&gt; function in our &lt;code&gt;memory&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::OffsetPageTable;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Initialize a new OffsetPageTable.
&#x2f;&#x2f;&#x2f;
&#x2f;&#x2f;&#x2f; This function is unsafe because the caller must guarantee that the
&#x2f;&#x2f;&#x2f; complete physical memory is mapped to virtual memory at the passed
&#x2f;&#x2f;&#x2f; `physical_memory_offset`. Also, this function must be only called once
&#x2f;&#x2f;&#x2f; to avoid aliasing `&amp;amp;mut` references (which is undefined behavior).
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(physical_memory_offset: VirtAddr) -&amp;gt; OffsetPageTable&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;active_level_4_table(physical_memory_offset);
    OffsetPageTable::new(level_4_table, physical_memory_offset)
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; make private
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;active_level_4_table(physical_memory_offset: VirtAddr)
    -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable
{â€¦}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The function takes the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; as an argument and returns a new &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt; instance with a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime. This means that the instance stays valid for the complete runtime of our kernel. In the function body, we first call the &lt;code&gt;active_level_4_table&lt;&#x2f;code&gt; function to retrieve a mutable reference to the level 4 page table. We then invoke the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.OffsetPageTable.html#method.new&quot;&gt;&lt;code&gt;OffsetPageTable::new&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function with this reference. As the second parameter, the &lt;code&gt;new&lt;&#x2f;code&gt; function expects the virtual address at which the mapping of the physical memory starts, which is given in the &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; variable.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;active_level_4_table&lt;&#x2f;code&gt; function should be only called from the &lt;code&gt;init&lt;&#x2f;code&gt; function from now on because it can easily to aliased mutable references when called multiple times, which can cause undefined behavior. For this reason, we make the function private by removing the &lt;code&gt;pub&lt;&#x2f;code&gt; specifier.&lt;&#x2f;p&gt;
&lt;p&gt;We now can use the &lt;code&gt;MapperAllSizes::translate_addr&lt;&#x2f;code&gt; method instead of our own &lt;code&gt;memory::translate_addr&lt;&#x2f;code&gt; function. We only need to change a few lines in our &lt;code&gt;kernel_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new: different imports
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{structures::paging::MapperAllSizes, VirtAddr};

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; hello world and blog_os::init

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new: initialize a mapper
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(phys_mem_offset) };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; same as before

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;addresses {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(address);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new: use the `mapper.translate_addr` method
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper.translate_addr(virt);
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, virt, phys);
    }

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need to import the &lt;code&gt;MapperAllSizes&lt;&#x2f;code&gt; trait in order to use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.MapperAllSizes.html#method.translate_addr&quot;&gt;&lt;code&gt;translate_addr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method it provides.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it now, we see the same translation results as before, with the difference that the huge page translation now also works:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;qemu-mapper-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x201008 -&amp;gt; 0x401008, 0x10000201a10 -&amp;gt; 0x279a10, 0x18000000000 -&amp;gt; 0x0&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As expected, the translations of &lt;code&gt;0xb8000&lt;&#x2f;code&gt; and the code and stack addresses stay the same as with our own translation function. Additionally, we now see that the virtual address &lt;code&gt;physical_memory_offset&lt;&#x2f;code&gt; is mapped to the physical address &lt;code&gt;0x0&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;By using the translation function of the &lt;code&gt;MappedPageTable&lt;&#x2f;code&gt; type we can spare ourselves the work of implementing huge page support. We also have access to other page functions such as &lt;code&gt;map_to&lt;&#x2f;code&gt;, which we will use in the next section.&lt;&#x2f;p&gt;
&lt;p&gt;At this point we no longer need our &lt;code&gt;memory::translate_addr&lt;&#x2f;code&gt; function, so we can delete it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-a-new-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-new-mapping&quot; aria-label=&quot;Anchor link for: creating-a-new-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a new Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;Until now we only looked at the page tables without modifying anything. Let&#x27;s change that by creating a new mapping for a previously unmapped page.&lt;&#x2f;p&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function of the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait for our implementation, so let&#x27;s take a look at that function first. The documentation tells us that it takes four arguments: the page that we want to map, the frame that the page should be mapped to, a set of flags for the page table entry, and a &lt;code&gt;frame_allocator&lt;&#x2f;code&gt;. The frame allocator is needed because mapping the given page might require creating additional page tables, which need unused frames as backing storage.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;a-create-example-mapping-function&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-create-example-mapping-function&quot; aria-label=&quot;Anchor link for: a-create-example-mapping-function&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; Function&lt;&#x2f;h4&gt;
&lt;p&gt;The first step of our implementation is to create a new &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function that maps a given virtual page to &lt;code&gt;0xb8000&lt;&#x2f;code&gt;, the physical frame of the VGA text buffer. We choose that frame because it allows us to easily test if the mapping was created correctly: We just need to write to the newly mapped page and see whether we see the write appear on the screen.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{
    PhysAddr,
    structures::paging::{Page, PhysFrame, Mapper, Size4KiB, FrameAllocator}
};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Creates an example mapping for the given page to frame `0xb8000`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;create_example_mapping(
    page: Page,
    mapper: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; OffsetPageTable,
    frame_allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::PageTableFlags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Flags;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PhysFrame::containing_address(PhysAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Flags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Flags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; map_to_result &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        mapper.map_to(page, frame, flags, frame_allocator)
    };
    map_to_result.expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_to failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).flush();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;In addition to the &lt;code&gt;page&lt;&#x2f;code&gt; that should be mapped, the function expects a mutable reference to an &lt;code&gt;OffsetPageTable&lt;&#x2f;code&gt; instance and a &lt;code&gt;frame_allocator&lt;&#x2f;code&gt;. The &lt;code&gt;frame_allocator&lt;&#x2f;code&gt; parameter uses the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-02-traits.html#traits-as-parameters&quot;&gt;&lt;code&gt;impl Trait&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; syntax to be &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-00-generics.html&quot;&gt;generic&lt;&#x2f;a&gt; over all types that implement the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait. The trait is generic over the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;trait.PageSize.html&quot;&gt;&lt;code&gt;PageSize&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait to work with both standard 4KiB pages and huge 2MiB&#x2f;1GiB pages. We only want to create a 4KiB mapping, so we set the generic parameter to &lt;code&gt;Size4KiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;For the mapping, we set the &lt;code&gt;PRESENT&lt;&#x2f;code&gt; flag because it is required for all valid entries and the &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flag to make the mapped page writable. Calling &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; is unsafe because it&#x27;s possible to break memory safety with invalid arguments, so we need to use an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block. For a list of all possible flags, see the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#page-table-format&quot;&gt;&lt;em&gt;Page Table Format&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; section of the previous post.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function can fail, so it returns a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. Since this is just some example code that does not need to be robust, we just use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; to panic when an error occurs. On success, the function returns a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type that provides an easy way to flush the newly mapped page from the translation lookaside buffer (TLB) with its &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method. Like &lt;code&gt;Result&lt;&#x2f;code&gt;, the type uses the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;result&#x2f;#results-must-be-used&quot;&gt;&lt;code&gt;#[must_use]&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; attribute to emit a warning when we accidentally forget to use it.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;a-dummy-frameallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-dummy-frameallocator&quot; aria-label=&quot;Anchor link for: a-dummy-frameallocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A dummy &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;&lt;&#x2f;h4&gt;
&lt;p&gt;To be able to call &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; we need to create a type that implements the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait first. As noted above, the trait is responsible for allocating frames for new page table if they are needed by &lt;code&gt;map_to&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s start with the simple case and assume that we don&#x27;t need to create new page tables. For this case, a frame allocator that always returns &lt;code&gt;None&lt;&#x2f;code&gt; suffices. We create such an &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; for testing our mapping function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&#x2f;&#x2f;&#x2f; A FrameAllocator that always returns `None`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EmptyFrameAllocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EmptyFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
        None
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Implementing the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; is unsafe because the implementer must guarantee that the allocator yields only unused frames. Otherwise undefined behavior might occur, for example when two virtual pages are mapped to the same physical frame. Our &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; only returns &lt;code&gt;None&lt;&#x2f;code&gt;, so this isn&#x27;t a problem in this case.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;choosing-a-virtual-page&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#choosing-a-virtual-page&quot; aria-label=&quot;Anchor link for: choosing-a-virtual-page&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Choosing a Virtual Page&lt;&#x2f;h4&gt;
&lt;p&gt;We now have a simple frame allocator that we can pass to our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function. However, the allocator always returns &lt;code&gt;None&lt;&#x2f;code&gt;, so this will only work if no additional page table frames are needed for creating the mapping. To understand when additional page table frames are needed and when not, let&#x27;s consider an example:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;required-page-frames-example.svg&quot; alt=&quot;A virtual and a physical address space with a single mapped page and the page tables of all four levels&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The graphic shows the virtual address space on the left, the physical address space on the right, and the page tables in between. The page tables are stored in physical memory frames, indicated by the dashed lines. The virtual address space contains a single mapped page at address &lt;code&gt;0x803fe00000&lt;&#x2f;code&gt;, marked in blue. To translate this page to its frame, the CPU walks the 4-level page table until it reaches the frame at address 36 KiB.&lt;&#x2f;p&gt;
&lt;p&gt;Additionally, the graphic shows the physical frame of the VGA text buffer in red. Our goal is to map a previously unmapped virtual page to this frame using our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function. Since our &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; always returns &lt;code&gt;None&lt;&#x2f;code&gt;, we want to create the mapping so that no additional frames are needed from the allocator. This depends on the virtual page that we select for the mapping.&lt;&#x2f;p&gt;
&lt;p&gt;The graphic shows two canditate pages in the virtual address space, both marked in yellow. One page is at address &lt;code&gt;0x803fdfd000&lt;&#x2f;code&gt;, which is 3 pages before the mapped page (in blue). While the level 4 and level 3 page table indices are the same as for the blue page, the level 2 and level 1 indices are different (see the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#paging-on-x86-64&quot;&gt;previous post&lt;&#x2f;a&gt;). The different index into the level 2 table means that a different level 1 table is used for this page. Since this level 1 table does not exist yet, we would need to create it if we chose that page for our example mapping, which would require an additional unused physical frame. In contrast, the second candidate page at address &lt;code&gt;0x803fe02000&lt;&#x2f;code&gt; does not have this problem because it uses the same level 1 page table than the blue page. Thus, all required page tables already exist.&lt;&#x2f;p&gt;
&lt;p&gt;In summary, the difficulty of creating a new mapping depends on the virtual page that we want to map. In the easiest case, the level 1 page table for the page already exists and we just need to write a single entry. In the most difficult case, the page is in a memory region for that no level 3 exists yet so that we need to create new level 3, level 2 and level 1 page tables first.&lt;&#x2f;p&gt;
&lt;p&gt;For calling our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function with the &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt;, we need to choose a page for that all page tables already exist. To find such a page, we can utilize the fact that the bootloader loads itself in the first megabyte of the virtual address space. This means that a valid level 1 table exists for all pages this region. Thus, we can choose any unused page in this memory region for our example mapping, such as the page at address &lt;code&gt;0&lt;&#x2f;code&gt;. Normally, this page should stay unused to guarantee that dereferencing a null pointer causes a page fault, so we know that the bootloader leaves it unmapped.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;creating-the-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-the-mapping&quot; aria-label=&quot;Anchor link for: creating-the-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating the Mapping&lt;&#x2f;h4&gt;
&lt;p&gt;We now have all the required parameters for calling our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function, so let&#x27;s modify our &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function to map the page at virtual address &lt;code&gt;0&lt;&#x2f;code&gt;. Since we map the page to the frame of the VGA text buffer, we should be able to write to the screen through it afterwards. The implementation looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{structures::paging::Page, VirtAddr}; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new import

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; hello world and blog_os::init

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_mem_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(boot_info.physical_memory_offset);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(phys_mem_offset) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::EmptyFrameAllocator;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; map an unused page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(VirtAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    memory::create_example_mapping(page, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; mapper, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; write the string `New!` to the screen through the new mapping
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u64 =&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page.start_address().as_mut_ptr();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ page_ptr.offset(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;400&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).write_volatile(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x_f021_f077_f065_f04e&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)};

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test_main(), &amp;quot;it did not crash&amp;quot; printing, and hlt_loop()
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We first create the mapping for the page at address &lt;code&gt;0&lt;&#x2f;code&gt; by calling our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function with a mutable reference to the &lt;code&gt;mapper&lt;&#x2f;code&gt; and the &lt;code&gt;frame_allocator&lt;&#x2f;code&gt; instances. This maps the page to the VGA text buffer frame, so we should see any write to it on the screen.&lt;&#x2f;p&gt;
&lt;p&gt;Then we convert the page to a raw pointer and write a value to offset &lt;code&gt;400&lt;&#x2f;code&gt;. We don&#x27;t write to the start of the page because the top line of the VGA buffer is directly shifted off the screen by the next &lt;code&gt;println&lt;&#x2f;code&gt;. We write the value &lt;code&gt;0x_f021_f077_f065_f04e&lt;&#x2f;code&gt;, which represents the string &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on white background. As we learned &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#volatile&quot;&gt;in the &lt;em&gt;â€œVGA Text Modeâ€&lt;&#x2f;em&gt; post&lt;&#x2f;a&gt;, writes to the VGA buffer should be volatile, so we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;primitive.pointer.html#method.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it in QEMU, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;qemu-new-mapping.png&quot; alt=&quot;QEMU printing &amp;quot;It did not crash!&amp;quot; with four completely white cells in the middle of the screen&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on the screen is by our write to page &lt;code&gt;0&lt;&#x2f;code&gt;, which means that we successfully created a new mapping in the page tables.&lt;&#x2f;p&gt;
&lt;p&gt;Creating that mapping only worked because the level 1 table responsible for the page at address &lt;code&gt;0&lt;&#x2f;code&gt; already exists. When we try to map a page for that no level 1 table exists yet, the &lt;code&gt;map_to&lt;&#x2f;code&gt; function fails because it tries to allocate frames from the &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; for creating new page tables. We can see that happen when we try to map page &lt;code&gt;0xdeadbeaf000&lt;&#x2f;code&gt; instead of &lt;code&gt;0&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(VirtAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    [â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, a panic with the following error message occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panicked at &amp;#39;map_to failed: FrameAllocationFailed&amp;#39;, &#x2f;â€¦&#x2f;result.rs:999:5
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To map pages that don&#x27;t have a level 1 page table yet we need to create a proper &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;. But how do we know which frames are unused and how much physical memory is available?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;allocating-frames&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-frames&quot; aria-label=&quot;Anchor link for: allocating-frames&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocating Frames&lt;&#x2f;h3&gt;
&lt;p&gt;In order to create new page tables, we need to create a proper frame allocator. For that we use the &lt;code&gt;memory_map&lt;&#x2f;code&gt; that is passed by the bootloader as part of the &lt;code&gt;BootInfo&lt;&#x2f;code&gt; struct:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::bootinfo::MemoryMap;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; A FrameAllocator that returns usable frames from the bootloader&amp;#39;s memory map.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator {
    memory_map: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryMap,
    next: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Create a FrameAllocator from the passed memory map.
    &#x2f;&#x2f;&#x2f;
    &#x2f;&#x2f;&#x2f; This function is unsafe because the caller must guarantee that the passed
    &#x2f;&#x2f;&#x2f; memory map is valid. The main requirement is that all frames that are marked
    &#x2f;&#x2f;&#x2f; as `USABLE` in it are really unused.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_map: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryMap) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator {
            memory_map,
            next: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The struct has two fields: A &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; reference to the memory map passed by the bootloader and a &lt;code&gt;next&lt;&#x2f;code&gt; field that keeps track of number of the next frame that the allocator should return.&lt;&#x2f;p&gt;
&lt;p&gt;As we explained in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-implementation&#x2f;#boot-information&quot;&gt;&lt;em&gt;Boot Information&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; section, the memory map is provided by the BIOS&#x2f;UEFI firmware. It can only be queried very early in the boot process, so the bootloader already calls the respective functions for us. The memory map consists of a list of &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.6.4&#x2f;bootloader&#x2f;bootinfo&#x2f;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; structs, which contain the start address, the length, and the type (e.g. unused, reserved, etc.) of each memory region.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;init&lt;&#x2f;code&gt; function initializes a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt; with a given memory map. The &lt;code&gt;next&lt;&#x2f;code&gt; field is initialized with &lt;code&gt;0&lt;&#x2f;code&gt; and will be increased for every frame allocation to avoid returning the same frame twice. Since we don&#x27;t know if the usable frames of the memory map were already used somewhere else, our &lt;code&gt;init&lt;&#x2f;code&gt; function must be &lt;code&gt;unsafe&lt;&#x2f;code&gt; to require additional guarantees from the caller.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;a-usable-frames-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-usable-frames-method&quot; aria-label=&quot;Anchor link for: a-usable-frames-method&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A &lt;code&gt;usable_frames&lt;&#x2f;code&gt; Method&lt;&#x2f;h4&gt;
&lt;p&gt;Before we implement the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait, we add an auxiliary method that converts the memory map into an iterator of usable frames:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::bootinfo::MemoryRegionType;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Returns an iterator over the usable frames specified in the memory map.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;usable_frames(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; impl Iterator&amp;lt;Item = PhysFrame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; get usable regions from memory map
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; regions &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.memory_map.iter();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; usable_regions &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; regions
            .filter(|r| r.region_type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;MemoryRegionType::Usable);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; map each region to its address range
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr_ranges &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; usable_regions
            .map(|r| r.range.start_addr()&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;r.range.end_addr());
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; transform to an iterator of frame start addresses
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr_ranges.flat_map(|r| r.step_by(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create `PhysFrame` types from the start addresses
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        frame_addresses
            .map(|addr|PhysFrame::containing_address(PhysAddr::new(addr)))
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function uses iterator combinator methods to transform the initial &lt;code&gt;MemoryMap&lt;&#x2f;code&gt; into an iterator of usable physical frames:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;First, we call the &lt;code&gt;iter&lt;&#x2f;code&gt; method to convert the memory map to an iterator of &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.6.4&#x2f;bootloader&#x2f;bootinfo&#x2f;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;s.&lt;&#x2f;li&gt;
&lt;li&gt;Then we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.filter&quot;&gt;&lt;code&gt;filter&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to skip any reserved or otherwise unavailable regions. The bootloader updates the memory map for all the mappings it creates, so frames that are used by our kernel (code, data or stack) or to store the boot information are already marked as &lt;code&gt;InUse&lt;&#x2f;code&gt; or similar. Thus we can be sure that &lt;code&gt;Usable&lt;&#x2f;code&gt; frames are not used somewhere else.&lt;&#x2f;li&gt;
&lt;li&gt;Afterwards, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; combinator and Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;ops&#x2f;struct.Range.html&quot;&gt;range syntax&lt;&#x2f;a&gt; to transform our iterator of memory regions to an iterator of address ranges.&lt;&#x2f;li&gt;
&lt;li&gt;The next step is the most complicated: We convert each range to an iterator through the &lt;code&gt;into_iter&lt;&#x2f;code&gt; method and then choose every 4096th address using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. Since 4096 bytes (= 4 KiB) is the page size, we get the start address of each frame. The bootloader page aligns all usable memory areas so that we don&#x27;t need any alignment or rounding code here. By using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instead of &lt;code&gt;map&lt;&#x2f;code&gt;, we get an &lt;code&gt;Iterator&amp;lt;Item = u64&amp;gt;&lt;&#x2f;code&gt; instead of an &lt;code&gt;Iterator&amp;lt;Item = Iterator&amp;lt;Item = u64&amp;gt;&amp;gt;&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;Finally, we convert the start addresses to &lt;code&gt;PhysFrame&lt;&#x2f;code&gt; types to construct the desired &lt;code&gt;Iterator&amp;lt;Item = PhysFrame&amp;gt;&lt;&#x2f;code&gt;. We then use this iterator to create and return a new &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The return type of the function uses the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-02-traits.html#returning-types-that-implement-traits&quot;&gt;&lt;code&gt;impl Trait&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; feature. This way, we can specify that we return some type that implements the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait with item type &lt;code&gt;PhysFrame&lt;&#x2f;code&gt;, but don&#x27;t need to name the concrete return type. This is important here because we &lt;em&gt;can&#x27;t&lt;&#x2f;em&gt; name the conrete type since it depends on unnamable closure types.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;implementing-the-frameallocator-trait&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-the-frameallocator-trait&quot; aria-label=&quot;Anchor link for: implementing-the-frameallocator-trait&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementing the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; Trait&lt;&#x2f;h4&gt;
&lt;p&gt;Now we can implement the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.usable_frames().nth(self.next);
        self.next &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        frame
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We first use an &lt;code&gt;usable_frames&lt;&#x2f;code&gt; method to get an iterator of usable frames from the memory map. Then, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.nth&quot;&gt;&lt;code&gt;Iterator::nth&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function to get the frame with index &lt;code&gt;self.next&lt;&#x2f;code&gt; (thereby skipping &lt;code&gt;(self.next - 1)&lt;&#x2f;code&gt; frames). Before returning that frame, we increase &lt;code&gt;self.next&lt;&#x2f;code&gt; by one so that we return the following frame on the next call.&lt;&#x2f;p&gt;
&lt;p&gt;This implementation is not quite optimal since it recreates the &lt;code&gt;usable_frame&lt;&#x2f;code&gt; allocator on every allocation. It would be better to directly store the iterator as a struct field instead. Then we wouldn&#x27;t need the &lt;code&gt;nth&lt;&#x2f;code&gt; method and could just call &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;next&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; on every allocation. The problem with this approach is that it&#x27;s not possible to store an &lt;code&gt;impl Trait&lt;&#x2f;code&gt; type in a struct field currently. It might work someday when &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;2071&quot;&gt;&lt;em&gt;named existential types&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; are fully implemented.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;using-the-bootinfoframeallocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-bootinfoframeallocator&quot; aria-label=&quot;Anchor link for: using-the-bootinfoframeallocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt;&lt;&#x2f;h4&gt;
&lt;p&gt;We can now modify our &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function to pass a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt; instance instead of an &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::BootInfoFrameAllocator;
    [â€¦]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        BootInfoFrameAllocator::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map)
    };
    [â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;With the boot info frame allocator, the mapping succeeds and we see the black-on-white &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on the screen again. Behind the scenes, the &lt;code&gt;map_to&lt;&#x2f;code&gt; method creates the missing page tables in the following way:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Allocate an unused frame from the passed &lt;code&gt;frame_allocator&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;Zero the frame to create a new, empty page table.&lt;&#x2f;li&gt;
&lt;li&gt;Map the entry of the higher level table to that frame.&lt;&#x2f;li&gt;
&lt;li&gt;Continue with the next table level.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;While our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function is just some example code, we are now able to create new mappings for arbitrary pages. This will be essential for allocating memory or implementing multithreading in future posts.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we learned about different techniques to access the physical frames of page tables, including identity mapping, mapping of the complete physical memory, temporary mapping, and recursive page tables. We chose to map the complete physical memory since it&#x27;s simple, portable, and powerful.&lt;&#x2f;p&gt;
&lt;p&gt;We can&#x27;t map the physical memory from our kernel without page table access, so we needed support from the bootloader. The &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate supports creating the required mapping through optional cargo features. It passes the required information to our kernel in the form of a &lt;code&gt;&amp;amp;BootInfo&lt;&#x2f;code&gt; argument to our entry point function.&lt;&#x2f;p&gt;
&lt;p&gt;For our implementation, we first manually traversed the page tables to implement a translation function, and then used the &lt;code&gt;MappedPageTable&lt;&#x2f;code&gt; type of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate. We also learned how to create new mappings in the page table and how to create the necessary &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; on top of the memory map passed by the bootloader.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;allocate memory&lt;&#x2f;a&gt; and use various &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;index.html&quot;&gt;collection types&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Advanced Paging</title>
                <pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/advanced-paging/</link>
                <guid>https://os.phil-opp.com/advanced-paging/</guid>
                <description>&lt;p&gt;This post explains techniques to make the physical page table frames accessible to our kernel. It then uses such a technique to implement a function that translates virtual to physical addresses. It also explains how to create new mappings in the page tables.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;5c0fb63f33380fc8596d7166c2ebde03ef3d6726&quot;&gt;here&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt; we learned about the principles of paging and how the 4-level page tables on x86_64 work. We also found out that the bootloader already set up a page table hierarchy for our kernel, which means that our kernel already runs on virtual addresses. This improves safety since illegal memory accesses cause page fault exceptions instead of modifying arbitrary physical memory.&lt;&#x2f;p&gt;
&lt;p&gt;However, it also causes a problem when we try to access the page tables from our kernel because we can&#x27;t directly access the physical addresses that are stored in page table entries or the &lt;code&gt;CR3&lt;&#x2f;code&gt; register. We experienced that problem already &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#accessing-the-page-tables&quot;&gt;at the end of the previous post&lt;&#x2f;a&gt; when we tried to inspect the active page tables.&lt;&#x2f;p&gt;
&lt;p&gt;The next section discusses the problem in detail and provides different approaches to a solution. Afterward, we implement a function that traverses the page table hierarchy in order to translate virtual to physical addresses. Finally, we learn how to create new mappings in the page tables and how to find unused memory frames for creating new page tables.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;dependency-versions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#dependency-versions&quot; aria-label=&quot;Anchor link for: dependency-versions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Dependency Versions&lt;&#x2f;h3&gt;
&lt;p&gt;This post requires version 0.3.12 of the &lt;code&gt;bootloader&lt;&#x2f;code&gt; dependency and version 0.5.0 of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; dependency. You can set the dependency versions in your &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.3.12&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;accessing-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-page-tables&quot; aria-label=&quot;Anchor link for: accessing-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Accessing Page Tables&lt;&#x2f;h2&gt;
&lt;p&gt;Accessing the page tables from our kernel is not as easy as it may seem. To understand the problem let&#x27;s take a look at the example 4-level page table hierarchy of the previous post again:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2f;paging-introduction&#x2f;x86_64-page-table-translation.svg&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The important thing here is that each page entry stores the &lt;em&gt;physical&lt;&#x2f;em&gt; address of the next table. This avoids the need to run a translation for these addresses too, which would be bad for performance and could easily cause endless translation loops.&lt;&#x2f;p&gt;
&lt;p&gt;The problem for us is that we can&#x27;t directly access physical addresses from our kernel since our kernel also runs on top of virtual addresses. For example when we access address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, we access the &lt;em&gt;virtual&lt;&#x2f;em&gt; address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, not the &lt;em&gt;physical&lt;&#x2f;em&gt; address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt; where the level 4 page table is stored. When we want to access the physical address &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, we can only do so through some virtual address that maps to it.&lt;&#x2f;p&gt;
&lt;p&gt;So in order to access page table frames, we need to map some virtual pages to them. There are different ways to create these mappings that all allow us to access arbitrary page table frames:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A simple solution is to &lt;strong&gt;identity map all page tables&lt;&#x2f;strong&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;identity-mapped-page-tables.svg&quot; alt=&quot;A virtual and a physical address space with various virtual pages mapped to the physical frame with the same address&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In this example, we see various identity-mapped page table frames. This way the physical addresses of page tables are also valid virtual addresses so that we can easily access the page tables of all levels starting from the CR3 register.&lt;&#x2f;p&gt;
&lt;p&gt;However, it clutters the virtual address space and makes it more difficult to find continuous memory regions of larger sizes. For example, imagine that we want to create a virtual memory region of size 1000â€¯KiB in the above graphic, e.g. for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory-mapped_file&quot;&gt;memory-mapping a file&lt;&#x2f;a&gt;. We can&#x27;t start the region at &lt;code&gt;28â€¯KiB&lt;&#x2f;code&gt; because it would collide with the already mapped page at &lt;code&gt;1004â€¯MiB&lt;&#x2f;code&gt;. So we have to look further until we find a large enough unmapped area, for example at &lt;code&gt;1008â€¯KiB&lt;&#x2f;code&gt;. This is a similar fragmentation problem as with &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#fragmentation&quot;&gt;segmentation&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Equally, it makes it much more difficult to create new page tables, because we need to find physical frames whose corresponding pages aren&#x27;t already in use. For example, let&#x27;s assume that we reserved the &lt;em&gt;virtual&lt;&#x2f;em&gt; 1000â€¯KiB memory region starting at &lt;code&gt;1008â€¯KiB&lt;&#x2f;code&gt; for our memory-mapped file. Now we can&#x27;t use any frame with a &lt;em&gt;physical&lt;&#x2f;em&gt; address between &lt;code&gt;1000â€¯KiB&lt;&#x2f;code&gt; and &lt;code&gt;2008â€¯KiB&lt;&#x2f;code&gt; anymore, because we can&#x27;t identity map it.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;Alternatively, we could &lt;strong&gt;map the page tables frames only temporarily&lt;&#x2f;strong&gt; when we need to access them. To be able to create the temporary mappings we only need a single identity-mapped level 1 table:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;temporarily-mapped-page-tables.png&quot; alt=&quot;A virtual and a physical address space with an identity mapped level 1 table, which maps its 0th entry to the level 2 table frame, thereby mapping that frame to page with address 0&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The level 1 table in this graphic controls the first 2â€¯MiB of the virtual address space. This is because it is reachable by starting at the CR3 register and following the 0th entry in the level 4, level 3, and level 2 page tables. The entry with index &lt;code&gt;8&lt;&#x2f;code&gt; maps the virtual page at address &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt; to the physical frame at address &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt;, thereby identity mapping the level 1 table itself. The graphic shows this identity-mapping by the horizontal arrow at &lt;code&gt;32â€¯KiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;By writing to the identity-mapped level 1 table, our kernel can create up to 511 temporary mappings (512 minus the entry required for the identity mapping). In the above example, the kernel mapped the 0th entry of the level 1 table to the frame with address &lt;code&gt;24â€¯KiB&lt;&#x2f;code&gt;. This created a temporary mapping of the virtual page at &lt;code&gt;0â€¯KiB&lt;&#x2f;code&gt; to the physical frame of the level 2 page table, indicated by the dashed arrow. Now the kernel can access the level 2 page table by writing to the page starting at &lt;code&gt;0â€¯KiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The process for accessing an arbitrary page table frame with temporary mappings would be:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Search for a free entry in the identity-mapped level 1 table.&lt;&#x2f;li&gt;
&lt;li&gt;Map that entry to the physical frame of the page table that we want to access.&lt;&#x2f;li&gt;
&lt;li&gt;Access the target frame through the virtual page that maps to the entry.&lt;&#x2f;li&gt;
&lt;li&gt;Set the entry back to unused thereby removing the temporary mapping again.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;This approach keeps the virtual address space clean since it reuses the same 512 virtual pages for creating the mappings. The drawback is that it is a bit cumbersome, especially since a new mapping might require modifications of multiple table levels, which means that we would need to repeat the above process multiple times.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;While both of the above approaches work, there is a third technique called &lt;strong&gt;recursive page tables&lt;&#x2f;strong&gt; that combines their advantages: It keeps all page table frames mapped at all times so that no temporary mappings are needed, and also keeps the mapped pages together to avoid fragmentation of the virtual address space. This is the technique that we will use for our implementation, therefore it is described in detail in the following section.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;recursive-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-page-tables&quot; aria-label=&quot;Anchor link for: recursive-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Recursive Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;The idea behind this approach is to map some entry of the level 4 page table to the level 4 table itself. By doing this, we effectively reserve a part of the virtual address space and map all current and future page table frames to that space.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s go through an example to understand how this all works:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;recursive-page-table.png&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory. Entry 511 of the level 4 page is mapped to frame 4KiB, the frame of the level 4 table itself.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The only difference to the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;#accessing-page-tables&quot;&gt;example at the beginning of this post&lt;&#x2f;a&gt; is the additional entry at index &lt;code&gt;511&lt;&#x2f;code&gt; in the level 4 table, which is mapped to physical frame &lt;code&gt;4â€¯KiB&lt;&#x2f;code&gt;, the frame of the level 4 table itself.&lt;&#x2f;p&gt;
&lt;p&gt;By letting the CPU follow this entry on a translation, it doesn&#x27;t reach a level 3 table, but the same level 4 table again. This is similar to a recursive function that calls itself, therefore this table is called a &lt;em&gt;recursive page table&lt;&#x2f;em&gt;. The important thing is that the CPU assumes that every entry in the level 4 table points to a level 3 table, so it now treats the level 4 table as a level 3 table. This works because tables of all levels have the exact same layout on x86_64.&lt;&#x2f;p&gt;
&lt;p&gt;By following the recursive entry one or multiple times before we start the actual translation, we can effectively shorten the number of levels that the CPU traverses. For example, if we follow the recursive entry once and then proceed to the level 3 table, the CPU thinks that the level 3 table is a level 2 table. Going further, it treats the level 2 table as a level 1 table and the level 1 table as the mapped frame. This means that we can now read and write the level 1 page table because the CPU thinks that it is the mapped frame. The graphic below illustrates the 5 translation steps:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;recursive-page-table-access-level-1.png&quot; alt=&quot;The above example 4-level page hierarchy with 5 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Step 1&amp;quot; from level 4 table to level 4 table, &amp;quot;Step 2&amp;quot; from level 4 table to level 3 table, &amp;quot;Step 3&amp;quot; from level 3 table to level 2 table, and &amp;quot;Step 4&amp;quot; from level 2 table to level 1 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Similarly, we can follow the recursive entry twice before starting the translation to reduce the number of traversed levels to two:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;recursive-page-table-access-level-2.png&quot; alt=&quot;The same 4-level page hierarchy with the following 4 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Steps 1&amp;amp;2&amp;quot; from level 4 table to level 4 table, &amp;quot;Step 3&amp;quot; from level 4 table to level 3 table, and &amp;quot;Step 4&amp;quot; from level 3 table to level 2 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s go through it step by step: First, the CPU follows the recursive entry on the level 4 table and thinks that it reaches a level 3 table. Then it follows the recursive entry again and thinks that it reaches a level 2 table. But in reality, it is still on the level 4 table. When the CPU now follows a different entry, it lands on a level 3 table but thinks it is already on a level 1 table. So while the next entry points at a level 2 table, the CPU thinks that it points to the mapped frame, which allows us to read and write the level 2 table.&lt;&#x2f;p&gt;
&lt;p&gt;Accessing the tables of levels 3 and 4 works in the same way. For accessing the level 3 table, we follow the recursive entry three times, tricking the CPU into thinking it is already on a level 1 table. Then we follow another entry and reach a level 3 table, which the CPU treats as a mapped frame. For accessing the level 4 table itself, we just follow the recursive entry four times until the CPU treats the level 4 table itself as mapped frame (in blue in the graphic below).&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;recursive-page-table-access-level-3.png&quot; alt=&quot;The same 4-level page hierarchy with the following 3 arrows: &amp;quot;Step 0&amp;quot; from CR4 to level 4 table, &amp;quot;Steps 1,2,3&amp;quot; from level 4 table to level 4 table, and &amp;quot;Step 4&amp;quot; from level 4 table to level 3 table. In blue the alternative &amp;quot;Steps 1,2,3,4&amp;quot; arrow from level 4 table to level 4 table.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It might take some time to wrap your head around the concept, but it works quite well in practice.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;address-calculation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#address-calculation&quot; aria-label=&quot;Anchor link for: address-calculation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Address Calculation&lt;&#x2f;h4&gt;
&lt;p&gt;We saw that we can access tables of all levels by following the recursive entry once or multiple times before the actual translation. Since the indexes into the tables of the four levels are derived directly from the virtual address, we need to construct special virtual addresses for this technique. Remember, the page table indexes are derived from the address in the following way:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2f;paging-introduction&#x2f;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0â€“12 are the page offset, bits 12â€“21 the level 1 index, bits 21â€“30 the level 2 index, bits 30â€“39 the level 3 index, and bits 39â€“48 the level 4 index&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s assume that we want to access the level 1 page table that maps a specific page. As we learned above, this means that we have to follow the recursive entry one time before continuing with the level 4, level 3, and level 2 indexes. To do that we move each block of the address one block to the right and set the original level 4 index to the index of the recursive entry:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;table-indices-from-address-recursive-level-1.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 1 table frame, bits 12â€“21 the level 2 index, bits 21â€“30 the level 3 index, bits 30â€“39 the level 4 index, and bits 39â€“48 the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;For accessing the level 2 table of that page, we move each index block two blocks to the right and set both the blocks of the original level 4 index and the original level 3 index to the index of the recursive entry:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;table-indices-from-address-recursive-level-2.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 2 table frame, bits 12â€“21 the level 3 index, bits 21â€“30 the level 4 index, and bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Accessing the level 3 table works by moving each block three blocks to the right and using the recursive index for the original level 4, level 3, and level 2 address blocks:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;table-indices-from-address-recursive-level-3.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level 3 table frame, bits 12â€“21 the level 4 index, and bits 21â€“30, bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Finally, we can access the level 4 table by moving each block four blocks to the right and using the recursive index for all address blocks except for the offset:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;table-indices-from-address-recursive-level-4.svg&quot; alt=&quot;Bits 0â€“12 are the offset into the level l table frame and bits 12â€“21, bits 21â€“30, bits 30â€“39 and bits 39â€“48 are the index of the recursive entry&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We can now calculate virtual addresses for the page tables of all four levels. We can even calculate an address that points exactly to a specific page table entry by multiplying its index by 8, the size of a page table entry.&lt;&#x2f;p&gt;
&lt;p&gt;The table below summarizes the address structure for accessing the different kinds of frames:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Virtual Address for &lt;&#x2f;th&gt;&lt;th&gt;Address Structure (&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Octal&quot;&gt;octal&lt;&#x2f;a&gt;)&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Page                &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 1 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 2 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 3 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Level 4 Table Entry &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Whereas &lt;code&gt;AAA&lt;&#x2f;code&gt; is the level 4 index, &lt;code&gt;BBB&lt;&#x2f;code&gt; the level 3 index, &lt;code&gt;CCC&lt;&#x2f;code&gt; the level 2 index, and &lt;code&gt;DDD&lt;&#x2f;code&gt; the level 1 index of the mapped frame, and &lt;code&gt;EEEE&lt;&#x2f;code&gt; the offset into it. &lt;code&gt;RRR&lt;&#x2f;code&gt; is the index of the recursive entry. When an index (three digits) is transformed to an offset (four digits), it is done by multiplying it by 8 (the size of a page table entry). With this offset, the resulting address directly points to the respective page table entry.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;code&gt;SSSSSS&lt;&#x2f;code&gt; are sign extension bits, which means that they are all copies of bit 47. This is a special requirement for valid addresses on the x86_64 architecture. We explained it in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#paging-on-x86&quot;&gt;previous post&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We use &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Octal&quot;&gt;octal&lt;&#x2f;a&gt; numbers for representing the addresses since each octal character represents three bits, which allows us to clearly separate the 9-bit indexes of the different page table levels. This isn&#x27;t possible with the hexadecimal system where each character represents four bits.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;After all this theory we can finally start our implementation. Conveniently, the bootloader not only created page tables for our kernel, but it also created a recursive mapping in the last entry of the level 4 table. The bootloader did this because otherwise there would be a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Chicken_or_the_egg&quot;&gt;chicken or egg problem&lt;&#x2f;a&gt;: We need to access the level 4 table to create a recursive mapping, but we can&#x27;t access it without some kind of mapping.&lt;&#x2f;p&gt;
&lt;p&gt;We already used this recursive mapping &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#accessing-the-page-tables&quot;&gt;at the end of the previous post&lt;&#x2f;a&gt; to access the level 4 table. We did this through the hardcoded address &lt;code&gt;0xffff_ffff_ffff_f000&lt;&#x2f;code&gt;. When we convert this address to &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Octal&quot;&gt;octal&lt;&#x2f;a&gt; and compare it with the above table, we can see that it exactly follows the structure of a level 4 table entry with &lt;code&gt;RRR&lt;&#x2f;code&gt; = &lt;code&gt;0o777&lt;&#x2f;code&gt;, &lt;code&gt;AAAA&lt;&#x2f;code&gt; = 0, and the sign extension bits set to &lt;code&gt;1&lt;&#x2f;code&gt; each:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;structure: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
address:   0o_177777_777_777_777_777_0000
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;With our knowledge about recursive page tables we can now create virtual addresses to access all active page tables. This allows us to create a translation function in software.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Translating Addresses&lt;&#x2f;h3&gt;
&lt;p&gt;As a first step, let&#x27;s create a function that translates a virtual address to a physical address by walking the page table hierarchy:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::PhysAddr;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::PageTable;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Returns the physical address for the given virtual address, or `None` if the
&#x2f;&#x2f;&#x2f; virtual address is not mapped.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate_addr(addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;PhysAddr&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; introduce variables for the recursive index and the sign extension bits
    &#x2f;&#x2f; TODO: Don&amp;#39;t hardcode these values
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; recursive index
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o177777 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;48&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; sign extension

    &#x2f;&#x2f; retrieve the page table indices of the address that we want to translate
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 4 index
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 3 index
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l2_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 2 index
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; l1_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; level 1 index
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o7777&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; calculate the table addresses
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_3_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_2_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_1_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        sign &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(r &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;39&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l4_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;30&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l3_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(l2_idx &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; check that level 4 entry is mapped
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table[l4_idx].addr().is_null() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None;
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; check that level 3 entry is mapped
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_3_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_3_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_3_table[l3_idx].addr().is_null() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None;
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; check that level 2 entry is mapped
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_2_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_2_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_2_table[l2_idx].addr().is_null() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None;
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; check that level 1 entry is mapped and retrieve physical address from it
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_1_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_1_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable) };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_1_table[l1_idx].addr();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_addr.is_null() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None;
    }

    Some(phys_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_offset)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we introduce variables for the recursive index (511 = &lt;code&gt;0o777&lt;&#x2f;code&gt;) and the sign extension bits (which are 1 each). Then we calculate the page table indices and the page offset from the address through bitwise operations as specified in the graphic:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;..&#x2f;paging-introduction&#x2f;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0â€“12 are the page offset, bits 12â€“21 the level 1 index, bits 21â€“30 the level 2 index, bits 30â€“39 the level 3 index, and bits 39â€“48 the level 4 index&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In the next step we calculate the virtual addresses of the four page tables as descripbed in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;#address-calculation&quot;&gt;address calculation&lt;&#x2f;a&gt; section. We transform each of these addresses to &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page_table&#x2f;struct.PageTable.html&quot;&gt;&lt;code&gt;PageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; references later in the function. These transformations are &lt;code&gt;unsafe&lt;&#x2f;code&gt; operations since the compiler can&#x27;t know that these addresses are valid.&lt;&#x2f;p&gt;
&lt;p&gt;After the address calculation, we use the indexing operator to look at the entry in the level 4 table. If that entry is null, there is no level 3 table for this level 4 entry, which means that the &lt;code&gt;addr&lt;&#x2f;code&gt; is not mapped to any physical memory, so we return &lt;code&gt;None&lt;&#x2f;code&gt;. If the entry is not &lt;code&gt;None&lt;&#x2f;code&gt;, we know that a level 3 table exists. We then do the same cast and entry-checking as with the level 4 table.&lt;&#x2f;p&gt;
&lt;p&gt;After we checked the three higher level pages, we can finally read the entry of the level 1 table that tells us the physical frame that the address is mapped to. As the last step, we add the page offset to that address and return it.&lt;&#x2f;p&gt;
&lt;p&gt;If we knew that the address is mapped, we could directly access the level 1 table without looking at the higher level pages first. But since we don&#x27;t know this, we have to check whether the level 1 table exists first, otherwise our function would cause a page fault for unmapped addresses.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Try it out&lt;&#x2f;h4&gt;
&lt;p&gt;We can use our new translation function to translate some virtual addresses in our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize GDT, IDT, PICS

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::translate_addr;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the identity-mapped vga buffer page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some code page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x20010a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some stack page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x57ac_001f_fe48&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    ];

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;addresses {
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, address, translate_addr(address));
    }

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;qemu-translate-addr.png&quot; alt=&quot;0xb8000 -&amp;gt; 0xb8000, 0x20010a -&amp;gt; 0x40010a, 0x57ac001ffe48 -&amp;gt; 0x27be48&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As expected, the identity-mapped address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; translates to the same physical address. The code page and the stack page translate to some arbitrary physical addresses, which depend on how the bootloader created the initial mapping for our kernel.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-recursivepagetable-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-recursivepagetable-type&quot; aria-label=&quot;Anchor link for: the-recursivepagetable-type&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; Type&lt;&#x2f;h4&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2f;code&gt; provides a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;struct.RecursivePageTable.html&quot;&gt;&lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type that implements safe abstractions for various page table operations. The type implements the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.MapperAllSizes.html&quot;&gt;&lt;code&gt;MapperAllSizes&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait, which already contains a &lt;code&gt;translate_addr&lt;&#x2f;code&gt; function that we can use instead of hand-rolling our own. To create a new &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt;, we create a &lt;code&gt;memory::init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{VirtAddr, PhysAddr};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Creates a RecursivePageTable instance from the level 4 address.
&#x2f;&#x2f;&#x2f;
&#x2f;&#x2f;&#x2f; This function is unsafe because it can break memory safety if an invalid
&#x2f;&#x2f;&#x2f; address is passed.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(level_4_table_addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;level_4_table_ptr;
    RecursivePageTable::new(level_4_table).unwrap()
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; type encapsulates the unsafety of the page table walk completely so that we no longer need &lt;code&gt;unsafe&lt;&#x2f;code&gt; to implement our own &lt;code&gt;translate_addr&lt;&#x2f;code&gt; function. The &lt;code&gt;init&lt;&#x2f;code&gt; function needs to be unsafe because the caller has to guarantee that the passed &lt;code&gt;level_4_table_addr&lt;&#x2f;code&gt; is valid.&lt;&#x2f;p&gt;
&lt;p&gt;We can now use the &lt;code&gt;MapperAllSizes::translate_addr&lt;&#x2f;code&gt; function in our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize GDT, IDT, PICS

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::{
        structures::paging::MapperAllSizes,
        VirtAddr,
    };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_177777_777_777_777_777_0000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;addresses {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virt_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::new(address);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; phys_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table.translate_addr(virt_addr);
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, virt_addr, phys_addr);
    }

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;u64&lt;&#x2f;code&gt; for all addresses we now use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;struct.VirtAddr.html&quot;&gt;&lt;code&gt;VirtAddr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;struct.PhysAddr.html&quot;&gt;&lt;code&gt;PhysAddr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; wrapper types to differentiate the two kinds of addresses. In order to be able to call the &lt;code&gt;translate_addr&lt;&#x2f;code&gt; method, we need to import the &lt;code&gt;MapperAllSizes&lt;&#x2f;code&gt; trait.&lt;&#x2f;p&gt;
&lt;p&gt;By using the &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; type, we now have a safe abstraction and clear ownership semantics. This ensures that we can&#x27;t accidentally modify the page table concurrently, because an exclusive borrow of the &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; is needed in order to modify it.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it, we see the same result as with our handcrafted translation function.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;making-unsafe-functions-safer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#making-unsafe-functions-safer&quot; aria-label=&quot;Anchor link for: making-unsafe-functions-safer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Making Unsafe Functions Safer&lt;&#x2f;h4&gt;
&lt;p&gt;Our &lt;code&gt;memory::init&lt;&#x2f;code&gt; function is an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method&quot;&gt;unsafe function&lt;&#x2f;a&gt;, which means that an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block is required for calling it because the caller has to guarantee that certain requirements are met. In our case, the requirement is that the passed address is mapped to the physical frame of the level 4 page table.&lt;&#x2f;p&gt;
&lt;p&gt;The second property of unsafe functions is that their complete body is treated as an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block, which means that it can perform all kinds of unsafe operations without additional unsafe blocks. This is the reason that we didn&#x27;t need an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block for dereferencing the raw &lt;code&gt;level_4_table_ptr&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(level_4_table_addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;level_4_table_ptr; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; &amp;lt;- this operation is unsafe
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;RecursivePageTable::new(level_4_table).unwrap()
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem with this is that we don&#x27;t immediately see which parts are unsafe. For example, we don&#x27;t know whether the &lt;code&gt;RecursivePageTable::new&lt;&#x2f;code&gt; function is unsafe or not without looking at &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;struct.RecursivePageTable.html#method.new&quot;&gt;its definition&lt;&#x2f;a&gt;. This makes it very easy to accidentally do something unsafe without noticing.&lt;&#x2f;p&gt;
&lt;p&gt;To avoid this problem, we can add a safe inner function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(level_4_table_addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Rust currently treats the whole body of unsafe functions as an unsafe
    &#x2f;&#x2f;&#x2f; block, which makes it difficult to see which operations are unsafe. To
    &#x2f;&#x2f;&#x2f; limit the scope of unsafe we use a safe inner function.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_inner(level_4_table_addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; RecursivePageTable&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; PageTable;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; level_4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;level_4_table_ptr };
        RecursivePageTable::new(level_4_table).unwrap()
    }

    init_inner(level_4_table_addr)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block is required again for dereferencing the &lt;code&gt;level_4_table_ptr&lt;&#x2f;code&gt; and we immediately see that this is the only unsafe operations in the function. There is currently an open &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;2585&quot;&gt;RFC&lt;&#x2f;a&gt; to change this unfortunate property of unsafe functions that would allow us to avoid the above boilerplate.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-a-new-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-new-mapping&quot; aria-label=&quot;Anchor link for: creating-a-new-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a new Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;After reading the page tables and creating a translation function, the next step is to create a new mapping in the page table hierarchy.&lt;&#x2f;p&gt;
&lt;p&gt;The difficulty of creating a new mapping depends on the virtual page that we want to map. In the easiest case, the level 1 page table for the page already exists and we just need to write a single entry. In the most difficult case, the page is in a memory region for that no level 3 exists yet so that we need to create new level 3, level 2 and level 1 page tables first.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s start with the simple case and assume that we don&#x27;t need to create new page tables. The bootloader loads itself in the first megabyte of the virtual address space, so we know that a valid level 1 table exists for this region. We can choose any unused page in this memory region for our example mapping, for example, the page at address &lt;code&gt;0x1000&lt;&#x2f;code&gt;. As the target frame we use &lt;code&gt;0xb8000&lt;&#x2f;code&gt;, the frame of the VGA text buffer. This way we can easily test whether our mapping worked.&lt;&#x2f;p&gt;
&lt;p&gt;We implement it in a new &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function in our &lt;code&gt;memory&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;create_example_mapping(
    recursive_page_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; RecursivePageTable,
    frame_allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; impl FrameAllocator&amp;lt;Size4KiB&amp;gt;,
) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::PageTableFlags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Flags;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page: Page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(VirtAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PhysFrame::containing_address(PhysAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Flags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Flags::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; map_to_result &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        recursive_page_table.map_to(page, frame, flags, frame_allocator)
    };
    map_to_result.expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;map_to failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).flush();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The function takes a mutable reference to the &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; because it needs to modify it and a &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; that is explained below. It then uses the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function of the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html&quot;&gt;&lt;code&gt;Mapper&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait to map the page at address &lt;code&gt;0x1000&lt;&#x2f;code&gt; to the physical frame at address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. The function is unsafe because it&#x27;s possible to break memory safety with invalid arguments.&lt;&#x2f;p&gt;
&lt;p&gt;Apart from the &lt;code&gt;page&lt;&#x2f;code&gt; and &lt;code&gt;frame&lt;&#x2f;code&gt; arguments, the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;trait.Mapper.html#tymethod.map_to&quot;&gt;&lt;code&gt;map_to&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function takes two more arguments. The third argument is a set of flags for the page table entry. We set the &lt;code&gt;PRESENT&lt;&#x2f;code&gt; flag because it is required for all valid entries and the &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flag to make the mapped page writable.&lt;&#x2f;p&gt;
&lt;p&gt;The fourth argument needs to be some structure that implements the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;trait.FrameAllocator.html&quot;&gt;&lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait. The &lt;code&gt;map_to&lt;&#x2f;code&gt; method needs this argument because it might need unused frames for creating new page tables. The &lt;code&gt;Size4KiB&lt;&#x2f;code&gt; argument in the trait implementation is needed because the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;struct.Page.html&quot;&gt;&lt;code&gt;Page&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;frame&#x2f;struct.PhysFrame.html&quot;&gt;&lt;code&gt;PhysFrame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; types are &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-00-generics.html&quot;&gt;generic&lt;&#x2f;a&gt; over the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page&#x2f;trait.PageSize.html&quot;&gt;&lt;code&gt;PageSize&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait to work with both standard 4KiB pages and huge 2MiB&#x2f;1GiB pages.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;map_to&lt;&#x2f;code&gt; function can fail, so it returns a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html&quot;&gt;&lt;code&gt;Result&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. Since this is just some example code that does not need to be robust, we just use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html#method.expect&quot;&gt;&lt;code&gt;expect&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; to panic when an error occurs. On success, the function returns a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html&quot;&gt;&lt;code&gt;MapperFlush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type that provides an easy way to flush the newly mapped page from the translation lookaside buffer (TLB) with its &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;mapper&#x2f;struct.MapperFlush.html#method.flush&quot;&gt;&lt;code&gt;flush&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method. Like &lt;code&gt;Result&lt;&#x2f;code&gt;, the type uses the [&lt;code&gt;#[must_use]&lt;&#x2f;code&gt;] attribute to emit a warning when we accidentally forget to use it.&lt;&#x2f;p&gt;
&lt;p&gt;[&lt;code&gt;#[must_use]&lt;&#x2f;code&gt;]: https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;result&#x2f;#results-must-be-used&lt;&#x2f;p&gt;
&lt;p&gt;Since we know that no new page tables are required for the address &lt;code&gt;0x1000&lt;&#x2f;code&gt;, a frame allocator that always returns &lt;code&gt;None&lt;&#x2f;code&gt; suffices. We create such an &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; for testing our mapping function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&#x2f;&#x2f;&#x2f; A FrameAllocator that always returns `None`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EmptyFrameAllocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EmptyFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
        None
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;(If you&#x27;re getting a &#x27;method &lt;code&gt;allocate_frame&lt;&#x2f;code&gt; is not a member of trait &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;&#x27; error, you need to update &lt;code&gt;x86_64&lt;&#x2f;code&gt; to version 0.4.0.)&lt;&#x2f;p&gt;
&lt;p&gt;We can now test the new mapping function in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize GDT, IDT, PICS

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::memory::{create_example_mapping, EmptyFrameAllocator};

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_177777_777_777_777_777_0000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ memory::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LEVEL_4_TABLE_ADDR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };

    create_example_mapping(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; EmptyFrameAllocator);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1900 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).write_volatile(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)};

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We first create the mapping for the page at &lt;code&gt;0x1000&lt;&#x2f;code&gt; by calling our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function with a mutable reference to the &lt;code&gt;RecursivePageTable&lt;&#x2f;code&gt; instance. This maps the page &lt;code&gt;0x1000&lt;&#x2f;code&gt; to the VGA text buffer, so we should see any write to it on the screen.&lt;&#x2f;p&gt;
&lt;p&gt;Then we write the value &lt;code&gt;0xf021_f077_f065_f04e&lt;&#x2f;code&gt; to this page, which represents the string &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on white background. We don&#x27;t write directly to the beginning of the page at &lt;code&gt;0x1000&lt;&#x2f;code&gt; since the top line is directly shifted off the screen by the next &lt;code&gt;println&lt;&#x2f;code&gt;. Instead, we write to offset &lt;code&gt;0x900&lt;&#x2f;code&gt;, which is about in the middle of the screen. As we learned &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#volatile&quot;&gt;in the &lt;em&gt;â€œVGA Text Modeâ€&lt;&#x2f;em&gt; post&lt;&#x2f;a&gt;, writes to the VGA buffer should be volatile, so we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;primitive.pointer.html#method.write_volatile&quot;&gt;&lt;code&gt;write_volatile&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it in QEMU, we see the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;advanced-paging&#x2f;qemu-new-mapping.png&quot; alt=&quot;QEMU printing &amp;quot;It did not crash!&amp;quot; with four completely white cells in the middle of the screen&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on the screen is by our write to &lt;code&gt;0x1900&lt;&#x2f;code&gt;, which means that we successfully created a new mapping in the page tables.&lt;&#x2f;p&gt;
&lt;p&gt;This only worked because there was already a level 1 table for mapping page &lt;code&gt;0x1000&lt;&#x2f;code&gt;. When we try to map a page for that no level 1 table exists yet, the &lt;code&gt;map_to&lt;&#x2f;code&gt; function fails because it tries to allocate frames from the &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt; for creating new page tables. We can see that happen when we try to map page &lt;code&gt;0xdeadbeaf000&lt;&#x2f;code&gt; instead of &lt;code&gt;0x1000&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;create_example_mapping(â€¦) {
    [â€¦]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page: Page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(VirtAddr::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    [â€¦]
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf900 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).write_volatile(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)};
    [â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, a panic with the following error message occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panicked at &amp;#39;map_to failed: FrameAllocationFailed&amp;#39;, &#x2f;â€¦&#x2f;result.rs:999:5
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To map pages that don&#x27;t have a level 1 page table yet we need to create a proper &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;. But how do we know which frames are unused and how much physical memory is available?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;boot-information&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#boot-information&quot; aria-label=&quot;Anchor link for: boot-information&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Boot Information&lt;&#x2f;h3&gt;
&lt;p&gt;The amount of physical memory and the memory regions reserved by devices like the VGA hardware vary between different machines. Only the BIOS or UEFI firmware knows exactly which memory regions can be used by the operating system and which regions are reserved. Both firmware standards provide functions to retrieve the memory map, but they can only be called very early in the boot process. For this reason, the bootloader already queries this and other information from the firmware.&lt;&#x2f;p&gt;
&lt;p&gt;To communicate this information to our kernel, the bootloader passes a reference to a boot information structure as an argument when calling our &lt;code&gt;_start&lt;&#x2f;code&gt; function. Right now we don&#x27;t have this argument declared in our function, so it is ignored. Let&#x27;s add it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::bootinfo::BootInfo;

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new argument
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.3.11&#x2f;bootloader&#x2f;bootinfo&#x2f;struct.BootInfo.html&quot;&gt;&lt;code&gt;BootInfo&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct is still in an early stage, so expect some breakage when updating to future &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;cargo&#x2f;reference&#x2f;specifying-dependencies.html#caret-requirements&quot;&gt;semver-incompatible&lt;&#x2f;a&gt; bootloader versions. It currently has the three fields &lt;code&gt;p4_table_addr&lt;&#x2f;code&gt;, &lt;code&gt;memory_map&lt;&#x2f;code&gt;, and &lt;code&gt;package&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;p4_table_addr&lt;&#x2f;code&gt; field contains the recursive virtual address of the level 4 page table. By using this field we can avoid hardcoding the address &lt;code&gt;0o_177777_777_777_777_777_0000&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;memory_map&lt;&#x2f;code&gt; field is most interesting to us since it contains a list of all memory regions and their type (i.e. unused, reserved, or other).&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;package&lt;&#x2f;code&gt; field is an in-progress feature to bundle additional data with the bootloader. The implementation is not finished, so we can ignore this field for now.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Before we use the &lt;code&gt;memory_map&lt;&#x2f;code&gt; field to create a proper &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;, we want to ensure that we can&#x27;t use a &lt;code&gt;boot_info&lt;&#x2f;code&gt; argument of the wrong type.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-entry-point-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-entry-point-macro&quot; aria-label=&quot;Anchor link for: the-entry-point-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;entry_point&lt;&#x2f;code&gt; Macro&lt;&#x2f;h4&gt;
&lt;p&gt;Since our &lt;code&gt;_start&lt;&#x2f;code&gt; function is called externally from the bootloader, no checking of our function signature occurs. This means that we could let it take arbitrary arguments without any compilation errors, but it would fail or cause undefined behavior at runtime.&lt;&#x2f;p&gt;
&lt;p&gt;To make sure that the entry point function has always the correct signature that the bootloader expects, the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate provides an &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.3.12&#x2f;bootloader&#x2f;macro.entry_point.html&quot;&gt;&lt;code&gt;entry_point&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; macro that provides a type-checked way to define a Rust function as the entry point. Let&#x27;s rewrite our entry point function to use this macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::{bootinfo::BootInfo, entry_point};

entry_point!(kernel_main);

#[cfg(not(test))]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize GDT, IDT, PICS

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        memory::init(boot_info.p4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    };

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create and test example mapping

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We no longer need to use &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2f;code&gt; or &lt;code&gt;no_mangle&lt;&#x2f;code&gt; for our entry point, as the macro defines the real lower level &lt;code&gt;_start&lt;&#x2f;code&gt; entry point for us. The &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function is now a completely normal Rust function, so we can choose an arbitrary name for it. The important thing is that it is type-checked so that a compilation error occurs when we now try to modify the function signature in any way, for example adding an argument or changing the argument type.&lt;&#x2f;p&gt;
&lt;p&gt;Note that we now pass &lt;code&gt;boot_info.p4_table_addr&lt;&#x2f;code&gt; instead of a hardcoded address to our &lt;code&gt;memory::init&lt;&#x2f;code&gt;. Thus our code continues to work even if a future version of the bootloader chooses a different entry of the level 4 page table for the recursive mapping.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;allocating-frames&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-frames&quot; aria-label=&quot;Anchor link for: allocating-frames&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocating Frames&lt;&#x2f;h3&gt;
&lt;p&gt;Now that we have access to the memory map through the boot information we can create a proper frame allocator on top. We start with a generic skeleton:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator&amp;lt;I&amp;gt; where I: Iterator&amp;lt;Item = PhysFrame&amp;gt; {
    frames: I,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;I&amp;gt; FrameAllocator&amp;lt;Size4KiB&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInfoFrameAllocator&amp;lt;I&amp;gt;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; I: Iterator&amp;lt;Item = PhysFrame&amp;gt;
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;PhysFrame&amp;gt; {
        self.frames.next()
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;frames&lt;&#x2f;code&gt; field can be initialized with an arbitrary &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; of frames. This allows us to just delegate &lt;code&gt;alloc&lt;&#x2f;code&gt; calls to the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#tymethod.next&quot;&gt;&lt;code&gt;Iterator::next&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method.&lt;&#x2f;p&gt;
&lt;p&gt;The initialization of the &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt; happens in a new &lt;code&gt;init_frame_allocator&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootloader::bootinfo::{MemoryMap, MemoryRegionType};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Create a FrameAllocator from the passed memory map
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_frame_allocator(
    memory_map: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryMap,
) -&amp;gt; BootInfoFrameAllocator&amp;lt;impl Iterator&amp;lt;Item = PhysFrame&amp;gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; get usable regions from memory map
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; regions &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map
        .iter()
        .filter(|r| r.region_type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;MemoryRegionType::Usable);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; map each region to its address range
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr_ranges &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; regions.map(|r| r.range.start_addr()&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;r.range.end_addr());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; transform to an iterator of frame start addresses
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_addresses &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr_ranges.flat_map(|r| r.into_iter().step_by(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create `PhysFrame` types from the start addresses
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frames &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_addresses.map(|addr| {
        PhysFrame::containing_address(PhysAddr::new(addr))
    });

    BootInfoFrameAllocator { frames }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function uses iterator combinator methods to transform the initial &lt;code&gt;MemoryMap&lt;&#x2f;code&gt; into an iterator of usable physical frames:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;First, we call the &lt;code&gt;iter&lt;&#x2f;code&gt; method to convert the memory map to an iterator of &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bootloader&#x2f;0.3.12&#x2f;bootloader&#x2f;bootinfo&#x2f;struct.MemoryRegion.html&quot;&gt;&lt;code&gt;MemoryRegion&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;s. Then we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.filter&quot;&gt;&lt;code&gt;filter&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to skip any reserved or otherwise unavailable regions. The bootloader updates the memory map for all the mappings it creates, so frames that are used by our kernel (code, data or stack) or to store the boot information are already marked as &lt;code&gt;InUse&lt;&#x2f;code&gt; or similar. Thus we can be sure that &lt;code&gt;Usable&lt;&#x2f;code&gt; frames are not used somewhere else.&lt;&#x2f;li&gt;
&lt;li&gt;In the second step, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.map&quot;&gt;&lt;code&gt;map&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; combinator and Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;ops&#x2f;struct.Range.html&quot;&gt;range syntax&lt;&#x2f;a&gt; to transform our iterator of memory regions to an iterator of address ranges.&lt;&#x2f;li&gt;
&lt;li&gt;The third step is the most complicated: We convert each range to an iterator through the &lt;code&gt;into_iter&lt;&#x2f;code&gt; method and then choose every 4096th address using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.step_by&quot;&gt;&lt;code&gt;step_by&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. Since 4096 bytes (= 4 KiB) is the page size, we get the start address of each frame. The bootloader page aligns all usable memory areas so that we don&#x27;t need any alignment or rounding code here. By using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.flat_map&quot;&gt;&lt;code&gt;flat_map&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instead of &lt;code&gt;map&lt;&#x2f;code&gt;, we get an &lt;code&gt;Iterator&amp;lt;Item = u64&amp;gt;&lt;&#x2f;code&gt; instead of an &lt;code&gt;Iterator&amp;lt;Item = Iterator&amp;lt;Item = u64&amp;gt;&amp;gt;&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;In the final step, we convert the start addresses to &lt;code&gt;PhysFrame&lt;&#x2f;code&gt; types to construct the desired &lt;code&gt;Iterator&amp;lt;Item = PhysFrame&amp;gt;&lt;&#x2f;code&gt;. We then use this iterator to create and return a new &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;We can now modify our &lt;code&gt;kernel_main&lt;&#x2f;code&gt; function to pass a &lt;code&gt;BootInfoFrameAllocator&lt;&#x2f;code&gt; instance instead of an &lt;code&gt;EmptyFrameAllocator&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_main(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; BootInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize GDT, IDT, PICS

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::paging::{PageTable, RecursivePageTable};

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        memory::init(boot_info.p4_table_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init_frame_allocator(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;boot_info.memory_map);

    blog_os::memory::create_example_mapping(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; recursive_page_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf900 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).write_volatile(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf021_f077_f065_f04e&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)};

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the mapping succeeds and we see the black-on-white &lt;em&gt;&amp;quot;New!&amp;quot;&lt;&#x2f;em&gt; on the screen again. Behind the scenes, the &lt;code&gt;map_to&lt;&#x2f;code&gt; method creates the missing page tables in the following way:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Allocate an unused frame from the passed &lt;code&gt;frame_allocator&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;Map the entry of the higher level table to that frame. Now the frame is accessible through the recursive page table.&lt;&#x2f;li&gt;
&lt;li&gt;Zero the frame to create a new, empty page table.&lt;&#x2f;li&gt;
&lt;li&gt;Continue with the next table level.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;While our &lt;code&gt;create_example_mapping&lt;&#x2f;code&gt; function is just some example code, we are now able to create new mappings for arbitrary pages. This will be essential for allocating memory or implementing multithreading in future posts.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we learned how a recursive level 4 table entry can be used to map all page table frames to calculatable virtual addresses. We used this technique to implement an address translation function and to create a new mapping in the page tables.&lt;&#x2f;p&gt;
&lt;p&gt;We saw that the creation of new mappings requires unused frames for creating new page tables. Such a frame allocator can be implemented on top of the boot information structure that the bootloader passes to our kernel.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The next post will create a heap memory region for our kernel, which will allow us to &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;allocate memory&lt;&#x2f;a&gt; and use various &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;alloc&#x2f;collections&#x2f;index.html&quot;&gt;collection types&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Introduction to Paging</title>
                <pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/paging-introduction/</link>
                <guid>https://os.phil-opp.com/paging-introduction/</guid>
                <description>&lt;p&gt;This post introduces &lt;em&gt;paging&lt;&#x2f;em&gt;, a very common memory management scheme that we will also use for our operating system. It explains why memory isolation is needed, how &lt;em&gt;segmentation&lt;&#x2f;em&gt; works, what &lt;em&gt;virtual memory&lt;&#x2f;em&gt; is, and how paging solves memory fragmentation issues. It also explores the layout of multilevel page tables on the x86_64 architecture.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-08&quot;&gt;&lt;code&gt;post-08&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;memory-protection&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-protection&quot; aria-label=&quot;Anchor link for: memory-protection&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Memory Protection&lt;&#x2f;h2&gt;
&lt;p&gt;One main task of an operating system is to isolate programs from each other. Your web browser shouldn&#x27;t be able to interfere with your text editor, for example. To achieve this goal, operating systems utilize hardware functionality to ensure that memory areas of one process are not accessible by other processes. There are different approaches, depending on the hardware and the OS implementation.&lt;&#x2f;p&gt;
&lt;p&gt;As an example, some ARM Cortex-M processors (used for embedded systems) have a &lt;a href=&quot;https:&#x2f;&#x2f;developer.arm.com&#x2f;docs&#x2f;ddi0337&#x2f;e&#x2f;memory-protection-unit&#x2f;about-the-mpu&quot;&gt;&lt;em&gt;Memory Protection Unit&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; (MPU), which allows you to define a small number (e.g. 8) of memory regions with different access permissions (e.g. no access, read-only, read-write). On each memory access the MPU ensures that the address is in a region with correct access permissions and throws an exception otherwise. By changing the regions and access permissions on each process switch, the operating system can ensure that each process only accesses its own memory, and thus isolate processes from each other.&lt;&#x2f;p&gt;
&lt;p&gt;On x86, the hardware supports two different approaches to memory protection: &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_memory_segmentation&quot;&gt;segmentation&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Virtual_memory#Paged_virtual_memory&quot;&gt;paging&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;segmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#segmentation&quot; aria-label=&quot;Anchor link for: segmentation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Segmentation&lt;&#x2f;h2&gt;
&lt;p&gt;Segmentation was already introduced in 1978, originally to increase the amount of addressable memory. The situation back then was that CPUs only used 16-bit addresses, which limited the amount of addressable memory to 64KiB. To make more than these 64KiB accessible, additional segment registers were introduced, each containing an offset address. The CPU automatically added this offset on each memory access, so that up to 1MiB of memory were accessible.&lt;&#x2f;p&gt;
&lt;p&gt;The segment register is chosen automatically by the CPU, depending on the kind of memory access: For fetching instructions the code segment &lt;code&gt;CS&lt;&#x2f;code&gt; is used and for stack operations (push&#x2f;pop) the stack segment &lt;code&gt;SS&lt;&#x2f;code&gt; is used. Other instructions use data segment &lt;code&gt;DS&lt;&#x2f;code&gt; or the extra segment &lt;code&gt;ES&lt;&#x2f;code&gt;. Later two additional segment registers &lt;code&gt;FS&lt;&#x2f;code&gt; and &lt;code&gt;GS&lt;&#x2f;code&gt; were added, which can be used freely.&lt;&#x2f;p&gt;
&lt;p&gt;In the first version of segmentation, the segment registers directly contained the offset and no access control was performed. This was changed later with the introduction of the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_memory_segmentation#Protected_mode&quot;&gt;&lt;em&gt;protected mode&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. When the CPU runs in this mode, the segment descriptors contain an index into a local or global &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Global_Descriptor_Table&quot;&gt;&lt;em&gt;descriptor table&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;, which contains â€“ in addition to an offset address â€“ the segment size and access permissions. By loading separate global&#x2f;local descriptor tables for each process that confine memory accesses to the process&#x27;s own memory areas, the OS can isolate processes from each other.&lt;&#x2f;p&gt;
&lt;p&gt;By modifying the memory addresses before the actual access, segmentation already employed a technique that is now used almost everywhere: &lt;em&gt;virtual memory&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;virtual-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#virtual-memory&quot; aria-label=&quot;Anchor link for: virtual-memory&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Virtual Memory&lt;&#x2f;h3&gt;
&lt;p&gt;The idea behind virtual memory is to abstract away the memory addresses from the underlying physical storage device. Instead of directly accessing the storage device, a translation step is performed first. For segmentation, the translation step is to add the offset address of the active segment. Imagine a program accessing memory address &lt;code&gt;0x1234000&lt;&#x2f;code&gt; in a segment with offset &lt;code&gt;0x1111000&lt;&#x2f;code&gt;: The address that is really accessed is &lt;code&gt;0x2345000&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To differentiate the two address types, addresses before the translation are called &lt;em&gt;virtual&lt;&#x2f;em&gt; and addresses after the translation are called &lt;em&gt;physical&lt;&#x2f;em&gt;. One important difference between these two kinds of addresses is that physical addresses are unique and always refer to the same, distinct memory location. Virtual addresses on the other hand depend on the translation function. It is entirely possible that two different virtual addresses refer to the same physical address. Also, identical virtual addresses can refer to different physical addresses when they use different translation functions.&lt;&#x2f;p&gt;
&lt;p&gt;An example where this property is useful is running the same program twice in parallel:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;segmentation-same-program-twice.svg&quot; alt=&quot;Two virtual address spaces with address 0â€“150, one translated to 100â€“250, the other to 300â€“450&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Here the same program runs twice, but with different translation functions. The first instance has an segment offset of 100, so that its virtual addresses 0â€“150 are translated to the physical addresses 100â€“250. The second instance has offset 300, which translates its virtual addresses  0â€“150 to physical addresses 300â€“450. This allows both programs to run the same code and use the same virtual addresses without interfering with each other.&lt;&#x2f;p&gt;
&lt;p&gt;Another advantage is that programs can be placed at arbitrary physical memory locations now, even if they use completely different virtual addresses. Thus, the OS can utilize the full amount of available memory without needing to recompile programs.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fragmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fragmentation&quot; aria-label=&quot;Anchor link for: fragmentation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fragmentation&lt;&#x2f;h3&gt;
&lt;p&gt;The differentiation between virtual and physical addresses makes segmentation really powerful. However, it has the problem of fragmentation. As an example, imagine that we want to run a third copy of the program we saw above:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;segmentation-fragmentation.svg&quot; alt=&quot;Three virtual address spaces, but there is not enough continuous space for the third&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;There is no way to map the third instance of the program to virtual memory without overlapping, even though there is more than enough free memory available. The problem is that we need &lt;em&gt;continuous&lt;&#x2f;em&gt; memory and can&#x27;t use the small free chunks.&lt;&#x2f;p&gt;
&lt;p&gt;One way to combat this fragmentation is to pause execution, move the used parts of the memory closer together, update the translation, and then resume execution:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;segmentation-fragmentation-compacted.svg&quot; alt=&quot;Three virtual address spaces after defragmentation&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Now there is enough continuous space to start the third instance of our program.&lt;&#x2f;p&gt;
&lt;p&gt;The disadvantage of this defragmentation process is that is needs to copy large amounts of memory which decreases performance. It also needs to be done regularly before the memory becomes too fragmented. This makes performance unpredictable, since programs are paused at random times and might become unresponsive.&lt;&#x2f;p&gt;
&lt;p&gt;The fragmentation problem is one of the reasons that segmentation is no longer used by most systems. In fact, segmentation is not even supported in 64-bit mode on x86 anymore. Instead &lt;em&gt;paging&lt;&#x2f;em&gt; is used, which completely avoids the fragmentation problem.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Paging&lt;&#x2f;h2&gt;
&lt;p&gt;The idea is to divide both the virtual and the physical memory space into small, fixed-size blocks. The blocks of the virtual memory space are called &lt;em&gt;pages&lt;&#x2f;em&gt; and the blocks of the physical address space are called &lt;em&gt;frames&lt;&#x2f;em&gt;. Each page can be individually mapped to a frame, which makes it possible to split larger memory regions across non-continuous physical frames.&lt;&#x2f;p&gt;
&lt;p&gt;The advantage of this becomes visible if we recap the example of the fragmented memory space, but use paging instead of segmentation this time:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;paging-fragmentation.svg&quot; alt=&quot;With paging the third program instance can be split across many smaller physical areas&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In this example we have a page size of 50 bytes, which means that each of our memory regions is split across three pages. Each page is mapped to a frame individually, so a continuous virtual memory region can be mapped to non-continuous physical frames. This allows us to start the third instance of the program without performing any defragmentation before.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;hidden-fragmentation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hidden-fragmentation&quot; aria-label=&quot;Anchor link for: hidden-fragmentation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hidden Fragmentation&lt;&#x2f;h3&gt;
&lt;p&gt;Compared to segmentation, paging uses lots of small, fixed sized memory regions instead of a few large, variable sized regions. Since every frame has the same size, there are no frames that are too small to be used so that no fragmentation occurs.&lt;&#x2f;p&gt;
&lt;p&gt;Or it &lt;em&gt;seems&lt;&#x2f;em&gt; like no fragmentation occurs. There is still some hidden kind of fragmentation, the so-called &lt;em&gt;internal fragmentation&lt;&#x2f;em&gt;. Internal fragmentation occurs because not every memory region is an exact multiple of the page size. Imagine a program of size 101 in the above example: It would still need three pages of size 50, so it would occupy 49 bytes more than needed. To differentiate the two types of fragmentation, the kind of fragmentation that happens when using segmentation is called &lt;em&gt;external fragmentation&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Internal fragmentation is unfortunate, but often better than the external fragmentation that occurs with segmentation. It still wastes memory, but does not require defragmentation and makes the amount of fragmentation predictable (on average half a page per memory region).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-tables&quot; aria-label=&quot;Anchor link for: page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;We saw that each of the potentially millions of pages is individually mapped to a frame. This mapping information needs to be stored somewhere. Segmentation uses an individual segment selector register for each active memory region, which is not possible for paging since there are way more pages than registers. Instead paging uses a table structure called &lt;em&gt;page table&lt;&#x2f;em&gt; to store the mapping information.&lt;&#x2f;p&gt;
&lt;p&gt;For our above example the page tables would look like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;paging-page-tables.svg&quot; alt=&quot;Three page tables, one for each program instance. For instance 1 the mapping is 0-&amp;gt;100, 50-&amp;gt;150, 100-&amp;gt;200. For instance 2 it is 0-&amp;gt;300, 50-&amp;gt;350, 100-&amp;gt;400. For instance 3 it is 0-&amp;gt;250, 50-&amp;gt;450, 100-&amp;gt;500.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that each program instance has its own page table. A pointer to the currently active table is stored in a special CPU register. On &lt;code&gt;x86&lt;&#x2f;code&gt;, this register is called &lt;code&gt;CR3&lt;&#x2f;code&gt;. It is the job of the operating system to load this register with the pointer to the correct page table before running each program instance.&lt;&#x2f;p&gt;
&lt;p&gt;On each memory access, the CPU reads the table pointer from the register and looks up the mapped frame for the accessed page in the table. This is entirely done in hardware and completely transparent to the running program. To speed up the translation process, many CPU architectures have a special cache that remembers the results of the last translations.&lt;&#x2f;p&gt;
&lt;p&gt;Depending on the architecture, page table entries can also store attributes such as access permissions in a flags field. In the above example, the &amp;quot;r&#x2f;w&amp;quot; flag makes the page both readable and writable.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;multilevel-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multilevel-page-tables&quot; aria-label=&quot;Anchor link for: multilevel-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Multilevel Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;The simple page tables we just saw have a problem in larger address spaces: they waste memory. For example, imagine a program that uses the four virtual pages &lt;code&gt;0&lt;&#x2f;code&gt;, &lt;code&gt;1_000_000&lt;&#x2f;code&gt;, &lt;code&gt;1_000_050&lt;&#x2f;code&gt;, and &lt;code&gt;1_000_100&lt;&#x2f;code&gt; (we use &lt;code&gt;_&lt;&#x2f;code&gt; as a thousands separator):&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;single-level-page-table.svg&quot; alt=&quot;Page 0 mapped to frame 0 and pages 1_000_000â€“1_000_150 mapped to frames 100â€“250&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It only needs 4 physical frames, but the page table has over a million entries. We can&#x27;t omit the empty entries because then the CPU would no longer be able to jump directly to the correct entry in the translation process (e.g. it is no longer guaranteed that the fourth page uses the fourth entry).&lt;&#x2f;p&gt;
&lt;p&gt;To reduce the wasted memory, we can use a &lt;strong&gt;two-level page table&lt;&#x2f;strong&gt;. The idea is that we use different page tables for different address regions. An additional table called &lt;em&gt;level 2&lt;&#x2f;em&gt; page table contains the mapping between address regions and (level 1) page tables.&lt;&#x2f;p&gt;
&lt;p&gt;This is best explained by an example. Let&#x27;s define that each level 1 page table is responsible for a region of size &lt;code&gt;10_000&lt;&#x2f;code&gt;. Then the following tables would exist for the above example mapping:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;multilevel-page-table.svg&quot; alt=&quot;Page 0 points to entry 0 of the level 2 page table, which points to the level 1 page table T1. The first entry of T1 points to frame 0, the other entries are empty. Pages 1_000_000â€“1_000_150 point to the 100th entry of the level 2 page table, which points to a different level 1 page table T2. The first three entries of T2 point to frames 100â€“250, the other entries are empty.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Page 0 falls into the first &lt;code&gt;10_000&lt;&#x2f;code&gt; byte region, so it uses the first entry of the level 2 page table. This entry points to level 1 page table T1, which specifies that page &lt;code&gt;0&lt;&#x2f;code&gt; points to frame &lt;code&gt;0&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The pages &lt;code&gt;1_000_000&lt;&#x2f;code&gt;, &lt;code&gt;1_000_050&lt;&#x2f;code&gt;, and &lt;code&gt;1_000_100&lt;&#x2f;code&gt; all fall into the 100th &lt;code&gt;10_000&lt;&#x2f;code&gt; byte region, so they use the 100th entry of the level 2 page table. This entry points at a different level 1 page table T2, which maps the three pages to frames &lt;code&gt;100&lt;&#x2f;code&gt;, &lt;code&gt;150&lt;&#x2f;code&gt;, and &lt;code&gt;200&lt;&#x2f;code&gt;. Note that the page address in level 1 tables does not include the region offset, so e.g. the entry for page &lt;code&gt;1_000_050&lt;&#x2f;code&gt; is just &lt;code&gt;50&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We still have 100 empty entries in the level 2 table, but much fewer than the million empty entries before. The reason for this savings is that we don&#x27;t need to create level 1 page tables for the unmapped memory regions between &lt;code&gt;10_000&lt;&#x2f;code&gt; and &lt;code&gt;1_000_000&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The principle of two-level page tables can be extended to three, four, or more levels. Then the page table register points at the highest level table, which points to the next lower level table, which points to the next lower level, and so on. The level 1 page table then points at the mapped frame. The principle in general is called a &lt;em&gt;multilevel&lt;&#x2f;em&gt; or &lt;em&gt;hierarchical&lt;&#x2f;em&gt; page table.&lt;&#x2f;p&gt;
&lt;p&gt;Now that we know how paging and multilevel page tables works, we can look at how paging is implemented in the x86_64 architecture (we assume in the following that the CPU runs in 64-bit mode).&lt;&#x2f;p&gt;
&lt;h2 id=&quot;paging-on-x86-64&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging-on-x86-64&quot; aria-label=&quot;Anchor link for: paging-on-x86-64&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Paging on x86_64&lt;&#x2f;h2&gt;
&lt;p&gt;The x86_64 architecture uses a 4-level page table and a page size of 4KiB. Each page table, independent of the level, has a fixed size of 512 entries. Each entry has a size of 8 bytes, so each table is 512 * 8B = 4KiB large and thus fits exactly into one page.&lt;&#x2f;p&gt;
&lt;p&gt;The page table index for level is derived directly from the virtual address:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;x86_64-table-indices-from-address.svg&quot; alt=&quot;Bits 0â€“12 are the page offset, bits 12â€“21 the level 1 index, bits 21â€“30 the level 2 index, bits 30â€“39 the level 3 index, and bits 39â€“48 the level 4 index&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that each table index consists of 9 bits, which makes sense because each table has 2^9 = 512 entries. The lowest 12 bits are the offset in the 4KiB page (2^12 bytes = 4KiB). Bits 48 to 64 are discarded, which means that x86_64 is not really 64-bit since it only supports 48-bit addresses. There are plans to extend the address size to 57 bits through a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_5-level_paging&quot;&gt;5-level page table&lt;&#x2f;a&gt;, but no processor that supports this feature exists yet.&lt;&#x2f;p&gt;
&lt;p&gt;Even though bits 48 to 64 are discarded, they can&#x27;t be set to arbitrary values. Instead all bits in this range have to be copies of bit 47 in order to keep addresses unique and allow future extensions like the 5-level page table. This is called &lt;em&gt;sign-extension&lt;&#x2f;em&gt; because it&#x27;s very similar to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Two&amp;#x27;s_complement#Sign_extension&quot;&gt;sign extension in two&#x27;s complement&lt;&#x2f;a&gt;. When an address is not correctly sign-extended, the CPU throws an exception.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;example-translation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#example-translation&quot; aria-label=&quot;Anchor link for: example-translation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Example Translation&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s go through an example to understand how the translation process works in detail:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;x86_64-page-table-translation.svg&quot; alt=&quot;An example 4-level page hierarchy with each page table shown in physical memory&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The physical address of the currently active level 4 page table, which is the root of the 4-level page table, is stored in the &lt;code&gt;CR3&lt;&#x2f;code&gt; register. Each page table entry then points to the physical frame of the next level table. The entry of the level 1 table then points to the mapped frame. Note that all addresses in the page tables are physical instead of virtual, because otherwise the CPU would need to translate those addresses too (which could cause a never-ending recursion).&lt;&#x2f;p&gt;
&lt;p&gt;The above page table hierarchy maps two pages (in blue). From the page table indices we can deduce that the virtual addresses of these two pages are &lt;code&gt;0x803FE7F000&lt;&#x2f;code&gt; and &lt;code&gt;0x803FE00000&lt;&#x2f;code&gt;. Let&#x27;s see what happens when the program tries to read from address &lt;code&gt;0x803FE7F5CE&lt;&#x2f;code&gt;. First, we convert the address to binary and determine the page table indices and the page offset for the address:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;x86_64-page-table-translation-addresses.png&quot; alt=&quot;The sign extension bits are all 0, the level 4 index is 1, the level 3 index is 0, the level 2 index is 511, the level 1 index is 127, and the page offset is 0x5ce&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;With these indices, we can now walk the page table hierarchy to determine the mapped frame for the address:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;We start by reading the address of the level 4 table out of the &lt;code&gt;CR3&lt;&#x2f;code&gt; register.&lt;&#x2f;li&gt;
&lt;li&gt;The level 4 index is 1, so we look at the entry with index 1 of that table, which tells us that the level 3 table is stored at address 16KiB.&lt;&#x2f;li&gt;
&lt;li&gt;We load the level 3 table from that address and look at the entry with index 0, which points us to the level 2 table at 24KiB.&lt;&#x2f;li&gt;
&lt;li&gt;The level 2 index is 511, so we look at the last entry of that page to find out the address of the level 1 table.&lt;&#x2f;li&gt;
&lt;li&gt;Through the entry with index 127 of the level 1 table we finally find out that the page is mapped to frame 12KiB, or 0xc000 in hexadecimal.&lt;&#x2f;li&gt;
&lt;li&gt;The final step is to add the page offset to the frame address to get the physical address 0xc000 + 0x5ce = 0xc5ce.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;x86_64-page-table-translation-steps.svg&quot; alt=&quot;The same example 4-level page hierarchy with 5 additional arrows: &amp;quot;Step 0&amp;quot; from the CR3 register to the level 4 table, &amp;quot;Step 1&amp;quot; from the level 4 entry to the level 3 table, &amp;quot;Step 2&amp;quot; from the level 3 entry to the level 2 table, &amp;quot;Step 3&amp;quot; from the level 2 entry to the level 1 table, and &amp;quot;Step 4&amp;quot; from the level 1 table to the mapped frames.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The permissions for the page in the level 1 table are &lt;code&gt;r&lt;&#x2f;code&gt;, which means read-only. The hardware enforces these permissions and would throw an exception if we tried to write to that page. Permissions in higher level pages restrict the possible permissions in lower level, so if we set the level 3 entry to read-only, no pages that use this entry can be writable, even if lower levels specify read&#x2f;write permissions.&lt;&#x2f;p&gt;
&lt;p&gt;It&#x27;s important to note that even though this example used only a single instance of each table, there are typically multiple instances of each level in each address space. At maximum, there are:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;one level 4 table,&lt;&#x2f;li&gt;
&lt;li&gt;512 level 3 tables (because the level 4 table has 512 entries),&lt;&#x2f;li&gt;
&lt;li&gt;512 * 512 level 2 tables (because each of the 512 level 3 tables has 512 entries), and&lt;&#x2f;li&gt;
&lt;li&gt;512 * 512 * 512 level 1 tables (512 entries for each level 2 table).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;page-table-format&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-format&quot; aria-label=&quot;Anchor link for: page-table-format&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Table Format&lt;&#x2f;h3&gt;
&lt;p&gt;Page tables on the x86_64 architecture are basically an array of 512 entries. In Rust syntax:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[repr(align(4096))]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageTable {
    entries: [PageTableEntry; 512],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;As indicated by the &lt;code&gt;repr&lt;&#x2f;code&gt; attribute, page tables need to be page aligned, i.e. aligned on a 4KiB boundary. This requirement guarantees that a page table always fills a complete page and allows an optimization that makes entries very compact.&lt;&#x2f;p&gt;
&lt;p&gt;Each entry is 8 bytes (64 bits) large and has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s) &lt;&#x2f;th&gt;&lt;th&gt;Name &lt;&#x2f;th&gt;&lt;th&gt;Meaning&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0 &lt;&#x2f;td&gt;&lt;td&gt;present &lt;&#x2f;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;1 &lt;&#x2f;td&gt;&lt;td&gt;writable &lt;&#x2f;td&gt;&lt;td&gt;it&#x27;s allowed to write to this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;2 &lt;&#x2f;td&gt;&lt;td&gt;user accessible &lt;&#x2f;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3 &lt;&#x2f;td&gt;&lt;td&gt;write through caching &lt;&#x2f;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;4 &lt;&#x2f;td&gt;&lt;td&gt;disable cache &lt;&#x2f;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;5 &lt;&#x2f;td&gt;&lt;td&gt;accessed &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;6 &lt;&#x2f;td&gt;&lt;td&gt;dirty &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;7 &lt;&#x2f;td&gt;&lt;td&gt;huge page&#x2f;null &lt;&#x2f;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1GiB page in P3, creates a 2MiB page in P2&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8 &lt;&#x2f;td&gt;&lt;td&gt;global &lt;&#x2f;td&gt;&lt;td&gt;page isn&#x27;t flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12-51 &lt;&#x2f;td&gt;&lt;td&gt;physical address &lt;&#x2f;td&gt;&lt;td&gt;the page aligned 52bit physical address of the frame or the next page table&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;63 &lt;&#x2f;td&gt;&lt;td&gt;no execute &lt;&#x2f;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;We see that only bits 12â€“51 are used to store the physical frame address, the remaining bits are used as flags or can be freely used by the operating system. This is possible because we always point to a 4096-byte aligned address, either to a page-aligned page table or to the start of a mapped frame. This means that bits 0â€“11 are always zero, so there is no reason to store these bits because the hardware can just set them to zero before using the address. The same is true for bits 52â€“63, because the x86_64 architecture only supports 52-bit physical addresses (similar to how it only supports 48-bit virtual addresses).&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s take a closer look at the available flags:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;present&lt;&#x2f;code&gt; flag differentiates mapped pages from unmapped ones. It can be used to temporarily swap out pages to disk when main memory becomes full. When the page is accessed subsequently, a special exception called &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs, to which the operating system can react by reloading the missing page from disk and then continuing the program.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;writable&lt;&#x2f;code&gt; and &lt;code&gt;no execute&lt;&#x2f;code&gt; flags control whether the contents of the page are writable or contain executable instructions respectively.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;accessed&lt;&#x2f;code&gt; and &lt;code&gt;dirty&lt;&#x2f;code&gt; flags are automatically set by the CPU when a read or write to the page occurs. This information can be leveraged by the operating system e.g. to decide which pages to swap out or whether the page contents were modified since the last save to disk.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;write through caching&lt;&#x2f;code&gt; and &lt;code&gt;disable cache&lt;&#x2f;code&gt; flags allow to control the caches for every page individually.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;user accessible&lt;&#x2f;code&gt; flag makes a page available to userspace code, otherwise it is only accessible when the CPU is in kernel mode. This feature can be used to make &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;System_call&quot;&gt;system calls&lt;&#x2f;a&gt; faster by keeping the kernel mapped while an userspace program is running. However, the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Spectre_(security_vulnerability)&quot;&gt;Spectre&lt;&#x2f;a&gt; vulnerability can allow userspace programs to read these pages nonetheless.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;global&lt;&#x2f;code&gt; flag signals to the hardware that a page is available in all address spaces and thus does not need to be removed from the translation cache (see the section about the TLB below) on address space switches. This flag is commonly used together with a cleared &lt;code&gt;user accessible&lt;&#x2f;code&gt; flag to map the kernel code to all address spaces.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;huge page&lt;&#x2f;code&gt; flag allows to create pages of larger sizes by letting the entries of the level 2 or level 3 page tables directly point to a mapped frame. With this bit set, the page size increases by factor 512 to either 2MiB = 512 * 4KiB for level 2 entries or even 1GiB = 512 * 2MiB for level 3 entries. The advantage of using larger pages is that fewer lines of the translation cache and fewer page tables are needed.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate provides types for &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page_table&#x2f;struct.PageTable.html&quot;&gt;page tables&lt;&#x2f;a&gt; and their &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;page_table&#x2f;struct.PageTableEntry.html&quot;&gt;entries&lt;&#x2f;a&gt;, so we don&#x27;t need to create these structures ourselves.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-translation-lookaside-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-translation-lookaside-buffer&quot; aria-label=&quot;Anchor link for: the-translation-lookaside-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Translation Lookaside Buffer&lt;&#x2f;h3&gt;
&lt;p&gt;A 4-level page table makes the translation of virtual addresses expensive, because each translation requires 4 memory accesses. To improve performance, the x86_64 architecture caches the last few translations in the so-called &lt;em&gt;translation lookaside buffer&lt;&#x2f;em&gt; (TLB). This allows to skip the translation when the translation is still cached.&lt;&#x2f;p&gt;
&lt;p&gt;Unlike the other CPU caches, the TLB is not fully transparent and does not update or remove translations when the contents of page tables change. This means that the kernel must manually update the TLB whenever it modifies a page table. To do this, there is a special CPU instruction called &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;INVLPG.html&quot;&gt;&lt;code&gt;invlpg&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; (â€œinvalidate pageâ€) that removes the translation for the specified page from the TLB, so that it is loaded again from the page table on the next access. The TLB can also be flushed completely by reloading the &lt;code&gt;CR3&lt;&#x2f;code&gt; register, which simulates an address space switch. The &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate provides Rust functions for both variants in the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;tlb&#x2f;index.html&quot;&gt;&lt;code&gt;tlb&lt;&#x2f;code&gt; module&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;It is important to remember flushing the TLB on each page table modification because otherwise the CPU might keep using the old translation, which can lead to non-deterministic bugs that are very hard to debug.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;One thing that we did not mention yet: &lt;strong&gt;Our kernel already runs on paging&lt;&#x2f;strong&gt;. The bootloader that we added in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;#creating-a-bootimage&quot;&gt;&amp;quot;A minimal Rust Kernel&amp;quot;&lt;&#x2f;a&gt; post already set up a 4-level paging hierarchy that maps every page of our kernel to a physical frame. The bootloader does this because paging is mandatory in 64-bit mode on x86_64.&lt;&#x2f;p&gt;
&lt;p&gt;This means that every memory address that we used in our kernel was a virtual address. Accessing the VGA buffer at address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; only worked because the bootloader &lt;em&gt;identity mapped&lt;&#x2f;em&gt; that memory page, which means that it mapped the virtual page &lt;code&gt;0xb8000&lt;&#x2f;code&gt; to the physical frame &lt;code&gt;0xb8000&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Paging makes our kernel already relatively safe, since every memory access that is out of bounds causes a page fault exception instead of writing to random physical memory. The bootloader even set the correct access permissions for each page, which means that only the pages containing code are executable and only data pages are writable.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-faults&quot; aria-label=&quot;Anchor link for: page-faults&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Faults&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s try to cause a page fault by accessing some memory outside of our kernel. First, we create a page fault handler and register it in our IDT, so that we see a page fault exception instead of a generic &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-fault-exceptions&#x2f;&quot;&gt;double fault&lt;&#x2f;a&gt; :&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();

        [â€¦]

        idt.page_fault.set_handler_fn(page_fault_handler); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::PageFaultErrorCode;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_fault_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame,
    error_code: PageFaultErrorCode,
) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control::Cr2;

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: PAGE FAULT&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Accessed Address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Cr2::read());
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error Code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, error_code);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
    hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Control_register#CR2&quot;&gt;&lt;code&gt;CR2&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; register is automatically set by the CPU on a page fault and contains the accessed virtual address that caused the page fault. We use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;registers&#x2f;control&#x2f;struct.Cr2.html#method.read&quot;&gt;&lt;code&gt;Cr2::read&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate to read and print it. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.PageFaultErrorCode.html&quot;&gt;&lt;code&gt;PageFaultErrorCode&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type provides more information about the type of memory access that caused the page fault, for example whether it was caused by a read or write operation. For this reason we print it too. We can&#x27;t continue execution without resolving the page fault, so we enter a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;#the&quot;&gt;&lt;code&gt;hlt_loop&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; at the end.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can try to access some memory outside our kernel:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
    test_main();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, we see that our page fault handler is called:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;qemu-page-fault.png&quot; alt=&quot;EXCEPTION: Page Fault, Accessed Address: VirtAddr(0xdeadbeaf), Error Code: CAUSED_BY_WRITE, InterruptStackFrame: {â€¦}&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;CR2&lt;&#x2f;code&gt; register indeed contains &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;, the address that we tried to access. The error code tells us through the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.PageFaultErrorCode.html#associatedconstant.CAUSED_BY_WRITE&quot;&gt;&lt;code&gt;CAUSED_BY_WRITE&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; that the fault occurred while trying to perform a write operation. It tells us even more through the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.PageFaultErrorCode.html&quot;&gt;bits that are &lt;em&gt;not&lt;&#x2f;em&gt; set&lt;&#x2f;a&gt;. For example, the fact that the &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2f;code&gt; flag is not set means that the page fault occurred because the target page wasn&#x27;t present.&lt;&#x2f;p&gt;
&lt;p&gt;We see that the current instruction pointer is &lt;code&gt;0x2031b2&lt;&#x2f;code&gt;, so we know that this address points to a code page. Code pages are mapped read-only by the bootloader, so reading from this address works but writing causes a page fault. You can try this by changing the &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt; pointer to &lt;code&gt;0x2031b2&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; Note: The actual address might be different for you. Use the address that
&#x2f;&#x2f; your page fault handler reports.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x2031b2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; read from a code page
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr; }
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;read worked&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; write to a code page
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; }
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;write worked&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By commenting out the last line, we see that the read access works, but the write access causes a page fault:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;paging-introduction&#x2f;qemu-page-fault-protection.png&quot; alt=&quot;QEMU with output: &amp;quot;read worked, EXCEPTION: Page Fault, Accessed Address: VirtAddr(0x2031b2), Error Code: PROTECTION_VIOLATION | CAUSED_BY_WRITE, InterruptStackFrame: {â€¦}&amp;quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that the &lt;em&gt;&amp;quot;read worked&amp;quot;&lt;&#x2f;em&gt; message is printed, which indicates that the read operation did not cause any errors. However, instead of the &lt;em&gt;&amp;quot;write worked&amp;quot;&lt;&#x2f;em&gt; message a page fault occurs. This time the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.PageFaultErrorCode.html#associatedconstant.PROTECTION_VIOLATION&quot;&gt;&lt;code&gt;PROTECTION_VIOLATION&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; flag is set in addition to the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.PageFaultErrorCode.html#associatedconstant.CAUSED_BY_WRITE&quot;&gt;&lt;code&gt;CAUSED_BY_WRITE&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; flag, which indicates that the page was present, but the operation was not allowed on it. In this case, writes to the page are not allowed since code pages are mapped as read-only.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;accessing-the-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#accessing-the-page-tables&quot; aria-label=&quot;Anchor link for: accessing-the-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Accessing the Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s try to take a look at the page tables that define how our kernel is mapped:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control::Cr3;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(level_4_page_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Cr3::read();
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Level 4 page table at: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, level_4_page_table.start_address());

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test_main(), println(â€¦), and hlt_loop()
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;registers&#x2f;control&#x2f;struct.Cr3.html#method.read&quot;&gt;&lt;code&gt;Cr3::read&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; returns the currently active level 4 page table from the &lt;code&gt;CR3&lt;&#x2f;code&gt; register. It returns a tuple of a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;paging&#x2f;frame&#x2f;struct.PhysFrame.html&quot;&gt;&lt;code&gt;PhysFrame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;registers&#x2f;control&#x2f;struct.Cr3Flags.html&quot;&gt;&lt;code&gt;Cr3Flags&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type. We are only interested in the frame, so we ignore the second element of the tuple.&lt;&#x2f;p&gt;
&lt;p&gt;When we run it, we see the following output:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level 4 page table at: PhysAddr(0x1000)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the currently active level 4 page table is stored at address &lt;code&gt;0x1000&lt;&#x2f;code&gt; in &lt;em&gt;physical&lt;&#x2f;em&gt; memory, as indicated by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;struct.PhysAddr.html&quot;&gt;&lt;code&gt;PhysAddr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; wrapper type. The question now is: how can we access this table from our kernel?&lt;&#x2f;p&gt;
&lt;p&gt;Accessing physical memory directly is not possible when paging is active, since programs could easily circumvent memory protection and access memory of other programs otherwise. So the only way to access the table is through some virtual page that is mapped to the physical frame at address &lt;code&gt;0x1000&lt;&#x2f;code&gt;. This problem of creating mappings for page table frames is a general problem, since the kernel needs to access the page tables regularly, for example when allocating a stack for a new thread.&lt;&#x2f;p&gt;
&lt;p&gt;Solutions to this problem are explained in detail in the next post.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;This post introduced two memory protection techniques: segmentation and paging. While the former uses variable-sized memory regions and suffers from external fragmentation, the latter uses fixed-sized pages and allows much more fine-grained control over access permissions.&lt;&#x2f;p&gt;
&lt;p&gt;Paging stores the mapping information for pages in page tables with one or more levels. The x86_64 architecture uses 4-level page tables and a page size of 4KiB. The hardware automatically walks the page tables and caches the resulting translations in the translation lookaside buffer (TLB). This buffer is not updated transparently and needs to be flushed manually on page table changes.&lt;&#x2f;p&gt;
&lt;p&gt;We learned that our kernel already runs on top of paging and that illegal memory accesses cause page fault exceptions. We tried to access the currently active page tables, but we weren&#x27;t able to do it because the CR3 register stores a physical address that we can&#x27;t access directly from our kernel.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The next post explains how to implement support for paging in our kernel. It presents different ways to access physical memory from our kernel, which makes it possible to access the page tables that our kernel runs on. At this point we are able to implement functions for translating virtual to physical addresses and for creating new mappings in the page tables.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Hardware Interrupts</title>
                <pubDate>Mon, 22 Oct 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/hardware-interrupts/</link>
                <guid>https://os.phil-opp.com/hardware-interrupts/</guid>
                <description>&lt;p&gt;In this post we set up the programmable interrupt controller to correctly forward hardware interrupts to the CPU. To handle these interrupts we add new entries to our interrupt descriptor table, just like we did for our exception handlers. We will learn how to get periodic timer interrupts and how to get input from the keyboard.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-07&quot;&gt;&lt;code&gt;post-07&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overview&lt;&#x2f;h2&gt;
&lt;p&gt;Interrupts provide a way to notify the CPU from attached hardware devices. So instead of letting the kernel periodically check the keyboard for new characters (a process called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Polling_(computer_science)&quot;&gt;&lt;em&gt;polling&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;), the keyboard can notify the kernel of each keypress. This is much more efficient because the kernel only needs to act when something happened. It also allows faster reaction times, since the kernel can react immediately and not only at the next poll.&lt;&#x2f;p&gt;
&lt;p&gt;Connecting all hardware devices directly to the CPU is not possible. Instead, a separate &lt;em&gt;interrupt controller&lt;&#x2f;em&gt; aggregates the interrupts from all devices and then notifies the CPU:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;                                    ____________             _____
               Timer ------------&amp;gt; |            |           |     |
               Keyboard ---------&amp;gt; | Interrupt  |---------&amp;gt; | CPU |
               Other Hardware ---&amp;gt; | Controller |           |_____|
               Etc. -------------&amp;gt; |____________|

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most interrupt controllers are programmable, which means that they support different priority levels for interrupts. For example, this allows to give timer interrupts a higher priority than keyboard interrupts to ensure accurate timekeeping.&lt;&#x2f;p&gt;
&lt;p&gt;Unlike exceptions, hardware interrupts occur &lt;em&gt;asynchronously&lt;&#x2f;em&gt;. This means that they are completely independent from the executed code and can occur at any time. Thus we suddenly have a form of concurrency in our kernel with all the potential concurrency-related bugs. Rust&#x27;s strict ownership model helps us here because it forbids mutable global state. However, deadlocks are still possible, as we will see later in this post.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-8259-pic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-8259-pic&quot; aria-label=&quot;Anchor link for: the-8259-pic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The 8259 PIC&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_8259&quot;&gt;Intel 8259&lt;&#x2f;a&gt; is a programmable interrupt controller (PIC) introduced in 1976. It has long been replaced by the newer &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_APIC_Architecture&quot;&gt;APIC&lt;&#x2f;a&gt;, but its interface is still supported on current systems for backwards compatibility reasons. The 8259 PIC is significantly easier to set up than the APIC, so we will use it to introduce ourselves to interrupts before we switch to the APIC in a later post.&lt;&#x2f;p&gt;
&lt;p&gt;The 8259 has 8 interrupt lines and several lines for communicating with the CPU. The typical systems back then were equipped with two instances of the 8259 PIC, one primary and one secondary PIC connected to one of the interrupt lines of the primary:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;                     ____________                          ____________
Real Time Clock --&amp;gt; |            |   Timer -------------&amp;gt; |            |
ACPI -------------&amp;gt; |            |   Keyboard-----------&amp;gt; |            |      _____
Available --------&amp;gt; | Secondary  |----------------------&amp;gt; | Primary    |     |     |
Available --------&amp;gt; | Interrupt  |   Serial Port 2 -----&amp;gt; | Interrupt  |---&amp;gt; | CPU |
Mouse ------------&amp;gt; | Controller |   Serial Port 1 -----&amp;gt; | Controller |     |_____|
Co-Processor -----&amp;gt; |            |   Parallel Port 2&#x2f;3 -&amp;gt; |            |
Primary ATA ------&amp;gt; |            |   Floppy disk -------&amp;gt; |            |
Secondary ATA ----&amp;gt; |____________|   Parallel Port 1----&amp;gt; |____________|

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This graphic shows the typical assignment of interrupt lines. We see that most of the 15 lines have a fixed mapping, e.g. line 4 of the secondary PIC is assigned to the mouse.&lt;&#x2f;p&gt;
&lt;p&gt;Each controller can be configured through two &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;#i-o-ports&quot;&gt;I&#x2f;O ports&lt;&#x2f;a&gt;, one â€œcommandâ€ port and one â€œdataâ€ port. For the primary controller these ports are &lt;code&gt;0x20&lt;&#x2f;code&gt; (command) and &lt;code&gt;0x21&lt;&#x2f;code&gt; (data). For the secondary controller they are &lt;code&gt;0xa0&lt;&#x2f;code&gt; (command) and &lt;code&gt;0xa1&lt;&#x2f;code&gt; (data). For more information on how the PICs can be configured see the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;8259_PIC&quot;&gt;article on osdev.org&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;The default configuration of the PICs is not usable, because it sends interrupt vector numbers in the range 0â€“15 to the CPU. These numbers are already occupied by CPU exceptions, for example number 8 corresponds to a double fault. To fix this overlapping issue, we need to remap the PIC interrupts to different numbers. The actual range doesn&#x27;t matter as long as it does not overlap with the exceptions, but typically the range 32â€“47 is chosen, because these are the first free numbers after the 32 exception slots.&lt;&#x2f;p&gt;
&lt;p&gt;The configuration happens by writing special values to the command and data ports of the PICs. Fortunately there is already a crate called &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pic8259_simple&#x2f;0.1.1&#x2f;pic8259_simple&#x2f;&quot;&gt;&lt;code&gt;pic8259_simple&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, so we don&#x27;t need to write the initialization sequence ourselves. In case you are interested how it works, check out &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;crate&#x2f;pic8259_simple&#x2f;0.1.1&#x2f;source&#x2f;src&#x2f;lib.rs&quot;&gt;its source code&lt;&#x2f;a&gt;, it&#x27;s fairly small and well documented.&lt;&#x2f;p&gt;
&lt;p&gt;To add the crate as dependency, we add the following to our project:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pic8259_simple &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.1&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The main abstraction provided by the crate is the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pic8259_simple&#x2f;0.1.1&#x2f;pic8259_simple&#x2f;struct.ChainedPics.html&quot;&gt;&lt;code&gt;ChainedPics&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct that represents the primary&#x2f;secondary PIC layout we saw above. It is designed to be used in the following way:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;pic8259_simple::ChainedPics;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; spin;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_2_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: spin::Mutex&amp;lt;ChainedPics&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ ChainedPics::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_2_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) });
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We&#x27;re setting the offsets for the pics to the range 32â€“47 as we noted above. By wrapping the &lt;code&gt;ChainedPics&lt;&#x2f;code&gt; struct in a &lt;code&gt;Mutex&lt;&#x2f;code&gt; we are able to get safe mutable access (through the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.5.2&#x2f;spin&#x2f;struct.Mutex.html#method.lock&quot;&gt;&lt;code&gt;lock&lt;&#x2f;code&gt; method&lt;&#x2f;a&gt;), which we need in the next step. The &lt;code&gt;ChainedPics::new&lt;&#x2f;code&gt; function is unsafe because wrong offsets could cause undefined behavior.&lt;&#x2f;p&gt;
&lt;p&gt;We can now initialize the 8259 PIC in our &lt;code&gt;init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    gdt::init();
    interrupts::init_idt();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ interrupts::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().initialize() }; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pic8259_simple&#x2f;0.1.1&#x2f;pic8259_simple&#x2f;struct.ChainedPics.html#method.initialize&quot;&gt;&lt;code&gt;initialize&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function to perform the PIC initialization. Like the &lt;code&gt;ChainedPics::new&lt;&#x2f;code&gt; function, this function is also unsafe because it can cause undefined behavior if the PIC is misconfigured.&lt;&#x2f;p&gt;
&lt;p&gt;If all goes well we should continue to see the &amp;quot;It did not crash&amp;quot; message when executing &lt;code&gt;cargo xrun&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;enabling-interrupts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#enabling-interrupts&quot; aria-label=&quot;Anchor link for: enabling-interrupts&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Enabling Interrupts&lt;&#x2f;h2&gt;
&lt;p&gt;Until now nothing happened because interrupts are still disabled in the CPU configuration. This means that the CPU does not listen to the interrupt controller at all, so no interrupts can reach the CPU. Let&#x27;s change that:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    gdt::init();
    interrupts::init_idt();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ interrupts::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().initialize() };
    x86_64::instructions::interrupts::enable();     &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;interrupts::enable&lt;&#x2f;code&gt; function of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate executes the special &lt;code&gt;sti&lt;&#x2f;code&gt; instruction (â€œset interruptsâ€) to enable external interrupts. When we try &lt;code&gt;cargo xrun&lt;&#x2f;code&gt; now, we see that a double fault occurs:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-hardware-timer-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT because of hardware timer&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The reason for this double fault is that the hardware timer (the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_8253&quot;&gt;Intel 8253&lt;&#x2f;a&gt; to be exact) is enabled by default, so we start receiving timer interrupts as soon as we enable interrupts. Since we didn&#x27;t define a handler function for it yet, our double fault handler is invoked.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;handling-timer-interrupts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-timer-interrupts&quot; aria-label=&quot;Anchor link for: handling-timer-interrupts&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Handling Timer Interrupts&lt;&#x2f;h2&gt;
&lt;p&gt;As we see from the graphic &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;#the-8259-pic&quot;&gt;above&lt;&#x2f;a&gt;, the timer uses line 0 of the primary PIC. This means that it arrives at the CPU as interrupt 32 (0 + offset 32). Instead of hardcoding index 32, we store it in an &lt;code&gt;InterruptIndex&lt;&#x2f;code&gt; enum:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy)]
#[repr(u8)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptIndex {
    Timer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptIndex {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;as_u8(self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;as_usize(self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(self.as_u8())
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The enum is a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;items&#x2f;enumerations.html#custom-discriminant-values-for-field-less-enumerations&quot;&gt;C-like enum&lt;&#x2f;a&gt; so that we can directly specify the index for each variant. The &lt;code&gt;repr(u8)&lt;&#x2f;code&gt; attribute specifies that each variant is represented as an &lt;code&gt;u8&lt;&#x2f;code&gt;. We will add more variants for other interrupts in the future.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can add a handler function for the timer interrupt:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::print;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        [â€¦]
        idt[InterruptIndex::Timer.as_usize()]
            .set_handler_fn(timer_interrupt_handler); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;timer_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;.&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our &lt;code&gt;timer_interrupt_handler&lt;&#x2f;code&gt; has the same signature as our exception handlers, because the CPU reacts identically to exceptions and external interrupts (the only difference is that some exceptions push an error code). The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct implements the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;ops&#x2f;trait.IndexMut.html&quot;&gt;&lt;code&gt;IndexMut&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait, so we can access individual entries through array indexing syntax.&lt;&#x2f;p&gt;
&lt;p&gt;In our timer interrupt handler, we print a dot to the screen. As the timer interrupt happens periodically, we would expect to see a dot appearing on each timer tick. However, when we run it we see that only a single dot is printed:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-single-dot-printed.png&quot; alt=&quot;QEMU printing only a single dot for hardware timer&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;end-of-interrupt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#end-of-interrupt&quot; aria-label=&quot;Anchor link for: end-of-interrupt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
End of Interrupt&lt;&#x2f;h3&gt;
&lt;p&gt;The reason is that the PIC expects an explicit â€œend of interruptâ€ (EOI) signal from our interrupt handler. This signal tells the controller that the interrupt was processed and that the system is ready to receive the next interrupt. So the PIC thinks we&#x27;re still busy processing the first timer interrupt and waits patiently for the EOI signal before sending the next one.&lt;&#x2f;p&gt;
&lt;p&gt;To send the EOI, we use our static &lt;code&gt;PICS&lt;&#x2f;code&gt; struct again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;timer_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;.&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .notify_end_of_interrupt(InterruptIndex::Timer.as_u8());
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;notify_end_of_interrupt&lt;&#x2f;code&gt; figures out whether the primary or secondary PIC sent the interrupt and then uses the &lt;code&gt;command&lt;&#x2f;code&gt; and &lt;code&gt;data&lt;&#x2f;code&gt; ports to send an EOI signal to respective controllers. If the secondary PIC sent the interrupt both PICs need to be notified because the secondary PIC is connected to an input line of the primary PIC.&lt;&#x2f;p&gt;
&lt;p&gt;We need to be careful to use the correct interrupt vector number, otherwise we could accidentally delete an important unsent interrupt or cause our system to hang. This is the reason that the function is unsafe.&lt;&#x2f;p&gt;
&lt;p&gt;When we now execute &lt;code&gt;cargo xrun&lt;&#x2f;code&gt; we see dots periodically appearing on the screen:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-hardware-timer-dots.gif&quot; alt=&quot;QEMU printing consecutive dots showing the hardware timer&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;configuring-the-timer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#configuring-the-timer&quot; aria-label=&quot;Anchor link for: configuring-the-timer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Configuring the Timer&lt;&#x2f;h3&gt;
&lt;p&gt;The hardware timer that we use is called the &lt;em&gt;Progammable Interval Timer&lt;&#x2f;em&gt; or PIT for short. Like the name says, it is possible to configure the interval between two interrupts. We won&#x27;t go into details here because we will switch to the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;APIC_timer&quot;&gt;APIC timer&lt;&#x2f;a&gt; soon, but the OSDev wiki has an extensive article about the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;Programmable_Interval_Timer&quot;&gt;configuring the PIT&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;deadlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deadlocks&quot; aria-label=&quot;Anchor link for: deadlocks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Deadlocks&lt;&#x2f;h2&gt;
&lt;p&gt;We now have a form of concurrency in our kernel: The timer interrupts occur asynchronously, so they can interrupt our &lt;code&gt;_start&lt;&#x2f;code&gt; function at any time. Fortunately Rust&#x27;s ownership system prevents many types of concurrency related bugs at compile time. One notable exception are deadlocks. Deadlocks occur if a thread tries to acquire a lock that will never become free. Thus the thread hangs indefinitely.&lt;&#x2f;p&gt;
&lt;p&gt;We can already provoke a deadlock in our kernel. Remember, our &lt;code&gt;println&lt;&#x2f;code&gt; macro calls the &lt;code&gt;vga_buffer::_print&lt;&#x2f;code&gt; function, which &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#spinlocks&quot;&gt;locks a global &lt;code&gt;WRITER&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; using a spinlock:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[â€¦]

#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).unwrap();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It locks the &lt;code&gt;WRITER&lt;&#x2f;code&gt;, calls &lt;code&gt;write_fmt&lt;&#x2f;code&gt; on it, and implicitly unlocks it at the end of the function. Now imagine that an interrupt occurs while the &lt;code&gt;WRITER&lt;&#x2f;code&gt; is locked and the interrupt handler tries to print something too:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Timestep &lt;&#x2f;th&gt;&lt;th&gt;_start &lt;&#x2f;th&gt;&lt;th&gt;interrupt_handler&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0 &lt;&#x2f;td&gt;&lt;td&gt;calls &lt;code&gt;println!&lt;&#x2f;code&gt;      &lt;&#x2f;td&gt;&lt;td&gt;Â &lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;1 &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2f;code&gt; locks &lt;code&gt;WRITER&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;Â &lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;2 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;interrupt occurs&lt;&#x2f;strong&gt;, handler begins to run&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;td&gt;calls &lt;code&gt;println!&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;4 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2f;code&gt; tries to lock &lt;code&gt;WRITER&lt;&#x2f;code&gt; (already locked)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;5 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;print&lt;&#x2f;code&gt; tries to lock &lt;code&gt;WRITER&lt;&#x2f;code&gt; (already locked)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;â€¦ &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;td&gt;â€¦&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;never&lt;&#x2f;em&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;em&gt;unlock &lt;code&gt;WRITER&lt;&#x2f;code&gt;&lt;&#x2f;em&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The &lt;code&gt;WRITER&lt;&#x2f;code&gt; is locked, so the interrupt handler waits until it becomes free. But this never happens, because the &lt;code&gt;_start&lt;&#x2f;code&gt; function only continues to run after the interrupt handler returns. Thus the complete system hangs.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;provoking-a-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#provoking-a-deadlock&quot; aria-label=&quot;Anchor link for: provoking-a-deadlock&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Provoking a Deadlock&lt;&#x2f;h3&gt;
&lt;p&gt;We can easily provoke such a deadlock in our kernel by printing something in the loop at the end of our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::print;
        print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it in QEMU we get output of the form:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;.&#x2f;qemu-deadlock.png&quot; alt=&quot;QEMU output with many rows of hyphens and no dots&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that only a limited number of hyphens is printed, until the first timer interrupt occurs. Then the system hangs because the timer interrupt handler deadlocks when it tries to print a dot. This is the reason that we see no dots in the above output.&lt;&#x2f;p&gt;
&lt;p&gt;The actual number of hyphens varies between runs because the timer interrupt occurs asynchronously. This non-determinism is what makes concurrency related bugs so difficult to debug.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-the-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-deadlock&quot; aria-label=&quot;Anchor link for: fixing-the-deadlock&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing the Deadlock&lt;&#x2f;h3&gt;
&lt;p&gt;To avoid this deadlock, we can disable interrupts as long as the &lt;code&gt;Mutex&lt;&#x2f;code&gt; is locked:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&#x2f;&#x2f;&#x2f; Prints the given formatted string to the VGA text buffer
&#x2f;&#x2f;&#x2f; through the global `WRITER` instance.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts;   &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::without_interrupts(|| {     &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).unwrap();
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;interrupts&#x2f;fn.without_interrupts.html&quot;&gt;&lt;code&gt;without_interrupts&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function takes a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch13-01-closures.html&quot;&gt;closure&lt;&#x2f;a&gt; and executes it in an interrupt-free environment. We use it to ensure that no interrupt can occur as long as the &lt;code&gt;Mutex&lt;&#x2f;code&gt; is locked. When we run our kernel now we see that it keeps running without hanging. (We still don&#x27;t notice any dots, but this is because they&#x27;re scrolling by too fast. Try to slow down the printing, e.g. by putting a &lt;code&gt;for _ in 0..10000 {}&lt;&#x2f;code&gt; inside the loop.)&lt;&#x2f;p&gt;
&lt;p&gt;We can apply the same change to our serial printing function to ensure that no deadlocks occur with it either:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;serial.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: ::core::fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts;       &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::without_interrupts(|| {         &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .write_fmt(args)
            .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that disabling interrupts shouldn&#x27;t be a general solution. The problem is that it increases the worst case interrupt latency, i.e. the time until the system reacts to an interrupt. Therefore interrupts should be only disabled for a very short time.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;fixing-a-race-condition&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-a-race-condition&quot; aria-label=&quot;Anchor link for: fixing-a-race-condition&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing a Race Condition&lt;&#x2f;h2&gt;
&lt;p&gt;If you run &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; you might see the &lt;code&gt;test_println_output&lt;&#x2f;code&gt; test failing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xtest --lib
[â€¦]
Running 4 tests
test_breakpoint_exception...[ok]
test_println... [ok]
test_println_many... [ok]
test_println_output... [failed]

Error: panicked at &amp;#39;assertion failed: `(left == right)`
  left: `&amp;#39;.&amp;#39;`,
 right: `&amp;#39;S&amp;#39;`&amp;#39;, src&#x2f;vga_buffer.rs:205:9
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason is a &lt;em&gt;race condition&lt;&#x2f;em&gt; between the test and our timer handler. Remember, the test looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println_output() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_output... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, s);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, c) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.chars().enumerate() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().buffer.chars[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;][i].read();
        assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(screen_char.ascii_character), c);
    }

    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The test prints a string to the VGA buffer and then checks the output by manually iterating over the &lt;code&gt;buffer_chars&lt;&#x2f;code&gt; array. The race condition occurs because the timer interrupt handler might run between the &lt;code&gt;println&lt;&#x2f;code&gt; and the reading of the screen characters. Note that this isn&#x27;t a dangerous &lt;em&gt;data race&lt;&#x2f;em&gt;, which Rust completely prevents at compile time. See the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;races.html&quot;&gt;&lt;em&gt;Rustonomicon&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; for details.&lt;&#x2f;p&gt;
&lt;p&gt;To fix this, we need to keep the &lt;code&gt;WRITER&lt;&#x2f;code&gt; locked for the complete duration of the test, so that the timer handler can&#x27;t write a &lt;code&gt;.&lt;&#x2f;code&gt; to the screen in between. The fixed test looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_println_output() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts;

    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_println_output... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some test string that fits on a single line&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    interrupts::without_interrupts(|| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock();
        writeln!(writer, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, s).expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;writeln failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, c) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.chars().enumerate() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer.buffer.chars[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;][i].read();
            assert_eq!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;char&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::from(screen_char.ascii_character), c);
        }
    });

    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We performed the following changes:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;We keep the writer locked for the complete test by using the &lt;code&gt;lock()&lt;&#x2f;code&gt; method explicitly. Instead of &lt;code&gt;println&lt;&#x2f;code&gt;, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;macro.writeln.html&quot;&gt;&lt;code&gt;writeln&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; marco that allows printing to an already locked writer.&lt;&#x2f;li&gt;
&lt;li&gt;To avoid another deadlock, we disable interrupts for the tests duration. Otherwise the test might get interrupted while the writer is still locked.&lt;&#x2f;li&gt;
&lt;li&gt;Since the timer interrupt handler can still run before the test, we print an additional newline &lt;code&gt;\n&lt;&#x2f;code&gt; before printing the string &lt;code&gt;s&lt;&#x2f;code&gt;. This way, we avoid test failure when the timer handler already printed some &lt;code&gt;.&lt;&#x2f;code&gt; characters to the current line.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;With the above changes, &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; now deterministically succeeds again.&lt;&#x2f;p&gt;
&lt;p&gt;This was a very harmless race condition that only caused a test failure. As you can imagine, other race conditions can be much more difficult to debug due to their non-deterministic nature. Luckily, Rust prevents us from data races, which are the most serious class of race conditions since they can cause all kinds of undefined behavior, including system crashes and silent memory corruptions.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-hlt-instruction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-hlt-instruction&quot; aria-label=&quot;Anchor link for: the-hlt-instruction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;hlt&lt;&#x2f;code&gt; Instruction&lt;&#x2f;h2&gt;
&lt;p&gt;Until now we used a simple empty loop statement at the end of our &lt;code&gt;_start&lt;&#x2f;code&gt; and &lt;code&gt;panic&lt;&#x2f;code&gt; functions. This causes the CPU to spin endlessly and thus works as expected. But it is also very inefficient, because the CPU continues to run at full speed even though there&#x27;s no work to do. You can see this problem in your task manager when you run your kernel: The QEMU process needs close to 100% CPU the whole time.&lt;&#x2f;p&gt;
&lt;p&gt;What we really want to do is to halt the CPU until the next interrupt arrives. This allows the CPU to enter a sleep state in which it consumes much less energy. The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;HLT_(x86_instruction)&quot;&gt;&lt;code&gt;hlt&lt;&#x2f;code&gt; instruction&lt;&#x2f;a&gt; does exactly that. Let&#x27;s use this instruction to create an energy efficient endless loop:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;hlt_loop() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        x86_64::instructions::hlt();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;instructions::hlt&lt;&#x2f;code&gt; function is just a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;x86_64&#x2f;blob&#x2f;5e8e218381c5205f5777cb50da3ecac5d7e3b1ab&#x2f;src&#x2f;instructions&#x2f;mod.rs#L16-L22&quot;&gt;thin wrapper&lt;&#x2f;a&gt; around the assembly instruction. It is safe because there&#x27;s no way it can compromise memory safety.&lt;&#x2f;p&gt;
&lt;p&gt;We can now use this &lt;code&gt;hlt_loop&lt;&#x2f;code&gt; instead of the endless loops in our &lt;code&gt;_start&lt;&#x2f;code&gt; and &lt;code&gt;panic&lt;&#x2f;code&gt; functions:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    [â€¦]

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    blog_os::hlt_loop();            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}


#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    blog_os::hlt_loop();            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s update our &lt;code&gt;lib.rs&lt;&#x2f;code&gt; as well:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&#x2f;&#x2f;&#x2f; Entry point for `cargo xtest`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    init();
    test_main();
    hlt_loop();         &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_panic_handler(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[failed]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Error: {}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    exit_qemu(QemuExitCode::Failed);
    hlt_loop();         &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can also use &lt;code&gt;hlt_loop&lt;&#x2f;code&gt; in our double fault exception handler:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::hlt_loop; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;double_fault_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame,
    _error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
) {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: DOUBLE FAULT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
    hlt_loop(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run our kernel now in QEMU, we see a much lower CPU usage.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;keyboard-input&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#keyboard-input&quot; aria-label=&quot;Anchor link for: keyboard-input&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Keyboard Input&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we are able to handle interrupts from external devices we are finally able to add support for keyboard input. This will allow us to interact with our kernel for the first time.&lt;&#x2f;p&gt;
&lt;aside class=&quot;post_aside&quot;&gt;
&lt;p&gt;Note that we only describe how to handle &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;PS&#x2f;2_port&quot;&gt;PS&#x2f;2&lt;&#x2f;a&gt; keyboards here, not USB keyboards. However the mainboard emulates USB keyboards as PS&#x2f;2 devices to support older software, so we can safely ignore USB keyboards until we have USB support in our kernel.&lt;&#x2f;p&gt;
&lt;&#x2f;aside&gt;
&lt;p&gt;Like the hardware timer, the keyboard controller is already enabled by default. So when you press a key the keyboard controller sends an interrupt to the PIC, which forwards it to the CPU. The CPU looks for a handler function in the IDT, but the corresponding entry is empty. Therefore a double fault occurs.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s add a handler function for the keyboard interrupt. It&#x27;s quite similar to how we defined the handler for the timer interrupt, it just uses a different interrupt number:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy)]
#[repr(u8)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptIndex {
    Timer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PIC_1_OFFSET&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Keyboard, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        [â€¦]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt[InterruptIndex::Keyboard.as_usize()]
            .set_handler_fn(keyboard_interrupt_handler);

        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;keyboard_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;k&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;As we see from the graphic &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;#the-8259-pic&quot;&gt;above&lt;&#x2f;a&gt;, the keyboard uses line 1 of the primary PIC. This means that it arrives at the CPU as interrupt 33 (1 + offset 32). We add this index as a new &lt;code&gt;Keyboard&lt;&#x2f;code&gt; variant to the &lt;code&gt;InterruptIndex&lt;&#x2f;code&gt; enum. We don&#x27;t need to specify the value explicitly, since it defaults to the previous value plus one, which is also 33. In the interrupt handler, we print a &lt;code&gt;k&lt;&#x2f;code&gt; and send the end of interrupt signal to the interrupt controller.&lt;&#x2f;p&gt;
&lt;p&gt;We now see that a &lt;code&gt;k&lt;&#x2f;code&gt; appears on the screen when we press a key. However, this only works for the first key we press, even if we continue to press keys no more &lt;code&gt;k&lt;&#x2f;code&gt;s appear on the screen. This is because the keyboard controller won&#x27;t send another interrupt until we have read the so-called &lt;em&gt;scancode&lt;&#x2f;em&gt; of the pressed key.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;reading-the-scancodes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reading-the-scancodes&quot; aria-label=&quot;Anchor link for: reading-the-scancodes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Reading the Scancodes&lt;&#x2f;h3&gt;
&lt;p&gt;To find out &lt;em&gt;which&lt;&#x2f;em&gt; key was pressed, we need to query the keyboard controller. We do this by reading from the data port of the PS&#x2f;2 controller, which is the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;#i-o-ports&quot;&gt;I&#x2f;O port&lt;&#x2f;a&gt; with number &lt;code&gt;0x60&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;keyboard_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; scancode: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 = unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ port.read() };
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, scancode);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;port&#x2f;struct.Port.html&quot;&gt;&lt;code&gt;Port&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate to read a byte from the keyboard&#x27;s data port. This byte is called the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Scancode&quot;&gt;&lt;em&gt;scancode&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; and is a number that represents the key press&#x2f;release. We don&#x27;t do anything with the scancode yet, we just print it to the screen:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-printing-scancodes.gif&quot; alt=&quot;QEMU printing scancodes to the screen when keys are pressed&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The above image shows me slowly typing &amp;quot;123&amp;quot;. We see that adjacent keys have adjacent scancodes and that pressing a key causes a different scancode than releasing it. But how do we translate the scancodes to the actual key actions exactly?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;interpreting-the-scancodes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#interpreting-the-scancodes&quot; aria-label=&quot;Anchor link for: interpreting-the-scancodes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Interpreting the Scancodes&lt;&#x2f;h3&gt;
&lt;p&gt;There are three different standards for the mapping between scancodes and keys, the so-called &lt;em&gt;scancode sets&lt;&#x2f;em&gt;. All three go back to the keyboards of early IBM computers: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;IBM_Personal_Computer_XT&quot;&gt;IBM XT&lt;&#x2f;a&gt;, the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;IBM_3270_PC&quot;&gt;IBM 3270 PC&lt;&#x2f;a&gt;, and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;IBM_Personal_Computer&#x2f;AT&quot;&gt;IBM AT&lt;&#x2f;a&gt;. Later computers fortunately did not continue the trend of defining new scancode sets, but rather emulated the existing sets and extended them. Today most keyboards can be configured to emulate any of the three sets.&lt;&#x2f;p&gt;
&lt;p&gt;By default, PS&#x2f;2 keyboards emulate scancode set 1 (&amp;quot;XT&amp;quot;). In this set, the lower 7 bits of a scancode byte define the key, and the most significant bit defines whether it&#x27;s a press (&amp;quot;0&amp;quot;) or a release (&amp;quot;1&amp;quot;). Keys that were not present on the original &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;IBM_Personal_Computer_XT&quot;&gt;IBM XT&lt;&#x2f;a&gt; keyboard, such as the enter key on the keypad, generate two scancodes in succession: a &lt;code&gt;0xe0&lt;&#x2f;code&gt; escape byte and then a byte representing the key. For a list of all set 1 scancodes and their corresponding keys, check out the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;Keyboard#Scan_Code_Set_1&quot;&gt;OSDev Wiki&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To translate the scancodes to keys, we can use a match statement:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;keyboard_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; scancode: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 = unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ port.read() };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; key &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; scancode {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x02 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;1&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x03 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;2&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x04 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;3&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x05 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;4&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x06 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;5&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x07 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;6&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x08 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;7&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x09 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;8&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0a &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;9&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0b &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;0&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None,
    };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(key) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; key {
        print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, key);
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The above code translates keypresses of the number keys 0-9 and ignores all other keys. It uses a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch06-02-match.html&quot;&gt;match&lt;&#x2f;a&gt; statement to assign a character or &lt;code&gt;None&lt;&#x2f;code&gt; to each scancode. It then uses &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch18-01-all-the-places-for-patterns.html#conditional-if-let-expressions&quot;&gt;&lt;code&gt;if let&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; to destructure the optional &lt;code&gt;key&lt;&#x2f;code&gt;. By using the same variable name &lt;code&gt;key&lt;&#x2f;code&gt; in the pattern, we &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch03-01-variables-and-mutability.html#shadowing&quot;&gt;shadow&lt;&#x2f;a&gt; the previous declaration, which is a common pattern for destructuring &lt;code&gt;Option&lt;&#x2f;code&gt; types in Rust.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can write numbers:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-printing-numbers.gif&quot; alt=&quot;QEMU printing numbers to the screen&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Translating the other keys works in the same way. Fortunately there is a crate named &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pc-keyboard&#x2f;0.3.1&#x2f;pc_keyboard&#x2f;&quot;&gt;&lt;code&gt;pc-keyboard&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for translating scancodes of scancode sets 1 and 2, so we don&#x27;t have to implement this ourselves. To use the crate, we add it to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; and import it in our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pc-keyboard &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.3.1&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can use this crate to rewrite our &lt;code&gt;keyboard_interrupt_handler&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in&#x2f;src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;keyboard_interrupt_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;pc_keyboard::{Keyboard, ScancodeSet1, DecodedKey, layouts};
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;

    lazy_static! {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;KEYBOARD&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;Keyboard&amp;lt;layouts::Us104Key, ScancodeSet1&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mutex::new(Keyboard::new(layouts::Us104Key, ScancodeSet1));
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; keyboard &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;KEYBOARD&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x60&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; scancode: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8 = unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ port.read() };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Ok(Some(key_event)) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; keyboard.add_byte(scancode) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(key) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; keyboard.process_keyevent(key_event) {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; key {
                DecodedKey::Unicode(character) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, character),
                DecodedKey::RawKey(key) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, key),
            }
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PICS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock()
            .notify_end_of_interrupt(InterruptIndex::Keyboard.as_u8());
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; macro to create a static &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pc-keyboard&#x2f;0.3.1&#x2f;pc_keyboard&#x2f;struct.Keyboard.html&quot;&gt;&lt;code&gt;Keyboard&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; object protected by a Mutex. On each interrupt, we lock the Mutex, read the scancode from the keyboard controller and pass it to the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pc-keyboard&#x2f;0.3.1&#x2f;pc_keyboard&#x2f;struct.Keyboard.html#method.add_byte&quot;&gt;&lt;code&gt;add_byte&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method, which translates the scancode into an &lt;code&gt;Option&amp;lt;KeyEvent&amp;gt;&lt;&#x2f;code&gt;. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pc-keyboard&#x2f;0.3.1&#x2f;pc_keyboard&#x2f;struct.KeyEvent.html&quot;&gt;&lt;code&gt;KeyEvent&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; contains which key caused the event and whether it was a press or release event.&lt;&#x2f;p&gt;
&lt;p&gt;To interpret this key event, we pass it to the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;pc-keyboard&#x2f;0.3.1&#x2f;pc_keyboard&#x2f;struct.Keyboard.html#method.process_keyevent&quot;&gt;&lt;code&gt;process_keyevent&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method, which translates the key event to a character if possible. For example, translates a press event of the &lt;code&gt;A&lt;&#x2f;code&gt; key to either a lowercase &lt;code&gt;a&lt;&#x2f;code&gt; character or an uppercase &lt;code&gt;A&lt;&#x2f;code&gt; character, depending on whether the shift key was pressed.&lt;&#x2f;p&gt;
&lt;p&gt;With this modified interrupt handler we can now write text:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;hardware-interrupts&#x2f;qemu-typing.gif&quot; alt=&quot;Typing &amp;quot;Hello World&amp;quot; in QEMU&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;configuring-the-keyboard&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#configuring-the-keyboard&quot; aria-label=&quot;Anchor link for: configuring-the-keyboard&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Configuring the Keyboard&lt;&#x2f;h3&gt;
&lt;p&gt;It&#x27;s possible to configure some aspects of a PS&#x2f;2 keyboard, for example which scancode set it should use. We won&#x27;t cover it here because this post is already long enough, but the OSDev Wiki has an overview of possible &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;PS&#x2f;2_Keyboard#Commands&quot;&gt;configuration commands&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;This post explained how to enable and handle external interrupts. We learned about the 8259 PIC and its primary&#x2f;secondary layout, the remapping of the interrupt numbers, and the &amp;quot;end of interrupt&amp;quot; signal. We implemented handlers for the hardware timer and the keyboard and learned about the &lt;code&gt;hlt&lt;&#x2f;code&gt; instruction, which halts the CPU until the next interrupt.&lt;&#x2f;p&gt;
&lt;p&gt;Now we are able to interact with our kernel and have some fundamental building blocks for creating a small shell or simple games.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;Timer interrupts are essential for an operating system, because they provide a way to periodically interrupt the running process and regain control in the kernel. The kernel can then switch to a different process and create the illusion that multiple processes run in parallel.&lt;&#x2f;p&gt;
&lt;p&gt;But before we can create processes or threads, we need a way to allocate memory for them. The next posts will explore memory management to provide this fundamental building block.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Double Faults</title>
                <pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/double-fault-exceptions/</link>
                <guid>https://os.phil-opp.com/double-fault-exceptions/</guid>
                <description>&lt;p&gt;This post explores the double fault exception in detail, which occurs when the CPU fails to invoke an exception handler. By handling this exception we avoid fatal &lt;em&gt;triple faults&lt;&#x2f;em&gt; that cause a system reset. To prevent triple faults in all cases we also set up an &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; to catch double faults on a separate kernel stack.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-fault-exceptions&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;.  The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-06&quot;&gt;&lt;code&gt;post-06&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;what-is-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-double-fault&quot; aria-label=&quot;Anchor link for: what-is-a-double-fault&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What is a Double Fault?&lt;&#x2f;h2&gt;
&lt;p&gt;In simplified terms, a double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered but there is no page fault handler registered in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;Interrupt Descriptor Table&lt;&#x2f;a&gt; (IDT). So it&#x27;s kind of similar to catch-all blocks in programming languages with exceptions, e.g. &lt;code&gt;catch(...)&lt;&#x2f;code&gt; in C++ or &lt;code&gt;catch(Exception e)&lt;&#x2f;code&gt; in Java or C#.&lt;&#x2f;p&gt;
&lt;p&gt;A double fault behaves like a normal exception. It has the vector number &lt;code&gt;8&lt;&#x2f;code&gt; and we can define a normal handler function for it in the IDT. It is really important to provide a double fault handler, because if a double fault is unhandled a fatal &lt;em&gt;triple fault&lt;&#x2f;em&gt; occurs. Triple faults can&#x27;t be caught and most hardware reacts with a system reset.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;triggering-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#triggering-a-double-fault&quot; aria-label=&quot;Anchor link for: triggering-a-double-fault&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Triggering a Double Fault&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s provoke a double fault by triggering an exception for that we didn&#x27;t define a handler function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a page fault
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeef &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
    test_main();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use &lt;code&gt;unsafe&lt;&#x2f;code&gt; to write to the invalid address &lt;code&gt;0xdeadbeef&lt;&#x2f;code&gt;. The virtual address is not mapped to a physical address in the page tables, so a page fault occurs. We haven&#x27;t registered a page fault handler in our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;IDT&lt;&#x2f;a&gt;, so a double fault occurs.&lt;&#x2f;p&gt;
&lt;p&gt;When we start our kernel now, we see that it enters an endless boot loop. The reason for the boot loop is the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU tries to write to &lt;code&gt;0xdeadbeef&lt;&#x2f;code&gt;, which causes a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU looks at the corresponding entry in the IDT and sees that the present bit isn&#x27;t set. Thus, it can&#x27;t call the page fault handler and a double fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU looks at the IDT entry of the double fault handler, but this entry is also non-present. Thus, a &lt;em&gt;triple&lt;&#x2f;em&gt; fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;A triple fault is fatal. QEMU reacts to it like most real hardware and issues a system reset.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;So in order to prevent this triple fault, we need to either provide a handler function for page faults or a double fault handler. We want to avoid triple faults in all cases, so let&#x27;s start with a double fault handler that is invoked for all unhandled exception types.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-double-fault-handler&quot; aria-label=&quot;Anchor link for: a-double-fault-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Double Fault Handler&lt;&#x2f;h2&gt;
&lt;p&gt;A double fault is a normal exception with an error code, so we can specify a handler function similar to our breakpoint handler:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt.double_fault.set_handler_fn(double_fault_handler); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;double_fault_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame, _error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
{
    panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: DOUBLE FAULT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;{:#?}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our handler prints a short error message and dumps the exception stack frame. The error code of the double fault handler is always zero, so there&#x27;s no reason to print it.&lt;&#x2f;p&gt;
&lt;p&gt;When we start our kernel now, we should see that the double fault handler is invoked:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-fault-exceptions&#x2f;qemu-catch-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It worked! Here is what happens this time:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU executes tries to write to &lt;code&gt;0xdeadbeef&lt;&#x2f;code&gt;, which causes a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;Like before, the CPU looks at the corresponding entry in the IDT and sees that the present bit isn&#x27;t set. Thus, a double fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU jumps to the â€“ now present â€“ double fault handler.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The triple fault (and the boot-loop) no longer occurs, since the CPU can now call the double fault handler.&lt;&#x2f;p&gt;
&lt;p&gt;That was quite straightforward! So why do we need a whole post for this topic? Well, we&#x27;re now able to catch &lt;em&gt;most&lt;&#x2f;em&gt; double faults, but there are some cases where our current approach doesn&#x27;t suffice.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;causes-of-double-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#causes-of-double-faults&quot; aria-label=&quot;Anchor link for: causes-of-double-faults&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Causes of Double Faults&lt;&#x2f;h2&gt;
&lt;p&gt;Before we look at the special cases, we need to know the exact causes of double faults. Above, we used a pretty vague definition:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A double fault is a special exception that occurs when the CPU fails to invoke an exception handler.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;What does &lt;em&gt;â€œfails to invokeâ€&lt;&#x2f;em&gt; mean exactly? The handler is not present? The handler is &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;vm-beyondphys.pdf&quot;&gt;swapped out&lt;&#x2f;a&gt;? And what happens if a handler causes exceptions itself?&lt;&#x2f;p&gt;
&lt;p&gt;For example, what happens if:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;a breakpoint exception occurs, but the corresponding handler function is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;a page fault occurs, but the page fault handler is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;a divide-by-zero handler causes a breakpoint exception, but the breakpoint handler is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;our kernel overflows its stack and the &lt;em&gt;guard page&lt;&#x2f;em&gt; is hit?&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;Fortunately, the AMD64 manual (&lt;a href=&quot;https:&#x2f;&#x2f;www.amd.com&#x2f;system&#x2f;files&#x2f;TechDocs&#x2f;24593.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) has an exact definition (in Section 8.2.9). According to it, a â€œdouble fault exception &lt;em&gt;can&lt;&#x2f;em&gt; occur when a second exception occurs during the handling of a prior (first) exception handlerâ€. The &lt;em&gt;â€œcanâ€&lt;&#x2f;em&gt; is important: Only very specific combinations of exceptions lead to a double fault. These combinations are:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;First Exception &lt;&#x2f;th&gt;&lt;th&gt;Second Exception&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Divide-by-zero_Error&quot;&gt;Divide-by-zero&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2f;a&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;So for example a divide-by-zero fault followed by a page fault is fine (the page fault handler is invoked), but a divide-by-zero fault followed by a general-protection fault leads to a double fault.&lt;&#x2f;p&gt;
&lt;p&gt;With the help of this table, we can answer the first three of the above questions:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;If a breakpoint exception occurs and the corresponding handler function is swapped out, a &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;li&gt;If a page fault occurs and the page fault handler is swapped out, a &lt;em&gt;double fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;double fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;li&gt;If a divide-by-zero handler causes a breakpoint exception, the CPU tries to invoke the breakpoint handler. If the breakpoint handler is swapped out, a &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;In fact, even the case of a non-present handler follows this scheme: A non-present handler causes a &lt;em&gt;segment-not-present&lt;&#x2f;em&gt; exception. We didn&#x27;t define a segment-not-present handler, so another segment-not-present exception occurs. According to the table, this leads to a double fault.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;kernel-stack-overflow&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-stack-overflow&quot; aria-label=&quot;Anchor link for: kernel-stack-overflow&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Kernel Stack Overflow&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s look at the fourth question:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What happens if our kernel overflows its stack and the guard page is hit?&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;A guard page is a special memory page at the bottom of a stack that makes it possible to detect stack overflows. The page is not mapped to any physical frame, so accessing it causes a page fault instead of silently corrupting other memory. The bootloader sets up a guard page for our kernel stack, so a stack overflow causes a &lt;em&gt;page fault&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;When a page fault occurs the CPU looks up the page fault handler in the IDT and tries to push the &lt;a href=&quot;http:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages.html#exceptions-in-detail&quot;&gt;exception stack frame&lt;&#x2f;a&gt; onto the stack. However, the current stack pointer still points to the non-present guard page. Thus, a second page fault occurs, which causes a double fault (according to the above table).&lt;&#x2f;p&gt;
&lt;p&gt;So the CPU tries to call the &lt;em&gt;double fault handler&lt;&#x2f;em&gt; now. However, on a double fault the CPU tries to push the exception stack frame, too. The stack pointer still points to the guard page, so a &lt;em&gt;third&lt;&#x2f;em&gt; page fault occurs, which causes a &lt;em&gt;triple fault&lt;&#x2f;em&gt; and a system reboot. So our current double fault handler can&#x27;t avoid a triple fault in this case.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s try it ourselves! We can easily provoke a kernel stack overflow by calling a function that recurses endlessly:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow() {
        stack_overflow(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; for each recursion, the return address is pushed
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a stack overflow
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow();

    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test_main(), println(â€¦), and loop {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we try this code in QEMU, we see that the system enters a boot-loop again.&lt;&#x2f;p&gt;
&lt;p&gt;So how can we avoid this problem? We can&#x27;t omit the pushing of the exception stack frame, since the CPU itself does it. So we need to ensure somehow that the stack is always valid when a double fault exception occurs. Fortunately, the x86_64 architecture has a solution to this problem.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;switching-stacks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-stacks&quot; aria-label=&quot;Anchor link for: switching-stacks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Switching Stacks&lt;&#x2f;h2&gt;
&lt;p&gt;The x86_64 architecture is able to switch to a predefined, known-good stack when an exception occurs. This switch happens at hardware level, so it can be performed before the CPU pushes the exception stack frame.&lt;&#x2f;p&gt;
&lt;p&gt;The switching mechanism is implemented as an &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; (IST). The IST is a table of 7 pointers to known-good stacks. In Rust-like pseudo code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptStackTable {
    stack_pointers: [Option&amp;lt;StackPointer&amp;gt;; 7],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For each exception handler, we can choose a stack from the IST through the &lt;code&gt;options&lt;&#x2f;code&gt; field in the corresponding &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;IDT entry&lt;&#x2f;a&gt;. For example, we could use the first stack in the IST for our double fault handler. Then the CPU would automatically switch to this stack whenever a double fault occurs. This switch would happen before anything is pushed, so it would prevent the triple fault.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-ist-and-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-ist-and-tss&quot; aria-label=&quot;Anchor link for: the-ist-and-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The IST and TSS&lt;&#x2f;h3&gt;
&lt;p&gt;The Interrupt Stack Table (IST) is part of an old legacy structure called &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Task_state_segment&quot;&gt;Task State Segment&lt;&#x2f;a&gt;&lt;&#x2f;em&gt; (TSS). The TSS used to hold various information (e.g. processor register state) about a task in 32-bit mode and was for example used for &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Context_Switching#Hardware_Context_Switching&quot;&gt;hardware context switching&lt;&#x2f;a&gt;. However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS changed completely.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, the TSS no longer holds any task specific information at all. Instead, it holds two stack tables (the IST is one of them). The only common field between the 32-bit and 64-bit TSS is the pointer to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Task_state_segment#I.2FO_port_permissions&quot;&gt;I&#x2f;O port permissions bitmap&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The 64-bit TSS has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field  &lt;&#x2f;th&gt;&lt;th&gt;Type&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u32&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Privilege Stack Table &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;[u64; 3]&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Interrupt Stack Table &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;[u64; 7]&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;I&#x2f;O Map Base Address &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The &lt;em&gt;Privilege Stack Table&lt;&#x2f;em&gt; is used by the CPU when the privilege level changes. For example, if an exception occurs while the CPU is in user mode (privilege level 3), the CPU normally switches to kernel mode (privilege level 0) before invoking the exception handler. In that case, the CPU would switch to the 0th stack in the Privilege Stack Table (since 0 is the target privilege level). We don&#x27;t have any user mode programs yet, so we ignore this table for now.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-a-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-tss&quot; aria-label=&quot;Anchor link for: creating-a-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a TSS&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s create a new TSS that contains a separate double fault stack in its interrupt stack table. For that we need a TSS struct. Fortunately, the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate already contains a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;tss&#x2f;struct.TaskStateSegment.html&quot;&gt;&lt;code&gt;TaskStateSegment&lt;&#x2f;code&gt; struct&lt;&#x2f;a&gt; that we can use.&lt;&#x2f;p&gt;
&lt;p&gt;We create the TSS in a new &lt;code&gt;gdt&lt;&#x2f;code&gt; module (the name will make sense later):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtAddr;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::tss::TaskStateSegment;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16 = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: TaskStateSegment &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TaskStateSegment::new();
        tss.interrupt_stack_table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];

            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;VirtAddr::from_ptr(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;});
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;STACK_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            stack_end
        };
        tss
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use &lt;code&gt;lazy_static&lt;&#x2f;code&gt; because Rust&#x27;s const evaluator is not yet powerful enough to do this initialization at compile time. We define that the 0th IST entry is the double fault stack (any other IST index would work too). Then we write the top address of a double fault stack to the 0th entry. We write the top address because stacks on x86 grow downwards, i.e. from high addresses to low addresses.&lt;&#x2f;p&gt;
&lt;p&gt;We don&#x27;t have implemented memory management yet, so we don&#x27;t have a proper way to allocate a new stack. Instead, we use a &lt;code&gt;static mut&lt;&#x2f;code&gt; array as stack storage for now. The &lt;code&gt;unsafe&lt;&#x2f;code&gt; is required because the compiler can&#x27;t guarantee race freedom when mutable statics are accessed. It is important that it is a &lt;code&gt;static mut&lt;&#x2f;code&gt; and not an immutable &lt;code&gt;static&lt;&#x2f;code&gt;, because otherwise the bootloader will map it to a read-only page. We will replace this with a proper stack allocation in a later post, then the &lt;code&gt;unsafe&lt;&#x2f;code&gt; will be no longer needed at this place.&lt;&#x2f;p&gt;
&lt;p&gt;Note that this double fault stack has no guard page that protects against stack overflow. This means that we should not do anything stack intensive in our double fault handler because a stack overflow might corrupt the memory below the stack.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;loading-the-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-tss&quot; aria-label=&quot;Anchor link for: loading-the-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the TSS&lt;&#x2f;h4&gt;
&lt;p&gt;Now that we created a new TSS, we need a way to tell the CPU that it should use it. Unfortunately this is a bit cumbersome, since the TSS uses the segmentation system (for historical reasons). Instead of loading the table directly, we need to add a new segment descriptor to the &lt;a href=&quot;http:&#x2f;&#x2f;www.flingos.co.uk&#x2f;docs&#x2f;reference&#x2f;Global-Descriptor-Table&#x2f;&quot;&gt;Global Descriptor Table&lt;&#x2f;a&gt; (GDT). Then we can load our TSS invoking the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;ltr&quot;&gt;&lt;code&gt;ltr&lt;&#x2f;code&gt; instruction&lt;&#x2f;a&gt; with the respective GDT index. (This is the reason why we named our module &lt;code&gt;gdt&lt;&#x2f;code&gt;.)&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-global-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Global Descriptor Table&lt;&#x2f;h3&gt;
&lt;p&gt;The Global Descriptor Table (GDT) is a relict that was used for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_memory_segmentation&quot;&gt;memory segmentation&lt;&#x2f;a&gt; before paging became the de facto standard. It is still needed in 64-bit mode for various things such as kernel&#x2f;user mode configuration or TSS loading.&lt;&#x2f;p&gt;
&lt;p&gt;The GDT is a structure that contains the &lt;em&gt;segments&lt;&#x2f;em&gt; of the program. It was used on older architectures to isolate programs from each other, before paging became the standard. For more information about segmentation check out the equally named chapter of the free &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;&quot;&gt;â€œThree Easy Piecesâ€ book&lt;&#x2f;a&gt;. While segmentation is no longer supported in 64-bit mode, the GDT still exists. It is mostly used for two things: Switching between kernel space and user space, and loading a TSS structure.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;creating-a-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-gdt&quot; aria-label=&quot;Anchor link for: creating-a-gdt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a GDT&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s create a static &lt;code&gt;GDT&lt;&#x2f;code&gt; that includes a segment for our &lt;code&gt;TSS&lt;&#x2f;code&gt; static:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::gdt::{GlobalDescriptorTable, Descriptor};

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: GlobalDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalDescriptorTable::new();
        gdt.add_entry(Descriptor::kernel_code_segment());
        gdt.add_entry(Descriptor::tss_segment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
        gdt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use &lt;code&gt;lazy_static&lt;&#x2f;code&gt; again, because Rust&#x27;s const evaluator is not powerful enough yet. We create a new GDT with a code segment and a TSS segment.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the GDT&lt;&#x2f;h4&gt;
&lt;p&gt;To load our GDT we create a new &lt;code&gt;gdt::init&lt;&#x2f;code&gt; function, that we call from our &lt;code&gt;init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    gdt::init();
    interrupts::init_idt();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now our GDT is loaded (since the &lt;code&gt;_start&lt;&#x2f;code&gt; function calls &lt;code&gt;init&lt;&#x2f;code&gt;), but we still see the boot loop on stack overflow.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-final-steps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-final-steps&quot; aria-label=&quot;Anchor link for: the-final-steps&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The final Steps&lt;&#x2f;h3&gt;
&lt;p&gt;The problem is that the GDT segments are not yet active because the segment and TSS registers still contain the values from the old GDT. We also need to modify the double fault IDT entry so that it uses the new stack.&lt;&#x2f;p&gt;
&lt;p&gt;In summary, we need to do the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Reload code segment register&lt;&#x2f;strong&gt;: We changed our GDT, so we should reload &lt;code&gt;cs&lt;&#x2f;code&gt;, the code segment register. This is required since the old segment selector could point a different GDT descriptor now (e.g. a TSS descriptor).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Load the TSS&lt;&#x2f;strong&gt; : We loaded a GDT that contains a TSS selector, but we still need to tell the CPU that it should use that TSS.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Update the IDT entry&lt;&#x2f;strong&gt;: As soon as our TSS is loaded, the CPU has access to a valid interrupt stack table (IST). Then we can tell the CPU that it should use our new double fault stack by modifying our double fault IDT entry.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;For the first two steps, we need access to the &lt;code&gt;code_selector&lt;&#x2f;code&gt; and &lt;code&gt;tss_selector&lt;&#x2f;code&gt; variables in our &lt;code&gt;gdt::init&lt;&#x2f;code&gt; function. We can achieve this by making them part of the static through a new &lt;code&gt;Selectors&lt;&#x2f;code&gt; struct:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::gdt::SegmentSelector;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: (GlobalDescriptorTable, Selectors) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GlobalDescriptorTable::new();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; code_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(Descriptor::kernel_code_segment());
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(Descriptor::tss_segment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
        (gdt, Selectors { code_selector, tss_selector })
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Selectors {
    code_selector: SegmentSelector,
    tss_selector: SegmentSelector,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can use the selectors to reload the &lt;code&gt;cs&lt;&#x2f;code&gt; segment register and load our &lt;code&gt;TSS&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::segmentation::set_cs;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tables::load_tss;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        set_cs(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;code_selector);
        load_tss(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;tss_selector);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We reload the code segment register using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;segmentation&#x2f;fn.set_cs.html&quot;&gt;&lt;code&gt;set_cs&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and to load the TSS using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;fn.load_tss.html&quot;&gt;&lt;code&gt;load_tss&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. The functions are marked as &lt;code&gt;unsafe&lt;&#x2f;code&gt;, so we need an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block to invoke them. The reason is that it might be possible to break memory safety by loading invalid selectors.&lt;&#x2f;p&gt;
&lt;p&gt;Now that we loaded a valid TSS and interrupt stack table, we can set the stack index for our double fault handler in the IDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::gdt;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            idt.double_fault.set_handler_fn(double_fault_handler)
                .set_stack_index(gdt::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;set_stack_index&lt;&#x2f;code&gt; method is unsafe because the the caller must ensure that the used index is valid and not already used for another exception.&lt;&#x2f;p&gt;
&lt;p&gt;That&#x27;s it! Now the CPU should switch to the double fault stack whenever a double fault occurs. Thus, we are able to catch &lt;em&gt;all&lt;&#x2f;em&gt; double faults, including kernel stack overflows:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-fault-exceptions&#x2f;qemu-double-fault-on-stack-overflow.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;From now on we should never see a triple fault again! To ensure that we don&#x27;t accidentally break the above, we should add a test for this.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-stack-overflow-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-stack-overflow-test&quot; aria-label=&quot;Anchor link for: a-stack-overflow-test&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Stack Overflow Test&lt;&#x2f;h2&gt;
&lt;p&gt;To test our new &lt;code&gt;gdt&lt;&#x2f;code&gt; module and ensure that the double fault handler is correctly called on a stack overflow, we can add an integration test. The idea is to do provoke a double fault in the test function and verify that the double fault handler is called.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s start with a minimal skeleton:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;stack_overflow.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    unimplemented!();
}

#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    blog_os::test_panic_handler(info)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like our &lt;code&gt;panic_handler&lt;&#x2f;code&gt; test, the test will run &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;#no-harness&quot;&gt;without a test harness&lt;&#x2f;a&gt;. The reason is that we can&#x27;t continue execution after a double fault, so more than one test doesn&#x27;t make sense. To disable, the test harness for the test, we add the following to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;test&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stack_overflow&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;harness &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now &lt;code&gt;cargo xtest --test stack_overflow&lt;&#x2f;code&gt; should compile successfully. The test fails of course, since the &lt;code&gt;unimplemented&lt;&#x2f;code&gt; macro panics.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementing-start&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementing-start&quot; aria-label=&quot;Anchor link for: implementing-start&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementing &lt;code&gt;_start&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;The implementation of the &lt;code&gt;_start&lt;&#x2f;code&gt; function looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;stack_overflow.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::serial_print;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;stack_overflow... &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::gdt::init();
    init_test_idt();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a stack overflow
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow();

    panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Execution continued after stack overflow&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}

#[allow(unconditional_recursion)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow() {
    stack_overflow(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; for each recursion, the return address is pushed
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We call our &lt;code&gt;gdt::init&lt;&#x2f;code&gt; function to initialize a new GDT. Instead of calling our &lt;code&gt;interrupts::init_idt&lt;&#x2f;code&gt; function, we call a &lt;code&gt;init_test_idt&lt;&#x2f;code&gt; function that will be explained in a moment. The reason is that we want to register a custom double fault handler that does a &lt;code&gt;exit_qemu(QemuExitCode::Success)&lt;&#x2f;code&gt; instead of panicking.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;stack_overflow&lt;&#x2f;code&gt; function is identical to the function in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;. We additionally added the &lt;code&gt;allow(unconditional_recursion)&lt;&#x2f;code&gt; attribute to silence the warning that the function recurses endlessly.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-test-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-test-idt&quot; aria-label=&quot;Anchor link for: the-test-idt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Test IDT&lt;&#x2f;h3&gt;
&lt;p&gt;As noted above, the test needs its own IDT with a custom double fault handler. The implementation looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;stack_overflow.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::InterruptDescriptorTable;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TEST_IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            idt.double_fault
                .set_handler_fn(test_double_fault_handler)
                .set_stack_index(blog_os::gdt::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        }

        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_test_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TEST_IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The implementation is very similar to our normal IDT in &lt;code&gt;interrupts.rs&lt;&#x2f;code&gt;. Like in the normal IDT, we set a stack index into the IST for the double fault handler in order to switch to a separate stack. The &lt;code&gt;init_test_idt&lt;&#x2f;code&gt; function loads the IDT on the CPU through the &lt;code&gt;load&lt;&#x2f;code&gt; method.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-double-fault-handler&quot; aria-label=&quot;Anchor link for: the-double-fault-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Double Fault Handler&lt;&#x2f;h3&gt;
&lt;p&gt;The only missing piece is our double fault handler. It looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in tests&#x2f;stack_overflow.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{exit_qemu, QemuExitCode, serial_println};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::InterruptStackFrame;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_double_fault_handler(
    _stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame,
    _error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
) {
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    exit_qemu(QemuExitCode::Success);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When the double fault handler is called, we exit QEMU with a success exit code, which marks the test as passed. Since integration tests are completely separate executables, we need to set &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2f;code&gt; attribute again at the top of our test file.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can run our test through &lt;code&gt;cargo xtest --test stack_overflow&lt;&#x2f;code&gt; (or &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; to run all tests). As expected, we see the &lt;code&gt;stack_overflow... [ok]&lt;&#x2f;code&gt; output in the console. Try to comment out the &lt;code&gt;set_stack_index&lt;&#x2f;code&gt; line: it should cause the test to fail.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we learned what a double fault is and under which conditions it occurs. We added a basic double fault handler that prints an error message and added an integration test for it.&lt;&#x2f;p&gt;
&lt;p&gt;We also enabled the hardware supported stack switching on double fault exceptions so that it also works on stack overflow. While implementing it, we learned about the task state segment (TSS), the contained interrupt stack table (IST), and the global descriptor table (GDT), which was used for segmentation on older architectures.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The next post explains how to handle interrupts from external devices such as timers, keyboards, or network controllers. These hardware interrupts are very similar to exceptions, e.g. they are also dispatched through the IDT. However, unlike exceptions, they don&#x27;t arise directly on the CPU. Instead, an &lt;em&gt;interrupt controller&lt;&#x2f;em&gt; aggregates these interrupts and forwards them to CPU depending on their priority. In the next we will explore the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_8259&quot;&gt;Intel 8259&lt;&#x2f;a&gt; (â€œPICâ€) interrupt controller and learn how to implement keyboard support.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>CPU Exceptions</title>
                <pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/cpu-exceptions/</link>
                <guid>https://os.phil-opp.com/cpu-exceptions/</guid>
                <description>&lt;p&gt;CPU exceptions occur in various erroneous situations, for example when accessing an invalid memory address or when dividing by zero. To react to them we have to set up an &lt;em&gt;interrupt descriptor table&lt;&#x2f;em&gt; that provides handler functions. At the end of this post, our kernel will be able to catch &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Breakpoint&quot;&gt;breakpoint exceptions&lt;&#x2f;a&gt; and to resume normal execution afterwards.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overview&lt;&#x2f;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2f;p&gt;
&lt;p&gt;On x86 there are about 20 different CPU exception types. The most important are:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2f;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2f;strong&gt;: This exception occurs when the current instruction is invalid, for example when we try to use newer &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Streaming_SIMD_Extensions&quot;&gt;SSE instructions&lt;&#x2f;a&gt; on an old CPU that does not support them.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;General Protection Fault&lt;&#x2f;strong&gt;: This is the exception with the broadest range of causes. It occurs on various kinds of access violations such as trying to execute a privileged instruction in user level code or writing reserved fields in configuration registers.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2f;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2f;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2f;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2f;em&gt;. We can&#x27;t catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;For the full list of exceptions check out the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;OSDev wiki&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Descriptor Table&lt;&#x2f;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2f;em&gt; (IDT). In this table we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2f;th&gt;&lt;th&gt;Name                     &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [0:15]  &lt;&#x2f;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;GDT selector             &lt;&#x2f;td&gt;&lt;td&gt;Selector of a code segment in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Global_Descriptor_Table&quot;&gt;global descriptor table&lt;&#x2f;a&gt;.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Options                  &lt;&#x2f;td&gt;&lt;td&gt;(see below)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [16:31] &lt;&#x2f;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [32:63] &lt;&#x2f;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Reserved                 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits  &lt;&#x2f;th&gt;&lt;th&gt;Name                              &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2   &lt;&#x2f;td&gt;&lt;td&gt;Interrupt Stack Table Index       &lt;&#x2f;td&gt;&lt;td&gt;0: Don&#x27;t switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7   &lt;&#x2f;td&gt;&lt;td&gt;Reserved              &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8     &lt;&#x2f;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate   &lt;&#x2f;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11  &lt;&#x2f;td&gt;&lt;td&gt;must be one                       &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12    &lt;&#x2f;td&gt;&lt;td&gt;must be zero                      &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;13â€‘14 &lt;&#x2f;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)  &lt;&#x2f;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;15    &lt;&#x2f;td&gt;&lt;td&gt;Present                           &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;Exception Table&lt;&#x2f;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the â€œVector nr.â€ column.&lt;&#x2f;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2f;a&gt; register. (We will use these values later in this post.)&lt;&#x2f;li&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14-th entry when a page fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;Check if the entry is present. Raise a double fault if not.&lt;&#x2f;li&gt;
&lt;li&gt;Disable hardware interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2f;li&gt;
&lt;li&gt;Load the specified &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Global_Descriptor_Table&quot;&gt;GDT&lt;&#x2f;a&gt; selector into the CS segment.&lt;&#x2f;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;Don&#x27;t worry about steps 4 and 5 for now, we will learn about the global descriptor table and hardware interrupts in future posts.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;an-idt-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-idt-type&quot; aria-label=&quot;Anchor link for: an-idt-type&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
An IDT Type&lt;&#x2f;h2&gt;
&lt;p&gt;Instead of creating our own IDT type, we will use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt; struct&lt;&#x2f;a&gt; of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate, which looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;debug: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;non_maskable_interrupt: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;breakpoint: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;overflow: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bound_range_exceeded: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid_opcode: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;device_not_available: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;double_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid_tss: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;segment_not_present: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_segment_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;general_protection_fault: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_fault: Entry&amp;lt;PageFaultHandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x87_floating_point: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alignment_check: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;machine_check: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;simd_floating_point: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;virtualization: Entry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;security_exception: Entry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some fields omitted
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The fields have the type &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.Entry.html&quot;&gt;&lt;code&gt;idt::Entry&amp;lt;F&amp;gt;&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, which is a struct that represents the fields of an IDT entry (see the table above). The type parameter &lt;code&gt;F&lt;&#x2f;code&gt; defines the expected handler function type. We see that some entries require a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFunc.html&quot;&gt;&lt;code&gt;HandlerFunc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and some entries require a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. The page fault even has its own special type: &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.PageFaultHandlerFunc.html&quot;&gt;&lt;code&gt;PageFaultHandlerFunc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s look at the &lt;code&gt;HandlerFunc&lt;&#x2f;code&gt; type first:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases&quot;&gt;type alias&lt;&#x2f;a&gt; for an &lt;code&gt;extern &amp;quot;x86-interrupt&amp;quot; fn&lt;&#x2f;code&gt; type. The &lt;code&gt;extern&lt;&#x2f;code&gt; keyword defines a function with a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;ffi.html#foreign-calling-conventions&quot;&gt;foreign calling convention&lt;&#x2f;a&gt; and is often used to communicate with C code (&lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt;). But what is the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention?&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-interrupt-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-calling-convention&quot; aria-label=&quot;Anchor link for: the-interrupt-calling-convention&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Calling Convention&lt;&#x2f;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the called function and executes it. Afterwards the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2f;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted &lt;code&gt;call&lt;&#x2f;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;Calling conventions&lt;&#x2f;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;x86_64-abi-0.99.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt;):&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2f;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2f;code&gt; and &lt;code&gt;rdx&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;issues&#x2f;600&quot;&gt;there isn&#x27;t even a Rust ABI yet&lt;&#x2f;a&gt;), so these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preserved and Scratch Registers&lt;&#x2f;h3&gt;
&lt;p&gt;The calling convention divides the registers in two parts: &lt;em&gt;preserved&lt;&#x2f;em&gt; and &lt;em&gt;scratch&lt;&#x2f;em&gt; registers.&lt;&#x2f;p&gt;
&lt;p&gt;The values of &lt;em&gt;preserved&lt;&#x2f;em&gt; registers must remain unchanged across function calls. So a called function (the &lt;em&gt;â€œcalleeâ€&lt;&#x2f;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called &lt;em&gt;â€œcallee-savedâ€&lt;&#x2f;em&gt;. A common pattern is to save these registers to the stack at the function&#x27;s beginning and restore them just before returning.&lt;&#x2f;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite &lt;em&gt;scratch&lt;&#x2f;em&gt; registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it before the function call (e.g. by pushing it to the stack). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers &lt;&#x2f;th&gt;&lt;th&gt;scratch registers&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2f;code&gt;, &lt;code&gt;rbx&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, &lt;code&gt;r12&lt;&#x2f;code&gt;, &lt;code&gt;r13&lt;&#x2f;code&gt;, &lt;code&gt;r14&lt;&#x2f;code&gt;, &lt;code&gt;r15&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;, &lt;code&gt;r10&lt;&#x2f;code&gt;, &lt;code&gt;r11&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2f;em&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2f;em&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2f;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2f;code&gt; on the stack (because it&#x27;s a callee-saved register).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;preserving-all-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserving-all-registers&quot; aria-label=&quot;Anchor link for: preserving-all-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preserving all Registers&lt;&#x2f;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In most cases we don&#x27;t even know at compile time if the generated code will cause an exception. For example, the compiler can&#x27;t know if an instruction causes a stack overflow or a page fault.&lt;&#x2f;p&gt;
&lt;p&gt;Since we don&#x27;t know when an exception occurs, we can&#x27;t backup any registers before. This means that we can&#x27;t use a calling convention that relies on caller-saved registers for exception handlers. Instead, we need a calling convention means that preserves &lt;em&gt;all registers&lt;&#x2f;em&gt;. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is such a calling convention, so it guarantees that all register values are restored to their original values on function return.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-interrupt-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-stack-frame&quot; aria-label=&quot;Anchor link for: the-interrupt-stack-frame&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Stack Frame&lt;&#x2f;h3&gt;
&lt;p&gt;On a normal function call (using the &lt;code&gt;call&lt;&#x2f;code&gt; instruction), the CPU pushes the return address before jumping to the target function. On function return (using the &lt;code&gt;ret&lt;&#x2f;code&gt; instruction), the CPU pops this return address and jumps to it. So the stack frame of a normal function call looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;For exception and interrupt handlers, however, pushing a return address would not suffice, since interrupt handlers often run in a different context (stack pointer, CPU flags, etc.). Instead, the CPU performs the following steps when an interrupt occurs:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack pointer&lt;&#x2f;strong&gt;: An interrupt can occur at any instructions, so the stack pointer can have any value, too. However, some CPU instructions (e.g. some SSE instructions) require that the stack pointer is aligned on a 16 byte boundary, therefore the CPU performs such an alignment right after the interrupt.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Switching stacks&lt;&#x2f;strong&gt; (in some cases): A stack switch occurs when the CPU privilege level changes, for example when a CPU exception occurs in an user mode program. It is also possible to configure stack switches for specific interrupts using the so-called &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; (described in the next post).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the old stack pointer&lt;&#x2f;strong&gt;: The CPU pushes the values of the stack pointer (&lt;code&gt;rsp&lt;&#x2f;code&gt;) and the stack segment (&lt;code&gt;ss&lt;&#x2f;code&gt;) registers at the time when the interrupt occurred (before the alignment). This makes it possible to restore the original stack pointer when returning from an interrupt handler.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing and updating the &lt;code&gt;RFLAGS&lt;&#x2f;code&gt; register&lt;&#x2f;strong&gt;: The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;&lt;code&gt;RFLAGS&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; register contains various control and status bits. On interrupt entry, the CPU changes some bits and pushes the old value.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the instruction pointer&lt;&#x2f;strong&gt;: Before jumping to the interrupt handler function, the CPU pushes the instruction pointer (&lt;code&gt;rip&lt;&#x2f;code&gt;) and the code segment (&lt;code&gt;cs&lt;&#x2f;code&gt;). This is comparable to the return address push of a normal function call.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing an error code&lt;&#x2f;strong&gt; (for some exceptions): For some specific exceptions such as page faults, the CPU pushes an error code, which describes the cause of the exception.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Invoking the interrupt handler&lt;&#x2f;strong&gt;: The CPU reads the address and the segment descriptor of the interrupt handler function from the corresponding field in the IDT. It then invokes this handler by loading the values into the &lt;code&gt;rip&lt;&#x2f;code&gt; and &lt;code&gt;cs&lt;&#x2f;code&gt; registers.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;So the &lt;em&gt;interrupt stack frame&lt;&#x2f;em&gt; looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;exception-stack-frame.svg&quot; alt=&quot;interrupt stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate, the interrupt stack frame is represented by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.InterruptStackFrame.html&quot;&gt;&lt;code&gt;InterruptStackFrame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct. It is passed to interrupt handlers as &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; and can be used to retrieve additional information about the exception&#x27;s cause. The struct contains no error code field, since only some few exceptions push an error code. These exceptions use the separate &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function type, which has an additional &lt;code&gt;error_code&lt;&#x2f;code&gt; argument.&lt;&#x2f;p&gt;
&lt;p&gt;Note that there is currently &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;57270&quot;&gt;a bug in LLVM&lt;&#x2f;a&gt; that leads to wrong error code arguments. The cause of the issue is already known and a solution is &lt;a href=&quot;https:&#x2f;&#x2f;reviews.llvm.org&#x2f;D56275&quot;&gt;being worked on&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;behind-the-scenes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#behind-the-scenes&quot; aria-label=&quot;Anchor link for: behind-the-scenes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Behind the Scenes&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is a powerful abstraction that hides almost all of the messy details of the exception handling process. However, sometimes it&#x27;s useful to know what&#x27;s happening behind the curtain. Here is a short overview of the things that the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention takes care of:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Retrieving the arguments&lt;&#x2f;strong&gt;: Most calling conventions expect that the arguments are passed in registers. This is not possible for exception handlers, since we must not overwrite any register values before backing them up on the stack. Instead, the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is aware that the arguments already lie on the stack at a specific offset.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Returning using &lt;code&gt;iretq&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;: Since the interrupt stack frame completely differs from stack frames of normal function calls, we can&#x27;t return from handlers functions through the normal &lt;code&gt;ret&lt;&#x2f;code&gt; instruction. Instead, the &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction must be used.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Handling the error code&lt;&#x2f;strong&gt;: The error code, which is pushed for some exceptions, makes things much more complex. It changes the stack alignment (see the next point) and needs to be popped off the stack before returning. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention handles all that complexity. However, it doesn&#x27;t know which handler function is used for which exception, so it needs to deduce that information from the number of function arguments. That means that the programmer is still responsible to use the correct function type for each exception. Luckily, the &lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt; type defined by the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate ensures that the correct function types are used.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack&lt;&#x2f;strong&gt;: There are some instructions (especially SSE instructions) that require a 16-byte stack alignment. The CPU ensures this alignment whenever an exception occurs, but for some exceptions it destroys it again later when it pushes an error code. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention takes care of this by realigning the stack in this case.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;If you are interested in more details: We also have a series of posts that explains exception handling using &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2f;a&gt; linked &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;#too-much-magic&quot;&gt;at the end of this post&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we&#x27;ve understood the theory, it&#x27;s time to handle CPU exceptions in our kernel. We&#x27;ll start by creating a new interrupts module in &lt;code&gt;src&#x2f;interrupts.rs&lt;&#x2f;code&gt;, that first creates an &lt;code&gt;init_idt&lt;&#x2f;code&gt; function that creates a new &lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::InterruptDescriptorTable;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can add handler functions. We start by adding a handler for the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Breakpoint&quot;&gt;breakpoint exception&lt;&#x2f;a&gt;. The breakpoint exception is the perfect exception to test exception handling. Its only purpose is to temporarily pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2f;code&gt; is executed.&lt;&#x2f;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;01&#x2f;27&#x2f;how-debuggers-work-part-2-breakpoints&quot;&gt;&amp;quot;&lt;em&gt;How debuggers work&lt;&#x2f;em&gt;&amp;quot;&lt;&#x2f;a&gt; series.&lt;&#x2f;p&gt;
&lt;p&gt;For our use case, we don&#x27;t need to overwrite any instructions. Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program. So let&#x27;s create a simple &lt;code&gt;breakpoint_handler&lt;&#x2f;code&gt; function and add it to our IDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::{InterruptDescriptorTable, InterruptStackFrame};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::println;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
    idt.breakpoint.set_handler_fn(breakpoint_handler);
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;breakpoint_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InterruptStackFrame)
{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: BREAKPOINT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our handler just outputs a message and pretty-prints the interrupt stack frame.&lt;&#x2f;p&gt;
&lt;p&gt;When we try to compile it, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0658]: x86-interrupt ABI is experimental and subject to change (see issue #40180)
  --&amp;gt; src&#x2f;main.rs:53:1
   |
53 | &#x2f; extern &amp;quot;x86-interrupt&amp;quot; fn breakpoint_handler(stack_frame: &amp;amp;mut InterruptStackFrame) {
54 | |     println!(&amp;quot;EXCEPTION: BREAKPOINT\n{:#?}&amp;quot;, stack_frame);
55 | | }
   | |_^
   |
   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This error occurs because the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is still unstable. To use it anyway, we have to explicitly enable it by adding &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2f;code&gt; on the top of our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the IDT&lt;&#x2f;h3&gt;
&lt;p&gt;In order that the CPU uses our new interrupt descriptor table, we need to load it using the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;lgdt:lidt&quot;&gt;&lt;code&gt;lidt&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instruction. The &lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt; struct of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; provides a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.InterruptDescriptorTable.html#method.load&quot;&gt;&lt;code&gt;load&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method function for that. Let&#x27;s try to use it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
    idt.breakpoint.set_handler_fn(breakpoint_handler);
    idt.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we try to compile it now, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `idt` does not live long enough
  --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:43:5
   |
43 |     idt.load();
   |     ^^^ does not live long enough
44 | }
   | - borrowed value only lives until here
   |
   = note: borrowed value must be valid for the static lifetime...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the &lt;code&gt;load&lt;&#x2f;code&gt; methods expects a &lt;code&gt;&amp;amp;&#x27;static self&lt;&#x2f;code&gt;, that is a reference that is valid for the complete runtime of the program. The reason is that the CPU will access this table on every interrupt until we load a different IDT. So using a shorter lifetime than &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; could lead to use-after-free bugs.&lt;&#x2f;p&gt;
&lt;p&gt;In fact, this is exactly what happens here. Our &lt;code&gt;idt&lt;&#x2f;code&gt; is created on the stack, so it is only valid inside the &lt;code&gt;init&lt;&#x2f;code&gt; function. Afterwards the stack memory is reused for other functions, so the CPU would interpret random stack memory as IDT. Luckily, the &lt;code&gt;InterruptDescriptorTable::load&lt;&#x2f;code&gt; method encodes this lifetime requirement in its function definition, so that the Rust compiler is able to prevent this possible bug at compile time.&lt;&#x2f;p&gt;
&lt;p&gt;In order to fix this problem, we need to store our &lt;code&gt;idt&lt;&#x2f;code&gt; at a place where it has a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime. To achieve this we could allocate our IDT on the heap using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;&lt;code&gt;Box&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and then convert it to a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; reference, but we are writing an OS kernel and thus don&#x27;t have a heap (yet).&lt;&#x2f;p&gt;
&lt;p&gt;As an alternative we could try to store the IDT as a &lt;code&gt;static&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.breakpoint.set_handler_fn(breakpoint_handler);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, there is a problem: Statics are immutable, so we can&#x27;t modify the breakpoint entry from our &lt;code&gt;init&lt;&#x2f;code&gt; function. We could solve this problem by using a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;&lt;code&gt;static mut&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.breakpoint.set_handler_fn(breakpoint_handler);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This variant compiles without errors but it&#x27;s far from idiomatic. &lt;code&gt;static mut&lt;&#x2f;code&gt;s are very prone to data races, so we need an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;&lt;code&gt;unsafe&lt;&#x2f;code&gt; block&lt;&#x2f;a&gt; on each access.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Lazy Statics to the Rescue&lt;&#x2f;h4&gt;
&lt;p&gt;Fortunately the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; macro exists. Instead of evaluating a &lt;code&gt;static&lt;&#x2f;code&gt; at compile time, the macro performs the initialization when the &lt;code&gt;static&lt;&#x2f;code&gt; is referenced the first time. Thus, we can do almost everything in the initialization block and are even able to read runtime values.&lt;&#x2f;p&gt;
&lt;p&gt;We already imported the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; crate when we &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#lazy-statics&quot;&gt;created an abstraction for the VGA text buffer&lt;&#x2f;a&gt;. So we can directly use the &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro to create our static IDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: InterruptDescriptorTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptDescriptorTable::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note how this solution requires no &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks. The &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro does use &lt;code&gt;unsafe&lt;&#x2f;code&gt; behind the scenes, but it is abstracted away in a safe interface.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;running-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-it&quot; aria-label=&quot;Anchor link for: running-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Running it&lt;&#x2f;h3&gt;
&lt;p&gt;The last step for making exceptions work in our kernel is to call the &lt;code&gt;init_idt&lt;&#x2f;code&gt; function from our &lt;code&gt;main.rs&lt;&#x2f;code&gt;. Instead of calling it directly, we introduce a general &lt;code&gt;init&lt;&#x2f;code&gt; function in our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    interrupts::init_idt();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;With this function we now have a central place for initialization routines that can be shared between the different &lt;code&gt;_start&lt;&#x2f;code&gt; functions in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;, &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, and integration tests.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can update the &lt;code&gt;_start&lt;&#x2f;code&gt; function of our &lt;code&gt;main.rs&lt;&#x2f;code&gt; to call &lt;code&gt;init&lt;&#x2f;code&gt; and then trigger a breakpoint exception:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    blog_os::init(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new

    &#x2f;&#x2f; invoke a breakpoint exception
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts::int3(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new

    &#x2f;&#x2f; as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
    test_main();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it in QEMU now (using &lt;code&gt;cargo xrun&lt;&#x2f;code&gt;), we see the following:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cpu-exceptions&#x2f;qemu-breakpoint-exception.png&quot; alt=&quot;QEMU printing EXCEPTION: BREAKPOINT and the interrupt stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It works! The CPU successfully invokes our breakpoint handler, which prints the message, and then returns back to the &lt;code&gt;_start&lt;&#x2f;code&gt; function, where the &lt;code&gt;It did not crash!&lt;&#x2f;code&gt; message is printed.&lt;&#x2f;p&gt;
&lt;p&gt;We see that the interrupt stack frame tells us the instruction and stack pointers at the time when the exception occurred. This information is very useful when debugging unexpected exceptions.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;adding-a-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-a-test&quot; aria-label=&quot;Anchor link for: adding-a-test&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Adding a Test&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s create a test that ensures that the above continues to work. First, we update the &lt;code&gt;_start&lt;&#x2f;code&gt; function to also call &lt;code&gt;init&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&#x2f;&#x2f;&#x2f; Entry point for `cargo xtest`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    init();      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_main();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Remember, this &lt;code&gt;_start&lt;&#x2f;code&gt; function is used when running &lt;code&gt;cargo xtest --lib&lt;&#x2f;code&gt;, since Rust&#x27;s tests the &lt;code&gt;lib.rs&lt;&#x2f;code&gt; completely independent of the &lt;code&gt;main.rs&lt;&#x2f;code&gt;. We need to call &lt;code&gt;init&lt;&#x2f;code&gt; here to set up an IDT before running the tests.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can create a &lt;code&gt;test_breakpoint_exception&lt;&#x2f;code&gt; test:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::{serial_print, serial_println};

#[test_case]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_breakpoint_exception() {
    serial_print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;test_breakpoint_exception...&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; invoke a breakpoint exception
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts::int3();
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;[ok]&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Apart from printing status messages through the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;#serial-port&quot;&gt;serial port&lt;&#x2f;a&gt;, the test invokes the &lt;code&gt;int3&lt;&#x2f;code&gt; function to trigger a breakpoint exception. By checking that the execution continues afterwards, we verify that our breakpoint handler is working correctly.&lt;&#x2f;p&gt;
&lt;p&gt;You can try this new test by running &lt;code&gt;cargo xtest&lt;&#x2f;code&gt; (all tests) or &lt;code&gt;cargo xtest --lib&lt;&#x2f;code&gt; (only tests of &lt;code&gt;lib.rs&lt;&#x2f;code&gt; and its modules). You should see &lt;code&gt;test_breakpoint_exception...[ok]&lt;&#x2f;code&gt; in the output.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;too-much-magic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#too-much-magic&quot; aria-label=&quot;Anchor link for: too-much-magic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Too much Magic?&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.7.5&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.InterruptDescriptorTable.html&quot;&gt;&lt;code&gt;InterruptDescriptorTable&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type made the exception handling process relatively straightforward and painless. If this was too much magic for you and you like to learn all the gory details of exception handling, we got you covered: Our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;extra&#x2f;naked-exceptions&#x2f;&quot;&gt;â€œHandling Exceptions with Naked Functionsâ€&lt;&#x2f;a&gt; series shows how to handle exceptions without the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and also creates its own IDT type. Historically, these posts were the main exception handling posts before the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate existed. Note that these posts are based on the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;&quot;&gt;first edition&lt;&#x2f;a&gt; of this blog and might be out of date.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;We&#x27;ve successfully caught our first exception and returned from it! The next step is to ensure that we catch all exceptions, because an uncaught exception causes a fatal &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Triple_Fault&quot;&gt;triple fault&lt;&#x2f;a&gt;, which leads to a system reset. The next post explains how we can avoid this by correctly catching &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Double_Fault#Double_Fault&quot;&gt;double faults&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Integration Tests</title>
                <pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/integration-tests/</link>
                <guid>https://os.phil-opp.com/integration-tests/</guid>
                <description>&lt;p&gt;To complete the testing picture we implement a basic integration test framework, which allows us to run tests on the target system. The idea is to run tests inside QEMU and report the results back to the host through the serial port.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;integration-tests&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-05&quot;&gt;&lt;code&gt;post-05&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Requirements&lt;&#x2f;h2&gt;
&lt;p&gt;This post builds upon the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;&quot;&gt;&lt;em&gt;Unit Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post, so you need to follow it first. Alternatively, consider reading the new &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;&quot;&gt;&lt;em&gt;Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post instead, which replaces both &lt;em&gt;Unit Testing&lt;&#x2f;em&gt; and this post. The new posts implements similar functionality, but integrates it directly in &lt;code&gt;cargo xtest&lt;&#x2f;code&gt;, so that both unit and integration tests run in a realistic environment inside QEMU.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overview&lt;&#x2f;h2&gt;
&lt;p&gt;In the previous post we added support for unit tests. The goal of unit tests is to test small components in isolation to ensure that each of them works as intended. The tests are run on the host machine and thus shouldn&#x27;t rely on architecture specific functionality.&lt;&#x2f;p&gt;
&lt;p&gt;To test the interaction of the components, both with each other and the system environment, we can write &lt;em&gt;integration tests&lt;&#x2f;em&gt;. Compared to unit tests, Ã¬ntegration tests are more complex, because they need to run in a realistic environment. What this means depends on the application type. For example, for webserver applications it often means to set up a database instance. For an operating system kernel like ours, it means that we run the tests on the target hardware without an underlying operating system.&lt;&#x2f;p&gt;
&lt;p&gt;Running on the target architecture allows us to test all hardware specific code such as the VGA buffer or the effects of &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Page_table&quot;&gt;page table&lt;&#x2f;a&gt; modifications. It also allows us to verify that our kernel boots without problems and that no &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;CPU exception&lt;&#x2f;a&gt; occurs.&lt;&#x2f;p&gt;
&lt;p&gt;In this post we will implement a very basic test framework that runs integration tests inside instances of the &lt;a href=&quot;https:&#x2f;&#x2f;www.qemu.org&#x2f;&quot;&gt;QEMU&lt;&#x2f;a&gt; virtual machine. It is not as realistic as running them on real hardware, but it is much simpler and should be sufficient as long as we only use standard hardware that is well supported in QEMU.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-serial-port&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-serial-port&quot; aria-label=&quot;Anchor link for: the-serial-port&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Serial Port&lt;&#x2f;h2&gt;
&lt;p&gt;The naive way of doing an integration test would be to add some assertions in the code, launch QEMU, and manually check if a panic occurred or not. This is very cumbersome and not practical if we have hundreds of integration tests. So we want an automated solution that runs all tests and fails if not all of them pass.&lt;&#x2f;p&gt;
&lt;p&gt;Such an automated test framework needs to know whether a test succeeded or failed. It can&#x27;t look at the screen output of QEMU, so we need a different way of retrieving the test results on the host system. A simple way to achieve this is by using the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Serial_port&quot;&gt;serial port&lt;&#x2f;a&gt;, an old interface standard which is no longer found in modern computers. It is easy to program and QEMU can redirect the bytes sent over serial to the host&#x27;s standard output or a file.&lt;&#x2f;p&gt;
&lt;p&gt;The chips implementing a serial interface are called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Universal_asynchronous_receiver-transmitter&quot;&gt;UARTs&lt;&#x2f;a&gt;. There are &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Universal_asynchronous_receiver-transmitter#UART_models&quot;&gt;lots of UART models&lt;&#x2f;a&gt; on x86, but fortunately the only differences between them are some advanced features we don&#x27;t need. The common UARTs today are all compatible to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;16550_UART&quot;&gt;16550 UART&lt;&#x2f;a&gt;, so we will use that model for our testing framework.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;port-i-o&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#port-i-o&quot; aria-label=&quot;Anchor link for: port-i-o&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Port I&#x2f;O&lt;&#x2f;h3&gt;
&lt;p&gt;There are two different approaches for communicating between the CPU and peripheral hardware on x86, &lt;strong&gt;memory-mapped I&#x2f;O&lt;&#x2f;strong&gt; and &lt;strong&gt;port-mapped I&#x2f;O&lt;&#x2f;strong&gt;. We already used memory-mapped I&#x2f;O for accessing the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;&quot;&gt;VGA text buffer&lt;&#x2f;a&gt; through the memory address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. This address is not mapped to RAM, but to some memory on the GPU.&lt;&#x2f;p&gt;
&lt;p&gt;In contrast, port-mapped I&#x2f;O uses a separate I&#x2f;O bus for communication. Each connected peripheral has one or more port numbers. To communicate with such an I&#x2f;O port there are special CPU instructions called &lt;code&gt;in&lt;&#x2f;code&gt; and &lt;code&gt;out&lt;&#x2f;code&gt;, which take a port number and a data byte (there are also variations of these commands that allow sending an &lt;code&gt;u16&lt;&#x2f;code&gt; or &lt;code&gt;u32&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;The UART uses port-mapped I&#x2f;O. Fortunately there are already several crates that provide abstractions for I&#x2f;O ports and even UARTs, so we don&#x27;t need to invoke the &lt;code&gt;in&lt;&#x2f;code&gt; and &lt;code&gt;out&lt;&#x2f;code&gt; assembly instructions manually.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;We will use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;uart_16550&quot;&gt;&lt;code&gt;uart_16550&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate to initialize the UART and send data over the serial port. To add it as a dependency, we update our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; and &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;uart_16550 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;uart_16550&lt;&#x2f;code&gt; crate contains a &lt;code&gt;SerialPort&lt;&#x2f;code&gt; struct that represents the UART registers, but we still need to construct an instance of it ourselves. For that we create a new &lt;code&gt;serial&lt;&#x2f;code&gt; module with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;serial.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;uart_16550::SerialPort;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;SerialPort&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; serial_port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;SerialPort::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x3F8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        serial_port.init();
        Mutex::new(serial_port)
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like with the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#lazy-statics&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;, we use &lt;code&gt;lazy_static&lt;&#x2f;code&gt; and a spinlock to create a &lt;code&gt;static&lt;&#x2f;code&gt;. However, this time we use &lt;code&gt;lazy_static&lt;&#x2f;code&gt; to ensure that the &lt;code&gt;init&lt;&#x2f;code&gt; method is called before first use. We&#x27;re using the port address &lt;code&gt;0x3F8&lt;&#x2f;code&gt;, which is the standard port number for the first serial interface.&lt;&#x2f;p&gt;
&lt;p&gt;To make the serial port easily usable, we add &lt;code&gt;serial_print!&lt;&#x2f;code&gt; and &lt;code&gt;serial_println!&lt;&#x2f;code&gt; macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: ::core::fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;SERIAL1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Printing to serial failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Prints to the host through the serial interface.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        $crate::serial::_print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Prints to the host through the serial interface, appending a newline.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! serial_println {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::serial_print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
        concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;SerialPort&lt;&#x2f;code&gt; type already implements the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Write.html&quot;&gt;&lt;code&gt;fmt::Write&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait, so we don&#x27;t need to provide an implementation.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can print to the serial interface in our &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; prints to vga buffer
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;serial_println&lt;&#x2f;code&gt; macro lives directly under the root namespace because we used the &lt;code&gt;#[macro_export]&lt;&#x2f;code&gt; attribute, so importing it through &lt;code&gt;use crate::serial::serial_println&lt;&#x2f;code&gt; will not work.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;qemu-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#qemu-arguments&quot; aria-label=&quot;Anchor link for: qemu-arguments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
QEMU Arguments&lt;&#x2f;h3&gt;
&lt;p&gt;To see the serial output in QEMU, we can use the &lt;code&gt;-serial&lt;&#x2f;code&gt; argument to redirect the output to stdout:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 \
    -drive format=raw,file=target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;bootimage-blog_os.bin \
    -serial mon:stdio
warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
Hello Host!
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If you chose a different name than &lt;code&gt;blog_os&lt;&#x2f;code&gt;, you need to update the paths of course. Note that you can no longer exit QEMU through &lt;code&gt;Ctrl+c&lt;&#x2f;code&gt;. As an alternative you can use &lt;code&gt;Ctrl+a&lt;&#x2f;code&gt; and then &lt;code&gt;x&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;As an alternative to this long command, we can pass the argument to &lt;code&gt;bootimage run&lt;&#x2f;code&gt;, with an additional &lt;code&gt;--&lt;&#x2f;code&gt; to separate the build arguments (passed to cargo) from the run arguments (passed to QEMU).&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- -serial mon:stdio
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of standard output, QEMU supports &lt;a href=&quot;https:&#x2f;&#x2f;qemu.weilnetz.de&#x2f;doc&#x2f;qemu-doc.html#Debug_002fExpert-options&quot;&gt;many more target devices&lt;&#x2f;a&gt;. For redirecting the output to a file, the argument is:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-serial file:output-file.txt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;shutting-down-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#shutting-down-qemu&quot; aria-label=&quot;Anchor link for: shutting-down-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Shutting Down QEMU&lt;&#x2f;h2&gt;
&lt;p&gt;Right now we have an endless loop at the end of our &lt;code&gt;_start&lt;&#x2f;code&gt; function and need to close QEMU manually. This does not work for automated tests. We could try to kill QEMU automatically from the host, for example after some special output was sent over serial, but this would be a bit hacky and difficult to get right. The cleaner solution would be to implement a way to shutdown our OS. Unfortunately this is relatively complex, because it requires implementing support for either the &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;APM&quot;&gt;APM&lt;&#x2f;a&gt; or &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;ACPI&quot;&gt;ACPI&lt;&#x2f;a&gt; power management standard.&lt;&#x2f;p&gt;
&lt;p&gt;Luckily, there is an escape hatch: QEMU supports a special &lt;code&gt;isa-debug-exit&lt;&#x2f;code&gt; device, which provides an easy way to exit QEMU from the guest system. To enable it, we add the following argument to our QEMU command:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;iobase&lt;&#x2f;code&gt; specifies on which port address the device should live (&lt;code&gt;0xf4&lt;&#x2f;code&gt; is a &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;I&#x2f;O_Ports#The_list&quot;&gt;generally unused&lt;&#x2f;a&gt; port on the x86&#x27;s IO bus) and the &lt;code&gt;iosize&lt;&#x2f;code&gt; specifies the port size (&lt;code&gt;0x04&lt;&#x2f;code&gt; means four bytes). Now the guest can write a value to the &lt;code&gt;0xf4&lt;&#x2f;code&gt; port and QEMU will exit with &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Exit_status&quot;&gt;exit status&lt;&#x2f;a&gt; &lt;code&gt;(passed_value &amp;lt;&amp;lt; 1) | 1&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To write to the I&#x2f;O port, we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.5.2&#x2f;x86_64&#x2f;&quot;&gt;&lt;code&gt;x86_64&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.2&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    port.write(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We mark the function as &lt;code&gt;unsafe&lt;&#x2f;code&gt; because it relies on the fact that a special QEMU device is attached to the I&#x2f;O port with address &lt;code&gt;0xf4&lt;&#x2f;code&gt;. For the port type we choose &lt;code&gt;u32&lt;&#x2f;code&gt; because the &lt;code&gt;iosize&lt;&#x2f;code&gt; is 4 bytes. As value we write a zero, which causes QEMU to exit with exit status &lt;code&gt;(0 &amp;lt;&amp;lt; 1) | 1 = 1&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Note that we could also use the exit status instead of the serial interface for sending the test results, for example &lt;code&gt;1&lt;&#x2f;code&gt; for success and &lt;code&gt;2&lt;&#x2f;code&gt; for failure. However, this wouldn&#x27;t allow us to send panic messages like the serial interface does and would also prevent us from replacing &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; with a proper shutdown someday. Therefore we continue to use the serial interface and just always write a &lt;code&gt;0&lt;&#x2f;code&gt; to the port.&lt;&#x2f;p&gt;
&lt;p&gt;We can now test the QEMU shutdown by calling &lt;code&gt;exit_qemu&lt;&#x2f;code&gt; from our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; prints to vga buffer
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You should see that QEMU immediately closes after booting when executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- -serial mon:stdio -device isa-debug-exit,iobase=0xf4,iosize=0x04
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;hiding-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hiding-qemu&quot; aria-label=&quot;Anchor link for: hiding-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hiding QEMU&lt;&#x2f;h2&gt;
&lt;p&gt;We are now able to launch a QEMU instance that writes its output to the serial port and automatically exits itself when it&#x27;s done. So we no longer need the VGA buffer output or the graphical representation that still pops up. We can disable it by passing the &lt;code&gt;-display none&lt;&#x2f;code&gt; parameter to QEMU. The full command looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qemu-system-x86_64 \
    -drive format=raw,file=target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;bootimage-blog_os.bin \
    -serial mon:stdio \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
    -display none
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Or, with &lt;code&gt;bootimage run&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run -- \
    -serial mon:stdio \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04 \
    -display none
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now QEMU runs completely in the background and no window is opened anymore. This is not only less annoying, but also allows our test framework to run in environments without a graphical user interface, such as &lt;a href=&quot;https:&#x2f;&#x2f;travis-ci.com&#x2f;&quot;&gt;Travis CI&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;test-organization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-organization&quot; aria-label=&quot;Anchor link for: test-organization&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Test Organization&lt;&#x2f;h2&gt;
&lt;p&gt;Right now we&#x27;re doing the serial output and the QEMU exit from the &lt;code&gt;_start&lt;&#x2f;code&gt; function in our &lt;code&gt;main.rs&lt;&#x2f;code&gt; and can no longer run our kernel in a normal way. We could try to fix this by adding an &lt;code&gt;integration-test&lt;&#x2f;code&gt; &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;manifest.html#the-features-section&quot;&gt;cargo feature&lt;&#x2f;a&gt; and using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;attributes.html#conditional-compilation&quot;&gt;conditional compilation&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;features&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;integration-test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= []
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(feature &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; prints to vga buffer

    &#x2f;&#x2f; normal execution

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(feature &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;integration-test&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello Host{}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    run_test_1();
    run_test_2();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; run more tests

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, this approach has a big problem: All tests run in the same kernel instance, which means that they can influence each other. For example, if &lt;code&gt;run_test_1&lt;&#x2f;code&gt; misconfigures the system by loading an invalid &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Page_table&quot;&gt;page table&lt;&#x2f;a&gt;, it can cause &lt;code&gt;run_test_2&lt;&#x2f;code&gt; to fail. This isn&#x27;t something that we want because it makes it very difficult to find the actual cause of an error.&lt;&#x2f;p&gt;
&lt;p&gt;Instead, we want our test instances to be as independent as possible. If a test wants to destroy most of the system configuration to ensure that some property still holds in catastrophic situations, it should be able to do so without needing to restore a correct system state afterwards. This means that we need to launch a separate QEMU instance for each test.&lt;&#x2f;p&gt;
&lt;p&gt;With the above conditional compilation we only have two modes: Run the kernel normally or execute &lt;em&gt;all&lt;&#x2f;em&gt; integration tests. To run each test in isolation we would need a separate cargo feature for each test with that approach, which would result in very complex conditional compilation bounds and confusing code.&lt;&#x2f;p&gt;
&lt;p&gt;A better solution is to create an additional executable for each test.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;additional-test-executables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#additional-test-executables&quot; aria-label=&quot;Anchor link for: additional-test-executables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Additional Test Executables&lt;&#x2f;h3&gt;
&lt;p&gt;Cargo allows to add &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;manifest.html#the-project-layout&quot;&gt;additional executables&lt;&#x2f;a&gt; to a project by putting them inside &lt;code&gt;src&#x2f;bin&lt;&#x2f;code&gt;. We can use that feature to create a separate executable for each integration test. For example, a &lt;code&gt;test-something&lt;&#x2f;code&gt; executable could be added like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;bin&#x2f;test-something.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; run tests
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By providing a new implementation for &lt;code&gt;_start&lt;&#x2f;code&gt; we can create a minimal test case that only tests one specific thing and is independent of the rest. For example, if we don&#x27;t print anything to the VGA buffer, the test still succeeds even if the &lt;code&gt;vga_buffer&lt;&#x2f;code&gt; module is broken.&lt;&#x2f;p&gt;
&lt;p&gt;We can now run this executable in QEMU by passing a &lt;code&gt;--bin&lt;&#x2f;code&gt; argument to &lt;code&gt;bootimage&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bootimage run --bin test-something
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It should build the &lt;code&gt;test-something.rs&lt;&#x2f;code&gt; executable instead of &lt;code&gt;main.rs&lt;&#x2f;code&gt; and launch an empty QEMU window (since we don&#x27;t print anything). So this approach allows us to create completely independent executables without cargo features or conditional compilation, and without cluttering our &lt;code&gt;main.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;However, there is a problem: This is a completely separate executable, which means that we can&#x27;t access any functions from our &lt;code&gt;main.rs&lt;&#x2f;code&gt;, including &lt;code&gt;serial_println&lt;&#x2f;code&gt; and &lt;code&gt;exit_qemu&lt;&#x2f;code&gt;. Duplicating the code would work, but we would also need to copy everything we want to test. This would mean that we no longer test the original function but only a possibly outdated copy.&lt;&#x2f;p&gt;
&lt;p&gt;Fortunately there is a way to share most of the code between our &lt;code&gt;main.rs&lt;&#x2f;code&gt; and the testing binaries: We move most of the code from our &lt;code&gt;main.rs&lt;&#x2f;code&gt; to a library that we can include from all executables.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;split-off-a-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#split-off-a-library&quot; aria-label=&quot;Anchor link for: split-off-a-library&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Split Off A Library&lt;&#x2f;h3&gt;
&lt;p&gt;Cargo supports hybrid projects that are both a library and a binary. We only need to create a &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt; file and split the contents of our &lt;code&gt;main.rs&lt;&#x2f;code&gt; in the following way:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t link the Rust standard library

&#x2f;&#x2f; NEW: We need to add `pub` here to make them accessible from the outside
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;serial;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exit_qemu() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::port::Port;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; port &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Port::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xf4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    port.write(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::println;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is the entry point, since the linker looks for a function
&#x2f;&#x2f;&#x2f; named `_start` by default.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So we move everything except &lt;code&gt;_start&lt;&#x2f;code&gt; and &lt;code&gt;panic&lt;&#x2f;code&gt; to &lt;code&gt;lib.rs&lt;&#x2f;code&gt; and make the &lt;code&gt;vga_buffer&lt;&#x2f;code&gt; and &lt;code&gt;serial&lt;&#x2f;code&gt; modules public. Everything should work exactly as before, including &lt;code&gt;bootimage run&lt;&#x2f;code&gt; and &lt;code&gt;cargo test&lt;&#x2f;code&gt;. To run tests only for the library part of our crate and avoid the additional output we can execute &lt;code&gt;cargo test --lib&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;test-basic-boot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-basic-boot&quot; aria-label=&quot;Anchor link for: test-basic-boot&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Test Basic Boot&lt;&#x2f;h3&gt;
&lt;p&gt;We are finally able to create our first integration test executable. We start simple and only test that the basic boot sequence works and the &lt;code&gt;_start&lt;&#x2f;code&gt; function is called:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;bin&#x2f;test-basic-boot.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; disable all Rust-level entry points
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{exit_qemu, serial_println};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is the entry point, since the linker looks for a function
&#x2f;&#x2f;&#x2f; named `_start` by default.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}


&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;failed&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We don&#x27;t do something special here, we just print &lt;code&gt;ok&lt;&#x2f;code&gt; if &lt;code&gt;_start&lt;&#x2f;code&gt; is called and &lt;code&gt;failed&lt;&#x2f;code&gt; with the panic message when a panic occurs. Let&#x27;s try it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; bootimage run --bin test-basic-boot -- \
    -serial mon:stdio -display none \
    -device isa-debug-exit,iobase=0xf4,iosize=0x04
Building kernel
   Compiling blog_os v0.2.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
    Updating registry `https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;crates.io-index`
Creating disk image at target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;bootimage-test-basic-boot.bin
warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
ok
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We got our &lt;code&gt;ok&lt;&#x2f;code&gt;, so it worked! Try inserting a &lt;code&gt;panic!()&lt;&#x2f;code&gt; before the &lt;code&gt;ok&lt;&#x2f;code&gt; printing, you should see output like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;failed
panicked at &amp;#39;explicit panic&amp;#39;, src&#x2f;bin&#x2f;test-basic-boot.rs:19:5
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;test-panic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#test-panic&quot; aria-label=&quot;Anchor link for: test-panic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Test Panic&lt;&#x2f;h3&gt;
&lt;p&gt;To test that our panic handler is really invoked on a panic, we create a &lt;code&gt;test-panic&lt;&#x2f;code&gt; test:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;bin&#x2f;test-panic.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_std)]
#![cfg_attr(not(test), no_main)]
#![cfg_attr(test, allow(unused_imports))]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os::{exit_qemu, serial_println};

#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    panic!();
}

#[cfg(not(test))]
#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    serial_println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ok&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ exit_qemu(); }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This executable is almost identical to &lt;code&gt;test-basic-boot&lt;&#x2f;code&gt;, the only difference is that we print &lt;code&gt;ok&lt;&#x2f;code&gt; from our panic handler and invoke an explicit &lt;code&gt;panic()&lt;&#x2f;code&gt; in our &lt;code&gt;_start&lt;&#x2f;code&gt; function.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-test-runner&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-test-runner&quot; aria-label=&quot;Anchor link for: a-test-runner&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Test Runner&lt;&#x2f;h2&gt;
&lt;p&gt;The final step is to create a test runner, a program that executes all integration tests and checks their results. The basic steps that it should do are:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Look for integration tests in the current project, maybe by some convention (e.g. executables starting with &lt;code&gt;test-&lt;&#x2f;code&gt;).&lt;&#x2f;li&gt;
&lt;li&gt;Run all integration tests and interpret their results.
&lt;ul&gt;
&lt;li&gt;Use a timeout to ensure that an endless loop does not block the test runner forever.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;Report the test results to the user and set a successful or failing exit status.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Such a test runner is useful to many projects, so we decided to add one to the &lt;code&gt;bootimage&lt;&#x2f;code&gt; tool.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;bootimage-test&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bootimage-test&quot; aria-label=&quot;Anchor link for: bootimage-test&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Bootimage Test&lt;&#x2f;h3&gt;
&lt;p&gt;The test runner of the &lt;code&gt;bootimage&lt;&#x2f;code&gt; tool can be invoked via &lt;code&gt;bootimage test&lt;&#x2f;code&gt;. It uses the following conventions:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;All executables starting with &lt;code&gt;test-&lt;&#x2f;code&gt; are treated as integration tests.&lt;&#x2f;li&gt;
&lt;li&gt;Tests must print either &lt;code&gt;ok&lt;&#x2f;code&gt; or &lt;code&gt;failed&lt;&#x2f;code&gt; over the serial port. When printing &lt;code&gt;failed&lt;&#x2f;code&gt; they can print additional information such as a panic message (in the next lines).&lt;&#x2f;li&gt;
&lt;li&gt;Tests are run with a timeout of 1 minute. If the test has not completed in time, it is reported as &amp;quot;timed out&amp;quot;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The &lt;code&gt;test-basic-boot&lt;&#x2f;code&gt; and &lt;code&gt;test-panic&lt;&#x2f;code&gt; tests we created above begin with &lt;code&gt;test-&lt;&#x2f;code&gt; and follow the &lt;code&gt;ok&lt;&#x2f;code&gt;&#x2f;&lt;code&gt;failed&lt;&#x2f;code&gt; conventions, so they should work with &lt;code&gt;bootimage test&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; bootimage test
test-panic
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Ok

test-basic-boot
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Ok

test-something
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
Timed Out

The following tests failed:
    test-something: TimedOut
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that our &lt;code&gt;test-panic&lt;&#x2f;code&gt; and &lt;code&gt;test-basic-boot&lt;&#x2f;code&gt; succeeded and that the &lt;code&gt;test-something&lt;&#x2f;code&gt; test timed out after one minute. We no longer need &lt;code&gt;test-something&lt;&#x2f;code&gt;, so we delete it (if you haven&#x27;t done already). Now &lt;code&gt;bootimage test&lt;&#x2f;code&gt; should execute successfully.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we learned about the serial port and port-mapped I&#x2f;O and saw how to configure QEMU to print serial output to the command line. We also learned a trick how to exit QEMU without needing to implement a proper shutdown.&lt;&#x2f;p&gt;
&lt;p&gt;We then split our crate into a library and binary part in order to create additional executables for integration tests. We added two example tests for testing that the &lt;code&gt;_start&lt;&#x2f;code&gt; function is correctly called and that a &lt;code&gt;panic&lt;&#x2f;code&gt; invokes our panic handler. Finally, we presented &lt;code&gt;bootimage test&lt;&#x2f;code&gt; as a basic test runner for our integration tests.&lt;&#x2f;p&gt;
&lt;p&gt;We now have a working integration test framework and can finally start to implement functionality in our kernel. We will continue to use the test framework over the next posts to test new components we add.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the next post, we will explore &lt;em&gt;CPU exceptions&lt;&#x2f;em&gt;. These exceptions are thrown by the CPU when something illegal happens, such as a division by zero or an access to an unmapped memory page (a so-called â€œpage faultâ€). Being able to catch and examine these exceptions is very important for debugging future errors. Exception handling is also very similar to the handling of hardware interrupts, which is required for keyboard support.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Unit Testing</title>
                <pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/unit-testing/</link>
                <guid>https://os.phil-opp.com/unit-testing/</guid>
                <description>&lt;p&gt;This post explores unit testing in &lt;code&gt;no_std&lt;&#x2f;code&gt; executables using Rust&#x27;s built-in test framework. We will adjust our code so that &lt;code&gt;cargo test&lt;&#x2f;code&gt; works and add some basic unit tests to our VGA buffer module.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-04&quot;&gt;&lt;code&gt;post-04&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;requirements&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#requirements&quot; aria-label=&quot;Anchor link for: requirements&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Requirements&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we explore how to execute &lt;code&gt;cargo test&lt;&#x2f;code&gt; on the host system (as a normal Linux&#x2f;Windows&#x2f;macOS executable). This only works if you don&#x27;t have a &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; file that sets a default target. If you followed the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;&quot;&gt;&lt;em&gt;Minimal Rust Kernel&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post before 2019-04-27, you should be fine. If you followed it after that date, you need to remove the &lt;code&gt;build.target&lt;&#x2f;code&gt; key from your &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; file and explicitly pass a target argument to &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Alternatively, consider reading the new &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;testing&#x2f;&quot;&gt;&lt;em&gt;Testing&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post instead. It sets up a similar functionality as this post, but instead of running the tests on your host system, they are run in a realistic environment inside QEMU.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;unit-tests-for-no-std-binaries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unit-tests-for-no-std-binaries&quot; aria-label=&quot;Anchor link for: unit-tests-for-no-std-binaries&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Unit Tests for &lt;code&gt;no_std&lt;&#x2f;code&gt; Binaries&lt;&#x2f;h2&gt;
&lt;p&gt;Rust has a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch11-00-testing.html&quot;&gt;built-in test framework&lt;&#x2f;a&gt; that is capable of running unit tests without the need to set anything up. Just create a function that checks some results through assertions and add the &lt;code&gt;#[test]&lt;&#x2f;code&gt; attribute to the function header. Then &lt;code&gt;cargo test&lt;&#x2f;code&gt; will automatically find and execute all test functions of your crate.&lt;&#x2f;p&gt;
&lt;p&gt;Unfortunately it&#x27;s a bit more complicated for &lt;code&gt;no_std&lt;&#x2f;code&gt; applications such as our kernel. If we run &lt;code&gt;cargo test&lt;&#x2f;code&gt; (without adding any test yet), we get the following error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os)
error[E0152]: duplicate lang item found: `panic_impl`.
  --&amp;gt; src&#x2f;main.rs:35:1
   |
35 | &#x2f; fn panic(info: &amp;amp;PanicInfo) -&amp;gt; ! {
36 | |     println!(&amp;quot;{}&amp;quot;, info);
37 | |     loop {}
38 | | }
   | |_^
   |
   = note: first defined in crate `std`.
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that unit tests are built for the host machine, with the &lt;code&gt;std&lt;&#x2f;code&gt; library included. This makes sense because they should be able to run as a normal application on the host operating system. Since the standard library has it&#x27;s own &lt;code&gt;panic_handler&lt;&#x2f;code&gt; function, we get the above error. To fix it, we use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;attributes.html#conditional-compilation&quot;&gt;conditional compilation&lt;&#x2f;a&gt; to include our implementation of the panic handler only in non-test environments:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[cfg(not(test))] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; only compile when the test flag is not set
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The only change is the added &lt;code&gt;#[cfg(not(test))]&lt;&#x2f;code&gt; attribute. The &lt;code&gt;#[cfg(â€¦)]&lt;&#x2f;code&gt; attribute ensures that the annotated item is only included if the passed condition is met. The &lt;code&gt;test&lt;&#x2f;code&gt; configuration is set when the crate is compiled for unit tests. Through &lt;code&gt;not(â€¦)&lt;&#x2f;code&gt; we negate the condition so that the language item is only compiled for non-test builds.&lt;&#x2f;p&gt;
&lt;p&gt;When we now try &lt;code&gt;cargo test&lt;&#x2f;code&gt; again, we get an ugly linker error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; &amp;quot;-Wl,--as-needed&amp;quot; &amp;quot;-Wl,-z,noexecstack&amp;quot; &amp;quot;-m64&amp;quot; &amp;quot;-L&amp;quot; &amp;quot;&#x2f;â€¦&#x2f;lib&#x2f;rustlib&#x2f;x86_64-unknown-linux-gnu&#x2f;lib&amp;quot; [â€¦]
  = note: &#x2f;â€¦&#x2f;blog_os-969bdb90d27730ed.2q644ojj2xqxddld.rcgu.o: In function `_start&amp;#39;:
          &#x2f;â€¦&#x2f;blog_os&#x2f;src&#x2f;main.rs:17: multiple definition of `_start&amp;#39;
          &#x2f;usr&#x2f;lib&#x2f;gcc&#x2f;x86_64-linux-gnu&#x2f;5&#x2f;..&#x2f;..&#x2f;..&#x2f;x86_64-linux-gnu&#x2f;Scrt1.o:(.text+0x0): first defined here
          &#x2f;usr&#x2f;lib&#x2f;gcc&#x2f;x86_64-linux-gnu&#x2f;5&#x2f;..&#x2f;..&#x2f;..&#x2f;x86_64-linux-gnu&#x2f;Scrt1.o: In function `_start&amp;#39;:
          (.text+0x20): undefined reference to `main&amp;#39;
          collect2: error: ld returned 1 exit status

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I shortened the output here because it is extremely verbose. The relevant part is at the bottom, after the second â€œnote:â€. We got two distinct errors here, â€œ&lt;em&gt;multiple definition of &lt;code&gt;_start&lt;&#x2f;code&gt;&lt;&#x2f;em&gt;â€ and â€œ&lt;em&gt;undefined reference to &lt;code&gt;main&lt;&#x2f;code&gt;&lt;&#x2f;em&gt;â€.&lt;&#x2f;p&gt;
&lt;p&gt;The reason for the first error is that the test framework injects its own &lt;code&gt;main&lt;&#x2f;code&gt; and &lt;code&gt;_start&lt;&#x2f;code&gt; functions, which will run the tests when invoked. So we get two functions named &lt;code&gt;_start&lt;&#x2f;code&gt; when compiling in test mode, one from the test framework and the one we defined ourselves. To fix this, we need to exclude our &lt;code&gt;_start&lt;&#x2f;code&gt; function in that case, which we can do by marking it as &lt;code&gt;#[cfg(not(test))]&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(not(test))]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ â€¦ }
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The second problem is that we use the &lt;code&gt;#![no_main]&lt;&#x2f;code&gt; attribute for our crate, which suppresses any &lt;code&gt;main&lt;&#x2f;code&gt; generation, including the test &lt;code&gt;main&lt;&#x2f;code&gt;. To solve this, we use the &lt;a href=&quot;https:&#x2f;&#x2f;chrismorgan.info&#x2f;blog&#x2f;rust-cfg_attr.html&quot;&gt;&lt;code&gt;cfg_attr&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; attribute to conditionally enable the &lt;code&gt;no_main&lt;&#x2f;code&gt; attribute only in non-test mode:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(not(test), no_main)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; instead of `#![no_main]`
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now &lt;code&gt;cargo test&lt;&#x2f;code&gt; works:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os)
    [some warnings]
    Finished dev [unoptimized + debuginfo] target(s) in 0.98 secs
     Running target&#x2f;debug&#x2f;deps&#x2f;blog_os-1f08396a9eff0aa7

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The test framework seems to work as intended. We don&#x27;t have any tests yet, but we already get a test result summary.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;silencing-the-warnings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#silencing-the-warnings&quot; aria-label=&quot;Anchor link for: silencing-the-warnings&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Silencing the Warnings&lt;&#x2f;h3&gt;
&lt;p&gt;We get a few warnings about unused imports, because we no longer compile our &lt;code&gt;_start&lt;&#x2f;code&gt; function. To silence such unused code warnings, we can add the following to the top of our &lt;code&gt;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![cfg_attr(test, allow(unused_imports))]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like before, the &lt;code&gt;cfg_attr&lt;&#x2f;code&gt; attribute sets the passed attribute if the passed condition holds. Here, we set the &lt;code&gt;allow(â€¦)&lt;&#x2f;code&gt; attribute when compiling in test mode. We use the &lt;code&gt;allow&lt;&#x2f;code&gt; attribute to disable warnings for the &lt;code&gt;unused_import&lt;&#x2f;code&gt; &lt;em&gt;lint&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Lints are classes of warnings, for example &lt;code&gt;dead_code&lt;&#x2f;code&gt; for unused code or &lt;code&gt;missing-docs&lt;&#x2f;code&gt; for missing documentation. Lints can be set to four different states:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;allow&lt;&#x2f;code&gt;: no errors, no warnings&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;warn&lt;&#x2f;code&gt;: causes a warning&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;deny&lt;&#x2f;code&gt;: causes a compilation error&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;forbid&lt;&#x2f;code&gt;: like &lt;code&gt;deny&lt;&#x2f;code&gt;, but can&#x27;t be overridden&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Some lints are &lt;code&gt;allow&lt;&#x2f;code&gt; by default (such as &lt;code&gt;missing-docs&lt;&#x2f;code&gt;), others are &lt;code&gt;warn&lt;&#x2f;code&gt; by default (such as &lt;code&gt;dead_code&lt;&#x2f;code&gt;), and some few are even &lt;code&gt;deny&lt;&#x2f;code&gt; by default.. The default can be overridden by the &lt;code&gt;allow&lt;&#x2f;code&gt;, &lt;code&gt;warn&lt;&#x2f;code&gt;, &lt;code&gt;deny&lt;&#x2f;code&gt; and &lt;code&gt;forbid&lt;&#x2f;code&gt; attributes. For a list of all lints, see &lt;code&gt;rustc -W help&lt;&#x2f;code&gt;. There is also the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang-nursery&#x2f;rust-clippy&quot;&gt;clippy&lt;&#x2f;a&gt; project, which provides many additional lints.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;including-the-standard-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#including-the-standard-library&quot; aria-label=&quot;Anchor link for: including-the-standard-library&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Including the Standard Library&lt;&#x2f;h3&gt;
&lt;p&gt;Unit tests run on the host machine, so it&#x27;s possible to use the complete standard library inside them. To link the standard library in test mode, we can make the &lt;code&gt;#![no_std]&lt;&#x2f;code&gt; attribute conditional through &lt;code&gt;cfg_attr&lt;&#x2f;code&gt; too:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;-#![no_std]
+#![cfg_attr(not(test), no_std)]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;testing-the-vga-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-the-vga-module&quot; aria-label=&quot;Anchor link for: testing-the-vga-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing the VGA Module&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we have set up the test framework, we can add a first unit test for our &lt;code&gt;vga_buffer&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    #[test]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;foo() {}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add the test in an inline &lt;code&gt;test&lt;&#x2f;code&gt; submodule. This isn&#x27;t necessary, but a common way to separate test code from the rest of the module. By adding the &lt;code&gt;#[cfg(test)]&lt;&#x2f;code&gt; attribute, we ensure that the module is only compiled in test mode. Through &lt;code&gt;use super::*&lt;&#x2f;code&gt;, we import all items of the parent module (the &lt;code&gt;vga_buffer&lt;&#x2f;code&gt; module), so that we can test them easily.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;#[test]&lt;&#x2f;code&gt; attribute on the &lt;code&gt;foo&lt;&#x2f;code&gt; function tells the test framework that the function is an unit test. The framework will find it automatically, even if it&#x27;s private and inside a private module as in our case:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo test
   Compiling blog_os v0.2.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 2.99 secs
     Running target&#x2f;debug&#x2f;deps&#x2f;blog_os-1f08396a9eff0aa7

running 1 test
test vga_buffer::test::foo ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that the test was found and executed. It didn&#x27;t panic, so it counts as passed.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;constructing-a-writer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#constructing-a-writer&quot; aria-label=&quot;Anchor link for: constructing-a-writer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Constructing a Writer&lt;&#x2f;h3&gt;
&lt;p&gt;In order to test the VGA methods, we first need to construct a &lt;code&gt;Writer&lt;&#x2f;code&gt; instance. Since we will need such an instance for other tests too, we create a separate function for it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[cfg(test)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_writer() -&amp;gt; Writer {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;std::boxed::Box;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; buffer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer();
        Writer {
            column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            color_code: ColorCode::new(Color::Blue, Color::Magenta),
            buffer: Box::leak(Box::new(buffer)),
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer { â€¦ }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We set the initial column position to 0 and choose some arbitrary colors for foreground and background color. The difficult part is the buffer construction, it&#x27;s described in detail below. We then use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;boxed&#x2f;struct.Box.html#method.new&quot;&gt;&lt;code&gt;Box::new&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;boxed&#x2f;struct.Box.html#method.leak&quot;&gt;&lt;code&gt;Box::leak&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; to transform the created &lt;code&gt;Buffer&lt;&#x2f;code&gt; into a &lt;code&gt;&amp;amp;&#x27;static mut Buffer&lt;&#x2f;code&gt;, because the &lt;code&gt;buffer&lt;&#x2f;code&gt; field needs to be of that type.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;buffer-construction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#buffer-construction&quot; aria-label=&quot;Anchor link for: buffer-construction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Buffer Construction&lt;&#x2f;h4&gt;
&lt;p&gt;So how do we create a &lt;code&gt;Buffer&lt;&#x2f;code&gt; instance? The naive approach does not work unfortunately:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer {
    Buffer {
        chars: [[Volatile::new(empty_char()); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;],
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;empty_char() -&amp;gt; ScreenChar {
    ScreenChar {
        ascii_character: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Green, Color::Brown),
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When running &lt;code&gt;cargo test&lt;&#x2f;code&gt; the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0277]: the trait bound `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;: core::marker::Copy` is not satisfied
   --&amp;gt; src&#x2f;vga_buffer.rs:186:21
    |
186 |             chars: [[Volatile::new(empty_char); BUFFER_WIDTH]; BUFFER_HEIGHT],
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `core::marker::Copy` is not implemented for `volatile::Volatile&amp;lt;vga_buffer::ScreenChar&amp;gt;`
    |
    = note: the `Copy` trait is required because the repeated element will be copied
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that array construction in Rust requires that the contained type is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. The &lt;code&gt;ScreenChar&lt;&#x2f;code&gt; is &lt;code&gt;Copy&lt;&#x2f;code&gt;, but the &lt;code&gt;Volatile&lt;&#x2f;code&gt; wrapper is not. There is currently no easy way to circumvent this without using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, but fortunately there is the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;array-init&quot;&gt;&lt;code&gt;array_init&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate that provides a safe interface for such operations.&lt;&#x2f;p&gt;
&lt;p&gt;To use that crate, we add the following to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dev-dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;array-init &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.0.3&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we&#x27;re using the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;specifying-dependencies.html#development-dependencies&quot;&gt;&lt;code&gt;dev-dependencies&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; table instead of the &lt;code&gt;dependencies&lt;&#x2f;code&gt; table, because we only need the crate for &lt;code&gt;cargo test&lt;&#x2f;code&gt; and not for a normal build.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can fix our &lt;code&gt;construct_buffer&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_buffer() -&amp;gt; Buffer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;array_init::array_init;

    Buffer {
        chars: array_init(|_| array_init(|_| Volatile::new(empty_char()))),
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;array-init&quot;&gt;documentation of &lt;code&gt;array_init&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for more information about using that crate.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-write-byte&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-write-byte&quot; aria-label=&quot;Anchor link for: testing-write-byte&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing &lt;code&gt;write_byte&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;Now we&#x27;re finally able to write a first unit test that tests the &lt;code&gt;write_byte&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    [â€¦]

    #[test]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_writer();
        writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, row) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer.buffer.chars.iter().enumerate() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(j, screen_char) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row.iter().enumerate() {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char.read();
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;X&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;Y&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char, empty_char());
                }
            }
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We construct a &lt;code&gt;Writer&lt;&#x2f;code&gt;, write two bytes to it, and then check that the right screen characters were updated. When we run &lt;code&gt;cargo test&lt;&#x2f;code&gt;, we see that the test is executed and passes:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;running 1 test
test vga_buffer::test::write_byte ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Try to play around a bit with this function and verify that the test fails if you change something, e.g. if you print a third byte without adjusting the &lt;code&gt;for&lt;&#x2f;code&gt; loop.&lt;&#x2f;p&gt;
&lt;p&gt;(If you&#x27;re getting an â€œbinary operation &lt;code&gt;==&lt;&#x2f;code&gt; cannot be applied to type &lt;code&gt;vga_buffer::ScreenChar&lt;&#x2f;code&gt;â€ error, you need to also derive &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cmp&#x2f;trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for &lt;code&gt;ScreenChar&lt;&#x2f;code&gt; and &lt;code&gt;ColorCode&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-strings&quot; aria-label=&quot;Anchor link for: testing-strings&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing Strings&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s add a second unit test to test formatted output and newline behavior:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test {
    [â€¦]

    #[test]
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_formatted() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;construct_writer();
        writeln!(&amp;amp;mut writer, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;a&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();
        writeln!(&amp;amp;mut writer, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;c&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, row) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer.buffer.chars.iter().enumerate() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(j, screen_char) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row.iter().enumerate() {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; screen_char.read();
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;a&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;b&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; j &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;c&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char.ascii_character, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                    assert_eq!(screen_char.color_code, writer.color_code);
                } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    assert_eq!(screen_char, empty_char());
                }
            }
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;In this test we&#x27;re using the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;macro.writeln.html&quot;&gt;&lt;code&gt;writeln!&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; macro to print strings with newlines to the buffer. Most of the for loop is similar to the &lt;code&gt;write_byte&lt;&#x2f;code&gt; test and only verifies if the written characters are at the expected place. The new &lt;code&gt;if i &amp;gt;= BUFFER_HEIGHT - 2&lt;&#x2f;code&gt; case verifies that the empty lines that are shifted in on a newline have the &lt;code&gt;writer.color_code&lt;&#x2f;code&gt;, which is different from the initial color.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;more-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-tests&quot; aria-label=&quot;Anchor link for: more-tests&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
More Tests&lt;&#x2f;h3&gt;
&lt;p&gt;We only present two basic tests here as an example, but of course many more tests are possible. For example a test that changes the writer color in between writes. Or a test that checks that the top line is correctly shifted off the screen on a newline. Or a test that checks that non-ASCII characters are handled correctly.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;Unit testing is a very useful technique to ensure that certain components have a desired behavior. Even if they cannot show the absence of bugs, they&#x27;re still an useful tool for finding them and especially for avoiding regressions.&lt;&#x2f;p&gt;
&lt;p&gt;This post explained how to set up unit testing in a Rust kernel. We now have a functioning test framework and can easily add tests by adding functions with a &lt;code&gt;#[test]&lt;&#x2f;code&gt; attribute. To run them, a short &lt;code&gt;cargo test&lt;&#x2f;code&gt; suffices. We also added a few basic tests for our VGA buffer as an example how unit tests could look like.&lt;&#x2f;p&gt;
&lt;p&gt;We also learned a bit about conditional compilation, Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;#silencing-the-warnings&quot;&gt;lint system&lt;&#x2f;a&gt;, how to &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;unit-testing&#x2f;#buffer-construction&quot;&gt;initialize arrays with non-Copy types&lt;&#x2f;a&gt;, and the &lt;code&gt;dev-dependencies&lt;&#x2f;code&gt; section of the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;We now have a working unit testing framework, which gives us the ability to test individual components. However, unit tests have the disadvantage that they run on the host machine and are thus unable to test how components interact with platform specific parts. For example, we can&#x27;t test the &lt;code&gt;println!&lt;&#x2f;code&gt; macro with an unit test because it wants to write at the VGA text buffer at address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;, which only exists in the bare metal environment.&lt;&#x2f;p&gt;
&lt;p&gt;The next post will close this gap by creating a basic &lt;em&gt;integration test&lt;&#x2f;em&gt; framework, which runs the tests in QEMU and thus has access to platform specific components. This will allow us to test the full system, for example that our kernel boots correctly or that no deadlock occurs on nested &lt;code&gt;println!&lt;&#x2f;code&gt; invocations.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Writing an OS in pure Rust</title>
                <pubDate>Fri, 09 Mar 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/news/pure-rust/</link>
                <guid>https://os.phil-opp.com/news/pure-rust/</guid>
                <description>&lt;p&gt;Over the past six months we&#x27;ve been working on a second edition of this blog. Our goals for this new version are &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;360&quot;&gt;numerous&lt;&#x2f;a&gt; and we are still not done yet, but today we reached a major milestone: It is now possible to build the OS natively on Windows, macOS, and Linux &lt;strong&gt;without any non-Rust dependendencies&lt;&#x2f;strong&gt;.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;&quot;&gt;first edition&lt;&#x2f;a&gt; required several C-tools for building:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;We used the &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;grub&#x2f;&quot;&gt;&lt;code&gt;GRUB&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; bootloader for booting our kernel. To create a bootable disk&#x2f;CD image we used the &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;grub&#x2f;manual&#x2f;grub&#x2f;html_node&#x2f;Invoking-grub_002dmkrescue.html&quot;&gt;&lt;code&gt;grub-mkrescue&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; tool, which is very difficult to get to run on Windows.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;xorriso&#x2f;&quot;&gt;&lt;code&gt;xorriso&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; program was also required, because it is used by &lt;code&gt;grub-mkrescue&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;GRUB only boots to protected mode, so we needed some assembly code for &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;&quot;&gt;entering long mode&lt;&#x2f;a&gt;. For building the assembly code, we used the &lt;a href=&quot;http:&#x2f;&#x2f;www.nasm.us&#x2f;xdoc&#x2f;2.13.03&#x2f;html&#x2f;nasmdoc1.html&quot;&gt;&lt;code&gt;nasm&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; assembler.&lt;&#x2f;li&gt;
&lt;li&gt;We used the GNU linker &lt;a href=&quot;https:&#x2f;&#x2f;ftp.gnu.org&#x2f;old-gnu&#x2f;Manuals&#x2f;ld-2.9.1&#x2f;html_node&#x2f;ld_3.html&quot;&gt;&lt;code&gt;ld&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for linking together the assembly files with the rust code, using a custom &lt;a href=&quot;http:&#x2f;&#x2f;www.scoberlin.de&#x2f;content&#x2f;media&#x2f;http&#x2f;informatik&#x2f;gcc_docs&#x2f;ld_3.html&quot;&gt;linker script&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;Finally, we used &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;make&#x2f;&quot;&gt;&lt;code&gt;make&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for automating the various build steps (assembling, compiling the Rust code, linking, invoking &lt;code&gt;grub-mkrescue&lt;&#x2f;code&gt;).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;We got lots of feedback that this setup was difficult to get running &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;55&quot;&gt;under macOS&lt;&#x2f;a&gt; and Windows. As a workaround, we &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;pull&#x2f;373&quot;&gt;added support for docker&lt;&#x2f;a&gt;, but that still required users to install and understand an additional dependency. So when we decided to create a second edition of the blog - originally because the order of posts led to jumps in difficulty - we thought about how we could avoid these C-dependencies.&lt;&#x2f;p&gt;
&lt;p&gt;There are lots of alternatives to &lt;code&gt;make&lt;&#x2f;code&gt;, including some Rust tools such as &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;casey&#x2f;just&quot;&gt;just&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;sagiegurari.github.io&#x2f;cargo-make&#x2f;&quot;&gt;cargo-make&lt;&#x2f;a&gt;. Avoiding &lt;code&gt;nasm&lt;&#x2f;code&gt; is also possible by using Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;global-asm.html&quot;&gt;&lt;code&gt;global_asm&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; feature instead. So there are only two problems left: the bootloader and the linker.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-custom-bootloader&quot;&gt;A custom Bootloader&lt;&#x2f;h2&gt;
&lt;p&gt;To avoid the dependency on GRUB and to make things more ergonomic, we decided to write &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootloader&quot;&gt;our own bootloader&lt;&#x2f;a&gt; using Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;global-asm.html&quot;&gt;&lt;code&gt;global_asm&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; feature. This way, the kernel can be significantly simplified, since the switch to long mode and the initial page table layout can already be done in the bootloader. Thus, we can avoid the initial assembly level blog posts in the second edition and directly start with high level Rust code.&lt;&#x2f;p&gt;
&lt;p&gt;The bootloader is still an early prototype, but it is already capable of switching to long mode and loading the kernel in form of an 64-bit ELF binary. It also performs the correct page table mapping (with the correct read&#x2f;write&#x2f;execute permissions) as it&#x27;s specified in the ELF file and creates an initial physical memory map.&lt;&#x2f;p&gt;
&lt;p&gt;The plan for the future is to make the bootloader more stable, add documentation, and ultimately add a â€œWriting a Bootloaderâ€ series to the blog, which explains in detail how the bootloader works.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;linking-with-lld&quot;&gt;Linking with LLD&lt;&#x2f;h2&gt;
&lt;p&gt;With our custom bootloader in place, the last remaining problem is platform independent linking. Fortunately there is &lt;a href=&quot;https:&#x2f;&#x2f;lld.llvm.org&#x2f;&quot;&gt;&lt;code&gt;LLD&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, the cross-platform linker from the LLVM project, which is already very stable for the &lt;code&gt;x86&lt;&#x2f;code&gt; architecture. As a bonus, &lt;code&gt;LLD&lt;&#x2f;code&gt; is &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;pull&#x2f;48125&quot;&gt;now shipped with Rust&lt;&#x2f;a&gt;, which means that it can be used without any extra installation.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-new-posts&quot;&gt;The new Posts&lt;&#x2f;h2&gt;
&lt;p&gt;The second edition is already live at &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;second-edition&#x2f;&quot;&gt;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;second-edition&lt;&#x2f;a&gt;. Please tell us if you have any feedback on the new posts! We&#x27;re planning to move over the content from the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;&quot;&gt;first edition&lt;&#x2f;a&gt; iteratively, in a different order and with various other improvements.&lt;&#x2f;p&gt;
&lt;p&gt;Many thanks to everyone who helped to make Rust an even better language for OS development!&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>VGA Text Mode</title>
                <pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/vga-text-mode/</link>
                <guid>https://os.phil-opp.com/vga-text-mode/</guid>
                <description>&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;VGA-compatible_text_mode&quot;&gt;VGA text mode&lt;&#x2f;a&gt; is a simple way to print text to the screen. In this post, we create an interface that makes its usage safe and simple, by encapsulating all unsafety in a separate module. We also implement support for Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;fmt&#x2f;#related-macros&quot;&gt;formatting macros&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-03&quot;&gt;&lt;code&gt;post-03&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;the-vga-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-vga-text-buffer&quot; aria-label=&quot;Anchor link for: the-vga-text-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The VGA Text Buffer&lt;&#x2f;h2&gt;
&lt;p&gt;To print a character to the screen in VGA text mode, one has to write it to the text buffer of the VGA hardware. The VGA text buffer is a two-dimensional array with typically 25 rows and 80 columns, which is directly rendered to the screen. Each array entry describes a single screen character through the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s) &lt;&#x2f;th&gt;&lt;th&gt;Value&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-7    &lt;&#x2f;td&gt;&lt;td&gt;ASCII code point&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8-11   &lt;&#x2f;td&gt;&lt;td&gt;Foreground color&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12-14  &lt;&#x2f;td&gt;&lt;td&gt;Background color&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;15     &lt;&#x2f;td&gt;&lt;td&gt;Blink&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The first byte represents the character that should be printed in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;ASCII&quot;&gt;ASCII encoding&lt;&#x2f;a&gt;. To be exact, it isn&#x27;t exactly ASCII, but a character set named &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Code_page_437&quot;&gt;&lt;em&gt;code page 437&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; with some additional characters and slight modifications. For simplicity, we proceed to call it an ASCII character in this post.&lt;&#x2f;p&gt;
&lt;p&gt;The second byte defines how the character is displayed. The first four bits define the foreground color, the next three bits the background color, and the last bit whether the character should blink. The following colors are available:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number &lt;&#x2f;th&gt;&lt;th&gt;Color      &lt;&#x2f;th&gt;&lt;th&gt;Number + Bright Bit &lt;&#x2f;th&gt;&lt;th&gt;Bright Color&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0x0    &lt;&#x2f;td&gt;&lt;td&gt;Black      &lt;&#x2f;td&gt;&lt;td&gt;0x8                 &lt;&#x2f;td&gt;&lt;td&gt;Dark Gray&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x1    &lt;&#x2f;td&gt;&lt;td&gt;Blue       &lt;&#x2f;td&gt;&lt;td&gt;0x9                 &lt;&#x2f;td&gt;&lt;td&gt;Light Blue&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x2    &lt;&#x2f;td&gt;&lt;td&gt;Green      &lt;&#x2f;td&gt;&lt;td&gt;0xa                 &lt;&#x2f;td&gt;&lt;td&gt;Light Green&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x3    &lt;&#x2f;td&gt;&lt;td&gt;Cyan       &lt;&#x2f;td&gt;&lt;td&gt;0xb                 &lt;&#x2f;td&gt;&lt;td&gt;Light Cyan&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x4    &lt;&#x2f;td&gt;&lt;td&gt;Red        &lt;&#x2f;td&gt;&lt;td&gt;0xc                 &lt;&#x2f;td&gt;&lt;td&gt;Light Red&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x5    &lt;&#x2f;td&gt;&lt;td&gt;Magenta    &lt;&#x2f;td&gt;&lt;td&gt;0xd                 &lt;&#x2f;td&gt;&lt;td&gt;Pink&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x6    &lt;&#x2f;td&gt;&lt;td&gt;Brown      &lt;&#x2f;td&gt;&lt;td&gt;0xe                 &lt;&#x2f;td&gt;&lt;td&gt;Yellow&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x7    &lt;&#x2f;td&gt;&lt;td&gt;Light Gray &lt;&#x2f;td&gt;&lt;td&gt;0xf                 &lt;&#x2f;td&gt;&lt;td&gt;White&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Bit 4 is the &lt;em&gt;bright bit&lt;&#x2f;em&gt;, which turns for example blue into light blue. For the background color, this bit is repurposed as the blink bit.&lt;&#x2f;p&gt;
&lt;p&gt;The VGA text buffer is accessible via &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory-mapped_I&#x2f;O&quot;&gt;memory-mapped I&#x2f;O&lt;&#x2f;a&gt; to the address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. This means that reads and writes to that address don&#x27;t access the RAM, but directly the text buffer on the VGA hardware. This means that we can read and write it through normal memory operations to that address.&lt;&#x2f;p&gt;
&lt;p&gt;Note that memory-mapped hardware might not support all normal RAM operations. For example, a device could only support byte-wise reads and return junk when an &lt;code&gt;u64&lt;&#x2f;code&gt; is read. Fortunately, the text buffer &lt;a href=&quot;https:&#x2f;&#x2f;web.stanford.edu&#x2f;class&#x2f;cs140&#x2f;projects&#x2f;pintos&#x2f;specs&#x2f;freevga&#x2f;vga&#x2f;vgamem.htm#manip&quot;&gt;supports normal reads and writes&lt;&#x2f;a&gt;, so that we don&#x27;t have to treat it in special way.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-rust-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-rust-module&quot; aria-label=&quot;Anchor link for: a-rust-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Rust Module&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we know how the VGA buffer works, we can create a Rust module to handle printing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;â€¯in src&#x2f;main.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For the content of this module we create a new &lt;code&gt;src&#x2f;vga_buffer.rs&lt;&#x2f;code&gt; file. All of the code below goes into our new module (unless specified otherwise).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;colors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#colors&quot; aria-label=&quot;Anchor link for: colors&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Colors&lt;&#x2f;h3&gt;
&lt;p&gt;First, we represent the different colors using an enum:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Color {
    Black &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Blue &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Green &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Cyan &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Red &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Magenta &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Brown &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightGray &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    DarkGray &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightBlue &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightGreen &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightCyan &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightRed &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Pink &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Yellow &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    White &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;custom_types&#x2f;enum&#x2f;c_like.html&quot;&gt;C-like enum&lt;&#x2f;a&gt; here to explicitly specify the number for each color. Because of the &lt;code&gt;repr(u8)&lt;&#x2f;code&gt; attribute each enum variant is stored as an &lt;code&gt;u8&lt;&#x2f;code&gt;. Actually 4 bits would be sufficient, but Rust doesn&#x27;t have an &lt;code&gt;u4&lt;&#x2f;code&gt; type.&lt;&#x2f;p&gt;
&lt;p&gt;Normally the compiler would issue a warning for each unused variant. By using the &lt;code&gt;#[allow(dead_code)]&lt;&#x2f;code&gt; attribute we disable these warnings for the &lt;code&gt;Color&lt;&#x2f;code&gt; enum.&lt;&#x2f;p&gt;
&lt;p&gt;By &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;trait&#x2f;derive.html&quot;&gt;deriving&lt;&#x2f;a&gt; the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;clone&#x2f;trait.Clone.html&quot;&gt;&lt;code&gt;Clone&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Debug.html&quot;&gt;&lt;code&gt;Debug&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cmp&#x2f;trait.PartialEq.html&quot;&gt;&lt;code&gt;PartialEq&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cmp&#x2f;trait.Eq.html&quot;&gt;&lt;code&gt;Eq&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; traits, we enable &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;first-edition&#x2f;ownership.html#copy-types&quot;&gt;copy semantics&lt;&#x2f;a&gt; for the type and make it printable and comparable.&lt;&#x2f;p&gt;
&lt;p&gt;To represent a full color code that specifies foreground and background color, we create a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;generics&#x2f;new_types.html&quot;&gt;newtype&lt;&#x2f;a&gt; on top of &lt;code&gt;u8&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(transparent)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ColorCode(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ColorCode {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(foreground: Color, background: Color) -&amp;gt; ColorCode {
        ColorCode((background &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(foreground &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;ColorCode&lt;&#x2f;code&gt; struct contains the full color byte, containing foreground and background color. Like before, we derive the &lt;code&gt;Copy&lt;&#x2f;code&gt; and &lt;code&gt;Debug&lt;&#x2f;code&gt; traits for it. To ensure that the &lt;code&gt;ColorCode&lt;&#x2f;code&gt; has the exact same data layout as an &lt;code&gt;u8&lt;&#x2f;code&gt;, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;other-reprs.html#reprtransparent&quot;&gt;&lt;code&gt;repr(transparent)&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; attribute.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#text-buffer&quot; aria-label=&quot;Anchor link for: text-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Text Buffer&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can add structures to represent a screen character and the text buffer:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ScreenChar {
    ascii_character: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;25&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;80&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

#[repr(transparent)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Buffer {
    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since the field ordering in default structs is undefined in Rust, we need the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;nomicon&#x2f;other-reprs.html#reprc&quot;&gt;&lt;code&gt;repr(C)&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; attribute. It guarantees that the struct&#x27;s fields are laid out exactly like in a C struct and thus guarantees the correct field ordering. For the &lt;code&gt;Buffer&lt;&#x2f;code&gt; struct, we use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;other-reprs.html#reprtransparent&quot;&gt;&lt;code&gt;repr(transparent)&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; again to ensure that it has the same memory layout as its single field.&lt;&#x2f;p&gt;
&lt;p&gt;To actually write to screen, we now create a writer type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode,
    buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The writer will always write to the last line and shift lines up when a line is full (or on &lt;code&gt;\n&lt;&#x2f;code&gt;). The &lt;code&gt;column_position&lt;&#x2f;code&gt; field keeps track of the current position in the last row. The current foreground and background colors are specified by &lt;code&gt;color_code&lt;&#x2f;code&gt; and a reference to the VGA buffer is stored in &lt;code&gt;buffer&lt;&#x2f;code&gt;. Note that we need an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-03-lifetime-syntax.html#lifetime-annotation-syntax&quot;&gt;explicit lifetime&lt;&#x2f;a&gt; here to tell the compiler how long the reference is valid. The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-03-lifetime-syntax.html#the-static-lifetime&quot;&gt;&lt;code&gt;&#x27;static&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; lifetime specifies that the reference is valid for the whole program run time (which is true for the VGA text buffer).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;printing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing&quot; aria-label=&quot;Anchor link for: printing&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can use the &lt;code&gt;Writer&lt;&#x2f;code&gt; to modify the buffer&#x27;s characters. First we create a method to write a single ASCII byte:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, byte: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.new_line(),
            byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    self.new_line();
                }

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.column_position;

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; color_code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.color_code;
                self.buffer.chars[row][col] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ScreenChar {
                    ascii_character: byte,
                    color_code,
                };
                self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            }
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new_line(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* TODO *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If the byte is the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Newline&quot;&gt;newline&lt;&#x2f;a&gt; byte &lt;code&gt;\n&lt;&#x2f;code&gt;, the writer does not print anything. Instead it calls a &lt;code&gt;new_line&lt;&#x2f;code&gt; method, which we&#x27;ll implement later. Other bytes get printed to the screen in the second match case.&lt;&#x2f;p&gt;
&lt;p&gt;When printing a byte, the writer checks if the current line is full. In that case, a &lt;code&gt;new_line&lt;&#x2f;code&gt; call is required before to wrap the line. Then it writes a new &lt;code&gt;ScreenChar&lt;&#x2f;code&gt; to the buffer at the current position. Finally, the current column position is advanced.&lt;&#x2f;p&gt;
&lt;p&gt;To print whole strings, we can convert them to bytes and print them one-by-one:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_string(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, s: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.bytes() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; printable ASCII byte or newline
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x20&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x7e &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.write_byte(byte),
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; not part of printable ASCII range
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xfe&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
            }

        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The VGA text buffer only supports ASCII and the additional bytes of &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Code_page_437&quot;&gt;code page 437&lt;&#x2f;a&gt;. Rust strings are &lt;a href=&quot;http:&#x2f;&#x2f;www.fileformat.info&#x2f;info&#x2f;unicode&#x2f;utf8.htm&quot;&gt;UTF-8&lt;&#x2f;a&gt; by default, so they might contain bytes that are not supported by the VGA text buffer. We use a match to differentiate printable ASCII bytes (a newline or anything in between a space character and a &lt;code&gt;~&lt;&#x2f;code&gt; character) and unprintable bytes. For unprintable bytes, we print a &lt;code&gt;â– &lt;&#x2f;code&gt; character, which has the hex code &lt;code&gt;0xfe&lt;&#x2f;code&gt; on the VGA hardware.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Try it out!&lt;&#x2f;h4&gt;
&lt;p&gt;To write some characters to the screen, you can create a temporary function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print_something() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
        column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Yellow, Color::Black),
        buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer) },
    };

    writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    writer.write_string(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    writer.write_string(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;WÃ¶rld!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It first creates a new Writer that points to the VGA buffer at &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. The syntax for this might seem a bit strange: First, we cast the integer &lt;code&gt;0xb8000&lt;&#x2f;code&gt; as an mutable &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2f;a&gt;. Then we convert it to a mutable reference by dereferencing it (through &lt;code&gt;*&lt;&#x2f;code&gt;) and immediately borrowing it again (through &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt;). This conversion requires an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2f;code&gt; block&lt;&#x2f;a&gt;, since the compiler can&#x27;t guarantee that the raw pointer is valid.&lt;&#x2f;p&gt;
&lt;p&gt;Then it writes the byte &lt;code&gt;b&#x27;H&#x27;&lt;&#x2f;code&gt; to it. The &lt;code&gt;b&lt;&#x2f;code&gt; prefix creates a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;tokens.html#byte-literals&quot;&gt;byte literal&lt;&#x2f;a&gt;, which represents an ASCII character. By writing the strings &lt;code&gt;&amp;quot;ello &amp;quot;&#x27;&lt;&#x2f;code&gt; and &lt;code&gt;&amp;quot;WÃ¶rld!&amp;quot;&lt;&#x2f;code&gt;, we test our &lt;code&gt;write_string&lt;&#x2f;code&gt; method and the handling of unprintable characters. To see the output, we need to call the &lt;code&gt;print_something&lt;&#x2f;code&gt; function from our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    vga_buffer::print_something();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run our project now, a &lt;code&gt;Hello Wâ– â– rld!&lt;&#x2f;code&gt; should be printed in the &lt;em&gt;lower&lt;&#x2f;em&gt; left corner of the screen in yellow:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;vga-hello.png&quot; alt=&quot;QEMU output with a yellow Hello Wâ– â– rld! in the lower left corner&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Notice that the &lt;code&gt;Ã¶&lt;&#x2f;code&gt; is printed as two &lt;code&gt;â– &lt;&#x2f;code&gt; characters. That&#x27;s because &lt;code&gt;Ã¶&lt;&#x2f;code&gt; is represented by two bytes in &lt;a href=&quot;http:&#x2f;&#x2f;www.fileformat.info&#x2f;info&#x2f;unicode&#x2f;utf8.htm&quot;&gt;UTF-8&lt;&#x2f;a&gt;, which both don&#x27;t fall into the printable ASCII range. In fact, this is a fundamental property of UTF-8: the individual bytes of multi-byte values are never valid ASCII.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;volatile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#volatile&quot; aria-label=&quot;Anchor link for: volatile&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Volatile&lt;&#x2f;h3&gt;
&lt;p&gt;We just saw that our message was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that we only write to the &lt;code&gt;Buffer&lt;&#x2f;code&gt; and never read from it again. The compiler doesn&#x27;t know that we really access VGA buffer memory (instead of normal RAM) and knows nothing about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted. To avoid this erroneous optimization, we need to specify these writes as &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Volatile_(computer_programming)&quot;&gt;volatile&lt;&#x2f;a&gt;&lt;&#x2f;em&gt;. This tells the compiler that the write has side effects and should not be optimized away.&lt;&#x2f;p&gt;
&lt;p&gt;In order to use volatile writes for the VGA buffer, we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;volatile&quot;&gt;volatile&lt;&#x2f;a&gt; library. This &lt;em&gt;crate&lt;&#x2f;em&gt; (this is how packages are called in the Rust world) provides a &lt;code&gt;Volatile&lt;&#x2f;code&gt; wrapper type with &lt;code&gt;read&lt;&#x2f;code&gt; and &lt;code&gt;write&lt;&#x2f;code&gt; methods. These methods internally use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ptr&#x2f;fn.read_volatile.html&quot;&gt;read_volatile&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ptr&#x2f;fn.write_volatile.html&quot;&gt;write_volatile&lt;&#x2f;a&gt; functions of the core library and thus guarantee that the reads&#x2f;writes are not optimized away.&lt;&#x2f;p&gt;
&lt;p&gt;We can add a dependency on the &lt;code&gt;volatile&lt;&#x2f;code&gt; crate by adding it to the &lt;code&gt;dependencies&lt;&#x2f;code&gt; section of our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;volatile &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.6&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;0.2.3&lt;&#x2f;code&gt; is the &lt;a href=&quot;http:&#x2f;&#x2f;semver.org&#x2f;&quot;&gt;semantic&lt;&#x2f;a&gt; version number. For more information, see the &lt;a href=&quot;http:&#x2f;&#x2f;doc.crates.io&#x2f;specifying-dependencies.html&quot;&gt;Specifying Dependencies&lt;&#x2f;a&gt; guide of the cargo documentation.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s use it to make writes to the VGA buffer volatile. We update our &lt;code&gt;Buffer&lt;&#x2f;code&gt; type as follows:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;volatile::Volatile;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Buffer {
    chars: [[Volatile&amp;lt;ScreenChar&amp;gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;ScreenChar&lt;&#x2f;code&gt;, we&#x27;re now using a &lt;code&gt;Volatile&amp;lt;ScreenChar&amp;gt;&lt;&#x2f;code&gt;. (The &lt;code&gt;Volatile&lt;&#x2f;code&gt; type is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-01-syntax.html&quot;&gt;generic&lt;&#x2f;a&gt; and can wrap (almost) any type). This ensures that we can&#x27;t accidentally write to it through a â€œnormalâ€ write. Instead, we have to use the &lt;code&gt;write&lt;&#x2f;code&gt; method now.&lt;&#x2f;p&gt;
&lt;p&gt;This means that we have to update our &lt;code&gt;Writer::write_byte&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, byte: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.new_line(),
            byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.buffer.chars[row][col].write(ScreenChar {
                    ascii_character: byte,
                    color_code: color_code,
                });
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
        }
    }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of a normal assignment using &lt;code&gt;=&lt;&#x2f;code&gt;, we&#x27;re now using the &lt;code&gt;write&lt;&#x2f;code&gt; method. This guarantees that the compiler will never optimize away this write.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;formatting-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#formatting-macros&quot; aria-label=&quot;Anchor link for: formatting-macros&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Formatting Macros&lt;&#x2f;h3&gt;
&lt;p&gt;It would be nice to support Rust&#x27;s formatting macros, too. That way, we can easily print different types like integers or floats. To support them, we need to implement the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Write.html&quot;&gt;&lt;code&gt;core::fmt::Write&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait. The only required method of this trait is &lt;code&gt;write_str&lt;&#x2f;code&gt; that looks quite similar to our &lt;code&gt;write_string&lt;&#x2f;code&gt; method, just with a &lt;code&gt;fmt::Result&lt;&#x2f;code&gt; return type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;fmt::Write &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, s: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; fmt::Result {
        self.write_string(s);
        Ok(())
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Ok(())&lt;&#x2f;code&gt; is just a &lt;code&gt;Ok&lt;&#x2f;code&gt; Result containing the &lt;code&gt;()&lt;&#x2f;code&gt; type.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use Rust&#x27;s built-in &lt;code&gt;write!&lt;&#x2f;code&gt;&#x2f;&lt;code&gt;writeln!&lt;&#x2f;code&gt; formatting macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print_something() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
        column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Yellow, Color::Black),
        buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer) },
    };

    writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    writer.write_string(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello! &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    write!(writer, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;The numbers are &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; and &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now you should see a &lt;code&gt;Hello! The numbers are 42 and 0.3333333333333333&lt;&#x2f;code&gt; at the bottom of the screen. The &lt;code&gt;write!&lt;&#x2f;code&gt; call returns a &lt;code&gt;Result&lt;&#x2f;code&gt; which causes a warning if not used, so we call the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;enum.Result.html#method.unwrap&quot;&gt;&lt;code&gt;unwrap&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function on it, which panics if an error occurs. This isn&#x27;t a problem in our case, since writes to the VGA buffer never fail.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;newlines&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#newlines&quot; aria-label=&quot;Anchor link for: newlines&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Newlines&lt;&#x2f;h3&gt;
&lt;p&gt;Right now, we just ignore newlines and characters that don&#x27;t fit into the line anymore. Instead we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the &lt;code&gt;new_line&lt;&#x2f;code&gt; method of &lt;code&gt;Writer&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new_line(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; character &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.buffer.chars[row][col].read();
                self.buffer.chars[row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;][col].write(character);
            }
        }
        self.clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, row: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* TODO *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We iterate over all screen characters and move each character one row up. Note that the range notation (&lt;code&gt;..&lt;&#x2f;code&gt;) is exclusive the upper bound. We also omit the 0th row (the first range starts at &lt;code&gt;1&lt;&#x2f;code&gt;) because it&#x27;s the row that is shifted off screen.&lt;&#x2f;p&gt;
&lt;p&gt;To finish the newline code, we add the &lt;code&gt;clear_row&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, row: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; blank &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ScreenChar {
            ascii_character: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            color_code: self.color_code,
        };
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            self.buffer.chars[row][col].write(blank);
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This method clears a row by overwriting all of its characters with a space character.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-global-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-global-interface&quot; aria-label=&quot;Anchor link for: a-global-interface&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Global Interface&lt;&#x2f;h2&gt;
&lt;p&gt;To provide a global writer that can be used as an interface from other modules without carrying a &lt;code&gt;Writer&lt;&#x2f;code&gt; instance around, we try to create a static &lt;code&gt;WRITER&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
    column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode::new(Color::Yellow, Color::Black),
    buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer) },
};
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, if we try to compile it now, the following errors occur:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants
 --&amp;gt; src&#x2f;vga_buffer.rs:7:17
  |
7 |     color_code: ColorCode::new(Color::Yellow, Color::Black),
  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0396]: raw pointers cannot be dereferenced in statics
 --&amp;gt; src&#x2f;vga_buffer.rs:8:22
  |
8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer in constant

error[E0017]: references in statics may only refer to immutable values
 --&amp;gt; src&#x2f;vga_buffer.rs:8:22
  |
8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
  |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values

error[E0017]: references in statics may only refer to immutable values
 --&amp;gt; src&#x2f;vga_buffer.rs:8:13
  |
8 |     buffer: unsafe { &amp;amp;mut *(0xb8000 as *mut Buffer) },
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ statics require immutable values
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To understand what&#x27;s happening here, we need to know that statics are initialized at compile time, in contrast to normal variables that are initialized at run time. The component of the Rust compiler that evaluates such initialization expressions is called the â€œ&lt;a href=&quot;https:&#x2f;&#x2f;rust-lang.github.io&#x2f;rustc-guide&#x2f;const-eval.html&quot;&gt;const evaluator&lt;&#x2f;a&gt;â€. Its functionality is still limited, but there is ongoing work to expand it, for example in the â€œ&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;2345&quot;&gt;Allow panicking in constants&lt;&#x2f;a&gt;â€ RFC.&lt;&#x2f;p&gt;
&lt;p&gt;The issue about &lt;code&gt;ColorCode::new&lt;&#x2f;code&gt; would be solvable by using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;unstable-book&#x2f;language-features&#x2f;const-fn.html&quot;&gt;&lt;code&gt;const&lt;&#x2f;code&gt; functions&lt;&#x2f;a&gt;, but the fundamental problem here is that Rust&#x27;s const evaluator is not able to convert raw pointers to references at compile time. Maybe it will work someday, but until then, we have to find another solution.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;lazy-statics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics&quot; aria-label=&quot;Anchor link for: lazy-statics&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Lazy Statics&lt;&#x2f;h3&gt;
&lt;p&gt;The one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;lazy_static&#x2f;1.0.1&#x2f;lazy_static&#x2f;&quot;&gt;lazy_static&lt;&#x2f;a&gt;. This crate provides a &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro that defines a lazily initialized &lt;code&gt;static&lt;&#x2f;code&gt;. Instead of computing its value at compile time, the &lt;code&gt;static&lt;&#x2f;code&gt; laziliy initializes itself when it&#x27;s accessed the first time. Thus, the initialization happens at runtime so that arbitrarily complex initialization code is possible.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; crate to our project:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2f;code&gt; feature, since we don&#x27;t link the standard library.&lt;&#x2f;p&gt;
&lt;p&gt;With &lt;code&gt;lazy_static&lt;&#x2f;code&gt;, we can define our static &lt;code&gt;WRITER&lt;&#x2f;code&gt; without problems:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static::lazy_static;

lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
        column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Yellow, Color::Black),
        buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer) },
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, this &lt;code&gt;WRITER&lt;&#x2f;code&gt; is pretty useless since it is immutable. This means that we can&#x27;t write anything to it (since all the write methods take &lt;code&gt;&amp;amp;mut self&lt;&#x2f;code&gt;). One possible solution would be to use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;mutable static&lt;&#x2f;a&gt;. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using &lt;code&gt;static mut&lt;&#x2f;code&gt; is highly discouraged, there were even proposals to &lt;a href=&quot;https:&#x2f;&#x2f;internals.rust-lang.org&#x2f;t&#x2f;pre-rfc-remove-static-mut&#x2f;1437&quot;&gt;remove it&lt;&#x2f;a&gt;. But what are the alternatives? We could try to use a immutable static with a cell type like &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch15-05-interior-mutability.html#keeping-track-of-borrows-at-runtime-with-refcellt&quot;&gt;RefCell&lt;&#x2f;a&gt; or even &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cell&#x2f;struct.UnsafeCell.html&quot;&gt;UnsafeCell&lt;&#x2f;a&gt; that provides &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch15-05-interior-mutability.html&quot;&gt;interior mutability&lt;&#x2f;a&gt;. But these types aren&#x27;t &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Sync.html&quot;&gt;Sync&lt;&#x2f;a&gt; (with good reason), so we can&#x27;t use them in statics.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;spinlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spinlocks&quot; aria-label=&quot;Anchor link for: spinlocks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Spinlocks&lt;&#x2f;h3&gt;
&lt;p&gt;To get synchronized interior mutability, users of the standard library can use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;sync&#x2f;struct.Mutex.html&quot;&gt;Mutex&lt;&#x2f;a&gt;. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can&#x27;t use it either. However there is a really basic kind of mutex in computer science that requires no operating system features: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Spinlock&quot;&gt;spinlock&lt;&#x2f;a&gt;. Instead of blocking, the threads simply try to lock it again and again in a tight loop and thus burn CPU time until the mutex is free again.&lt;&#x2f;p&gt;
&lt;p&gt;To use a spinning mutex, we can add the &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;spin&quot;&gt;spin crate&lt;&#x2f;a&gt; as a dependency:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;spin &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.5.2&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Then we can use the spinning Mutex to add safe &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch15-05-interior-mutability.html&quot;&gt;interior mutability&lt;&#x2f;a&gt; to our static &lt;code&gt;WRITER&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;Writer&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mutex::new(Writer {
        column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::Yellow, Color::Black),
        buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer) },
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can delete the &lt;code&gt;print_something&lt;&#x2f;code&gt; function and print directly from our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    vga_buffer::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello again&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();
    write!(vga_buffer::WRITER.lock(), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;, some numbers: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.337&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).unwrap();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need to import the &lt;code&gt;fmt::Write&lt;&#x2f;code&gt; trait in order to be able to use its functions.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h3&gt;
&lt;p&gt;Note that we only have a single unsafe block in our code, which is needed to create a &lt;code&gt;Buffer&lt;&#x2f;code&gt; reference pointing to &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. Afterwards, all operations are safe. Rust uses bounds checking for array accesses by default, so we can&#x27;t accidentally write outside the buffer. Thus, we encoded the required conditions in the type system and are able to provide a safe interface to the outside.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-println-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-println-macro&quot; aria-label=&quot;Anchor link for: a-println-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A println Macro&lt;&#x2f;h3&gt;
&lt;p&gt;Now that we have a global writer, we can add a &lt;code&gt;println&lt;&#x2f;code&gt; macro that can be used from anywhere in the codebase. Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;book&#x2f;ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming&quot;&gt;macro syntax&lt;&#x2f;a&gt; is a bit strange, so we won&#x27;t try to write a macro from scratch. Instead we look at the source of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.println!.html&quot;&gt;&lt;code&gt;println!&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; in the standard library:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! println {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Macros are defined through one or more rules, which are similar to &lt;code&gt;match&lt;&#x2f;code&gt; arms. The &lt;code&gt;println&lt;&#x2f;code&gt; macro has two rules: The first rule for is invocations without arguments (e.g &lt;code&gt;println!()&lt;&#x2f;code&gt;), which is expanded to &lt;code&gt;print!(&amp;quot;\n&amp;quot;)&lt;&#x2f;code&gt; and thus just prints a newline. the second rule is for invocations with parameters such as &lt;code&gt;println!(&amp;quot;Hello&amp;quot;)&lt;&#x2f;code&gt; or &lt;code&gt;println!(&amp;quot;Number: {}&amp;quot;, 4)&lt;&#x2f;code&gt;. It is also expanded to an invocation of the &lt;code&gt;print!&lt;&#x2f;code&gt; macro, passing all arguments and an additional newline &lt;code&gt;\n&lt;&#x2f;code&gt; at the end.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;#[macro_export]&lt;&#x2f;code&gt; attribute makes the available to the whole crate (not just the module it is defined) and external crates. It also places the macro at the crate root, which means that we have to import the macro through &lt;code&gt;use std::println&lt;&#x2f;code&gt; instead of &lt;code&gt;std::macros::println&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.print!.html&quot;&gt;&lt;code&gt;print!&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; is defined as:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::io::_print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The macro expands to a call of the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;29f5c699b11a6a148f097f82eaa05202f8799bbc&#x2f;src&#x2f;libstd&#x2f;io&#x2f;stdio.rs#L698&quot;&gt;&lt;code&gt;_print&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt; in the &lt;code&gt;io&lt;&#x2f;code&gt; module. The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;macros.html#the-variable-crate&quot;&gt;&lt;code&gt;$crate&lt;&#x2f;code&gt; variable&lt;&#x2f;a&gt; ensures that the macro also works from outside the &lt;code&gt;std&lt;&#x2f;code&gt; crate by expanding to &lt;code&gt;std&lt;&#x2f;code&gt; when it&#x27;s used in other crates.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.format_args.html&quot;&gt;&lt;code&gt;format_args&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; builds a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;struct.Arguments.html&quot;&gt;fmt::Arguments&lt;&#x2f;a&gt; type from the passed arguments, which is passed to &lt;code&gt;_print&lt;&#x2f;code&gt;. The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;29f5c699b11a6a148f097f82eaa05202f8799bbc&#x2f;src&#x2f;libstd&#x2f;io&#x2f;stdio.rs#L698&quot;&gt;&lt;code&gt;_print&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt; of libstd calls &lt;code&gt;print_to&lt;&#x2f;code&gt;, which is rather complicated because it supports different &lt;code&gt;Stdout&lt;&#x2f;code&gt; devices. We don&#x27;t need that complexity since we just want to print to the VGA buffer.&lt;&#x2f;p&gt;
&lt;p&gt;To print to the VGA buffer, we just copy the &lt;code&gt;println!&lt;&#x2f;code&gt; and &lt;code&gt;print!&lt;&#x2f;code&gt; macros, but modify them to use our own &lt;code&gt;_print&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_export]
macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::vga_buffer::_print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
}

#[macro_export]
macro_rules! println {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::print&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
}

#[doc(hidden)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_print(args: fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).unwrap();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;One thing that we changed from the original &lt;code&gt;println&lt;&#x2f;code&gt; definition is that we prefixed the invocations of the &lt;code&gt;print!&lt;&#x2f;code&gt; macro with &lt;code&gt;$crate&lt;&#x2f;code&gt; too. This ensures that we don&#x27;t need to have to import the &lt;code&gt;print!&lt;&#x2f;code&gt; macro too if we only want to use &lt;code&gt;println&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Like in the standard library, we add the &lt;code&gt;#[macro_export]&lt;&#x2f;code&gt; attribute to both macros to make them available everywhere in our crate. Note that this places the macros in the root namespace of the crate, so importing them via &lt;code&gt;use crate::vga_buffer::println&lt;&#x2f;code&gt; does not work. Instead, we have to do &lt;code&gt;use crate::println&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;_print&lt;&#x2f;code&gt; function locks our static &lt;code&gt;WRITER&lt;&#x2f;code&gt; and calls the &lt;code&gt;write_fmt&lt;&#x2f;code&gt; method on it. This method is from the &lt;code&gt;Write&lt;&#x2f;code&gt; trait, we need to import that trait. The additional &lt;code&gt;unwrap()&lt;&#x2f;code&gt; at the end panics if printing isn&#x27;t successful. But since we always return &lt;code&gt;Ok&lt;&#x2f;code&gt; in &lt;code&gt;write_str&lt;&#x2f;code&gt;, that should not happen.&lt;&#x2f;p&gt;
&lt;p&gt;Since the macros need to be able to call &lt;code&gt;_print&lt;&#x2f;code&gt; from outside of the module, the function needs to be public. However, since we consider this a private implementation detail, we add the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;rustdoc&#x2f;the-doc-attribute.html#dochidden&quot;&gt;&lt;code&gt;doc(hidden)&lt;&#x2f;code&gt; attribute&lt;&#x2f;a&gt; to hide it from the generated documentation.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;hello-world-using-println&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world-using-println&quot; aria-label=&quot;Anchor link for: hello-world-using-println&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hello World using &lt;code&gt;println&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can use &lt;code&gt;println&lt;&#x2f;code&gt; in our &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we don&#x27;t have to import the macro in the main function, because it already lives in the root namespace.&lt;&#x2f;p&gt;
&lt;p&gt;As expected, we now see a &lt;em&gt;â€œHello World!â€&lt;&#x2f;em&gt; on the screen:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;vga-hello-world.png&quot; alt=&quot;QEMU printing â€œHello World!â€&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;printing-panic-messages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-panic-messages&quot; aria-label=&quot;Anchor link for: printing-panic-messages&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing Panic Messages&lt;&#x2f;h3&gt;
&lt;p&gt;Now that we have a &lt;code&gt;println&lt;&#x2f;code&gt; macro, we can use it in our panic function to print the panic message and the location of the panic:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in main.rs

&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, info);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we now insert &lt;code&gt;panic!(&amp;quot;Some panic message&amp;quot;);&lt;&#x2f;code&gt; in our &lt;code&gt;_start&lt;&#x2f;code&gt; function, we get the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;vga-text-mode&#x2f;vga-panic.png&quot; alt=&quot;QEMU printing â€œpanicked at &#x27;Some panic message&#x27;, src&#x2f;main.rs:28:5&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;So we know not only that a panic has occurred, but also the panic message and where in the code it happened.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;In this post we learned about the structure of the VGA text buffer and how it can be written through the memory mapping at address &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. We created a Rust module that encapsulates the unsafety of writing to this memory mapped buffer and presents a safe and convenient interface to the outside.&lt;&#x2f;p&gt;
&lt;p&gt;We also saw how easy it is to add dependencies on third-party libraries, thanks to cargo. The two dependencies that we added, &lt;code&gt;lazy_static&lt;&#x2f;code&gt; and &lt;code&gt;spin&lt;&#x2f;code&gt;, are very useful in OS development and we will use them in more places in future posts.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The next post explains how to set up Rust&#x27;s built in unit test framework. We will then create some basic unit tests for the VGA buffer module from this post.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>A Freestanding Rust Binary</title>
                <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/freestanding-rust-binary/</link>
                <guid>https://os.phil-opp.com/freestanding-rust-binary/</guid>
                <description>&lt;p&gt;The first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Bare_machine&quot;&gt;bare metal&lt;&#x2f;a&gt; without an underlying operating system.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-01&quot;&gt;&lt;code&gt;post-01&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;To write an operating system kernel, we need code that does not depend on any operating system features. This means that we can&#x27;t use threads, files, heap memory, the network, random numbers, standard output, or any other features requiring OS abstractions or specific hardware. Which makes sense, since we&#x27;re trying to write our own OS and our own drivers.&lt;&#x2f;p&gt;
&lt;p&gt;This means that we can&#x27;t use most of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;&quot;&gt;Rust standard library&lt;&#x2f;a&gt;, but there are a lot of Rust features that we &lt;em&gt;can&lt;&#x2f;em&gt; use. For example, we can use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch13-02-iterators.html&quot;&gt;iterators&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch13-01-closures.html&quot;&gt;closures&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch06-00-enums.html&quot;&gt;pattern matching&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;option&#x2f;&quot;&gt;option&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;result&#x2f;&quot;&gt;result&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;macro.write.html&quot;&gt;string formatting&lt;&#x2f;a&gt;, and of course the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch04-00-understanding-ownership.html&quot;&gt;ownership system&lt;&#x2f;a&gt;. These features make it possible to write a kernel in a very expressive, high level way without worrying about &lt;a href=&quot;https:&#x2f;&#x2f;www.nayuki.io&#x2f;page&#x2f;undefined-behavior-in-c-and-cplusplus-programs&quot;&gt;undefined behavior&lt;&#x2f;a&gt; or &lt;a href=&quot;https:&#x2f;&#x2f;tonyarcieri.com&#x2f;it-s-time-for-a-memory-safety-intervention&quot;&gt;memory safety&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;In order to create an OS kernel in Rust, we need to create an executable that can be run without an underlying operating system. Such an executable is often called a â€œfreestandingâ€ or â€œbare-metalâ€ executable.&lt;&#x2f;p&gt;
&lt;p&gt;This post describes the necessary steps to create a freestanding Rust binary and explains why the steps are needed. If you&#x27;re just interested in a minimal example, you can &lt;strong&gt;&lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;#summary&quot;&gt;jump to the summary&lt;&#x2f;a&gt;&lt;&#x2f;strong&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;disabling-the-standard-library&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-the-standard-library&quot; aria-label=&quot;Anchor link for: disabling-the-standard-library&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Disabling the Standard Library&lt;&#x2f;h2&gt;
&lt;p&gt;By default, all Rust crates link the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;&quot;&gt;standard library&lt;&#x2f;a&gt;, which depends on the operating system for features such as threads, files, or networking. It also depends on the C standard library &lt;code&gt;libc&lt;&#x2f;code&gt;, which closely interacts with OS services. Since our plan is to write an operating system, we can not use any OS-dependent libraries. So we have to disable the automatic inclusion of the standard library through the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;using-rust-without-the-standard-library.html&quot;&gt;&lt;code&gt;no_std&lt;&#x2f;code&gt; attribute&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We start by creating a new cargo application project. The easiest way to do this is through the command line:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo new blog_os --bin --edition 2018
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I named the project &lt;code&gt;blog_os&lt;&#x2f;code&gt;, but of course you can choose your own name. The &lt;code&gt;--bin&lt;&#x2f;code&gt; flag specifies that we want to create an executable binary (in contrast to a library) and the &lt;code&gt;--edition 2018&lt;&#x2f;code&gt; flag specifies that we want to use the &lt;a href=&quot;https:&#x2f;&#x2f;rust-lang-nursery.github.io&#x2f;edition-guide&#x2f;rust-2018&#x2f;index.html&quot;&gt;2018 edition&lt;&#x2f;a&gt; of Rust for our crate. When we run the command, cargo creates the following directory structure for us:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;blog_os
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ main.rs
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; contains the crate configuration, for example the crate name, the author, the &lt;a href=&quot;http:&#x2f;&#x2f;semver.org&#x2f;&quot;&gt;semantic version&lt;&#x2f;a&gt; number, and dependencies. The &lt;code&gt;src&#x2f;main.rs&lt;&#x2f;code&gt; file contains the root module of our crate and our &lt;code&gt;main&lt;&#x2f;code&gt; function. You can compile your crate through &lt;code&gt;cargo build&lt;&#x2f;code&gt; and then run the compiled &lt;code&gt;blog_os&lt;&#x2f;code&gt; binary in the &lt;code&gt;target&#x2f;debug&lt;&#x2f;code&gt; subfolder.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-no-std-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-no-std-attribute&quot; aria-label=&quot;Anchor link for: the-no-std-attribute&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;no_std&lt;&#x2f;code&gt; Attribute&lt;&#x2f;h3&gt;
&lt;p&gt;Right now our crate implicitly links the standard library. Let&#x27;s try to disable this by adding the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;using-rust-without-the-standard-library.html&quot;&gt;&lt;code&gt;no_std&lt;&#x2f;code&gt; attribute&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main() {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we try to build it now (by running &lt;code&gt;cargo build&lt;&#x2f;code&gt;), the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: cannot find macro `println!` in this scope
 --&amp;gt; src&#x2f;main.rs:4:5
  |
4 |     println!(&amp;quot;Hello, world!&amp;quot;);
  |     ^^^^^^^
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason for this error is that the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;macro.println.html&quot;&gt;&lt;code&gt;println&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; is part of the standard library, which we no longer include. So we can no longer print things. This makes sense, since &lt;code&gt;println&lt;&#x2f;code&gt; writes to &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Standard_streams#Standard_output_.28stdout.29&quot;&gt;standard output&lt;&#x2f;a&gt;, which is a special file descriptor provided by the operating system.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s remove the printing and try again with an empty main function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;main() {}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo build
error: `#[panic_handler]` function required, but not found
error: language item required, but not found: `eh_personality`
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the compiler is missing a &lt;code&gt;#[panic_handler]&lt;&#x2f;code&gt; function and a &lt;em&gt;language item&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;panic-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#panic-implementation&quot; aria-label=&quot;Anchor link for: panic-implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Panic Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;code&gt;panic_handler&lt;&#x2f;code&gt; attribute defines the function that the compiler should invoke when a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch09-01-unrecoverable-errors-with-panic.html&quot;&gt;panic&lt;&#x2f;a&gt; occurs. The standard library provides its own panic handler function, but in a &lt;code&gt;no_std&lt;&#x2f;code&gt; environment we need to define it ourselves:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;panic&#x2f;struct.PanicInfo.html&quot;&gt;&lt;code&gt;PanicInfo&lt;&#x2f;code&gt; parameter&lt;&#x2f;a&gt; contains the file and line where the panic happened and the optional panic message. The function should never return, so it is marked as a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;first-edition&#x2f;functions.html#diverging-functions&quot;&gt;diverging function&lt;&#x2f;a&gt; by returning the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;primitive.never.html&quot;&gt;â€œneverâ€ type&lt;&#x2f;a&gt; &lt;code&gt;!&lt;&#x2f;code&gt;. There is not much we can do in this function for now, so we just loop indefinitely.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-eh-personality-language-item&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-eh-personality-language-item&quot; aria-label=&quot;Anchor link for: the-eh-personality-language-item&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;eh_personality&lt;&#x2f;code&gt; Language Item&lt;&#x2f;h2&gt;
&lt;p&gt;Language items are special functions and types that are required internally by the compiler. For example, the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;&lt;code&gt;Copy&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; trait is a language item that tells the compiler which types have &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;&lt;em&gt;copy semantics&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. When we look at the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;485397e49a02a3b7ff77c17e4a3f16c653925cb3&#x2f;src&#x2f;libcore&#x2f;marker.rs#L296-L299&quot;&gt;implementation&lt;&#x2f;a&gt;, we see it has the special &lt;code&gt;#[lang = &amp;quot;copy&amp;quot;]&lt;&#x2f;code&gt; attribute that defines it as a language item.&lt;&#x2f;p&gt;
&lt;p&gt;Providing own implementations of language items would be possible, but this should only be done as a last resort. The reason is that language items are highly unstable implementation details and not even type checked (so the compiler doesn&#x27;t even check if a function has the right argument types). Fortunately, there is a more stable ways to fix the above language item error.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;eh_personality&lt;&#x2f;code&gt; language item marks a function that is used for implementing &lt;a href=&quot;http:&#x2f;&#x2f;www.bogotobogo.com&#x2f;cplusplus&#x2f;stackunwinding.php&quot;&gt;stack unwinding&lt;&#x2f;a&gt;. By default, Rust uses unwinding to run the destructors of all live stack variables in case of a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch09-01-unrecoverable-errors-with-panic.html&quot;&gt;panic&lt;&#x2f;a&gt;. This ensures that all used memory is freed and allows the parent thread to catch the panic and continue execution. Unwinding, however, is a complicated process and requires some OS specific libraries (e.g. &lt;a href=&quot;http:&#x2f;&#x2f;www.nongnu.org&#x2f;libunwind&#x2f;&quot;&gt;libunwind&lt;&#x2f;a&gt; on Linux or &lt;a href=&quot;https:&#x2f;&#x2f;msdn.microsoft.com&#x2f;en-us&#x2f;library&#x2f;windows&#x2f;desktop&#x2f;ms680657(v=vs.85).aspx&quot;&gt;structured exception handling&lt;&#x2f;a&gt; on Windows), so we don&#x27;t want to use it for our operating system.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;disabling-unwinding&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-unwinding&quot; aria-label=&quot;Anchor link for: disabling-unwinding&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Disabling Unwinding&lt;&#x2f;h3&gt;
&lt;p&gt;There are other use cases as well for which unwinding is undesirable, so Rust provides an option to &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;pull&#x2f;32900&quot;&gt;abort on panic&lt;&#x2f;a&gt; instead. This disables the generation of unwinding symbol information and thus considerably reduces binary size. There are multiple places where we can disable unwinding. The easiest way is to add the following lines to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.dev&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.release&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This sets the panic strategy to &lt;code&gt;abort&lt;&#x2f;code&gt; for both the &lt;code&gt;dev&lt;&#x2f;code&gt; profile (used for &lt;code&gt;cargo build&lt;&#x2f;code&gt;) and the &lt;code&gt;release&lt;&#x2f;code&gt; profile (used for &lt;code&gt;cargo build --release&lt;&#x2f;code&gt;). Now the &lt;code&gt;eh_personality&lt;&#x2f;code&gt; language item should no longer be required.&lt;&#x2f;p&gt;
&lt;p&gt;Now we fixed both of the above errors. However, if we try to compile it now, another error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo build
error: requires `start` lang_item
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our program is missing the &lt;code&gt;start&lt;&#x2f;code&gt; language item, which defines the entry point.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-start-attribute&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-start-attribute&quot; aria-label=&quot;Anchor link for: the-start-attribute&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;start&lt;&#x2f;code&gt; attribute&lt;&#x2f;h2&gt;
&lt;p&gt;One might think that the &lt;code&gt;main&lt;&#x2f;code&gt; function is the first function called when you run a program. However, most languages have a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Runtime_system&quot;&gt;runtime system&lt;&#x2f;a&gt;, which is responsible for things such as garbage collection (e.g. in Java) or software threads (e.g. goroutines in Go). This runtime needs to be called before &lt;code&gt;main&lt;&#x2f;code&gt;, since it needs to initialize itself.&lt;&#x2f;p&gt;
&lt;p&gt;In a typical Rust binary that links the standard library, execution starts in a C runtime library called &lt;code&gt;crt0&lt;&#x2f;code&gt; (â€œC runtime zeroâ€), which sets up the environment for a C application. This includes creating a stack and placing the arguments in the right registers. The C runtime then invokes the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;bb4d1491466d8239a7a5fd68bd605e3276e97afb&#x2f;src&#x2f;libstd&#x2f;rt.rs#L32-L73&quot;&gt;entry point of the Rust runtime&lt;&#x2f;a&gt;, which is marked by the &lt;code&gt;start&lt;&#x2f;code&gt; language item. Rust only has a very minimal runtime, which takes care of some small things such as setting up stack overflow guards or printing a backtrace on panic. The runtime then finally calls the &lt;code&gt;main&lt;&#x2f;code&gt; function.&lt;&#x2f;p&gt;
&lt;p&gt;Our freestanding executable does not have access to the Rust runtime and &lt;code&gt;crt0&lt;&#x2f;code&gt;, so we need to define our own entry point. Implementing the &lt;code&gt;start&lt;&#x2f;code&gt; language item wouldn&#x27;t help, since it would still require &lt;code&gt;crt0&lt;&#x2f;code&gt;. Instead, we need to overwrite the &lt;code&gt;crt0&lt;&#x2f;code&gt; entry point directly.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;overwriting-the-entry-point&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overwriting-the-entry-point&quot; aria-label=&quot;Anchor link for: overwriting-the-entry-point&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overwriting the Entry Point&lt;&#x2f;h3&gt;
&lt;p&gt;To tell the Rust compiler that we don&#x27;t want to use the normal entry point chain, we add the &lt;code&gt;#![no_main]&lt;&#x2f;code&gt; attribute.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std]
#![no_main]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You might notice that we removed the &lt;code&gt;main&lt;&#x2f;code&gt; function. The reason is that a &lt;code&gt;main&lt;&#x2f;code&gt; doesn&#x27;t make sense without an underlying runtime that calls it. Instead, we are now overwriting the operating system entry point with our own &lt;code&gt;_start&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By using the &lt;code&gt;#[no_mangle]&lt;&#x2f;code&gt; attribute we disable the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Name_mangling&quot;&gt;name mangling&lt;&#x2f;a&gt; to ensure that the Rust compiler really outputs a function with the name &lt;code&gt;_start&lt;&#x2f;code&gt;. Without the attribute, the compiler would generate some cryptic &lt;code&gt;_ZN3blog_os4_start7hb173fedf945531caE&lt;&#x2f;code&gt; symbol to give every function an unique name. The attribute is required because we need to tell the name of the entry point function to the linker in the next step.&lt;&#x2f;p&gt;
&lt;p&gt;We also have to mark the function as &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2f;code&gt; to tell the compiler that it should use the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;C calling convention&lt;&#x2f;a&gt; for this function (instead of the unspecified Rust calling convention). The reason for naming the function &lt;code&gt;_start&lt;&#x2f;code&gt; is that this is the default entry point name for most systems.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;!&lt;&#x2f;code&gt; return type means that the function is diverging, i.e. not allowed to ever return. This is required because the entry point is not called by any function, but invoked directly by the operating system or bootloader. So instead of returning, the entry point should e.g. invoke the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Exit_(system_call)&quot;&gt;&lt;code&gt;exit&lt;&#x2f;code&gt; system call&lt;&#x2f;a&gt; of the operating system. In our case, shutting down the machine could be a reasonable action, since there&#x27;s nothing left to do if a freestanding binary returns. For now, we fulfill the requirement by looping endlessly.&lt;&#x2f;p&gt;
&lt;p&gt;When we run &lt;code&gt;cargo build&lt;&#x2f;code&gt; now, we get an ugly &lt;em&gt;linker&lt;&#x2f;em&gt; error.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;linker-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linker-errors&quot; aria-label=&quot;Anchor link for: linker-errors&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Linker Errors&lt;&#x2f;h2&gt;
&lt;p&gt;The linker is a program that combines the generated code into an executable. Since the executable format differs between Linux, Windows, and macOS, each system has its own linker that throws a different error. The fundamental cause of the errors is the same: the default configuration of the linker assumes that our program depends on the C runtime, which it does not.&lt;&#x2f;p&gt;
&lt;p&gt;To solve the errors, we need to tell the linker that it should not include the C runtime. We can do this either by passing a certain set of arguments to the linker or by building for a bare metal target.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;building-for-a-bare-metal-target&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-for-a-bare-metal-target&quot; aria-label=&quot;Anchor link for: building-for-a-bare-metal-target&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Building for a Bare Metal Target&lt;&#x2f;h3&gt;
&lt;p&gt;By default Rust tries to build an executable that is able to run in your current system environment. For example, if you&#x27;re using Windows on &lt;code&gt;x86_64&lt;&#x2f;code&gt;, Rust tries to build a &lt;code&gt;.exe&lt;&#x2f;code&gt; Windows executable that uses &lt;code&gt;x86_64&lt;&#x2f;code&gt; instructions. This environment is called your &amp;quot;host&amp;quot; system.&lt;&#x2f;p&gt;
&lt;p&gt;To describe different environments, Rust uses a string called &lt;a href=&quot;https:&#x2f;&#x2f;clang.llvm.org&#x2f;docs&#x2f;CrossCompilation.html#target-triple&quot;&gt;&lt;em&gt;target triple&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;. You can see the target triple for your host system by running &lt;code&gt;rustc --version --verbose&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rustc 1.35.0-nightly (474e7a648 2019-04-07)
binary: rustc
commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab
commit-date: 2019-04-07
host: x86_64-unknown-linux-gnu
release: 1.35.0-nightly
LLVM version: 8.0
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The above output is from a &lt;code&gt;x86_64&lt;&#x2f;code&gt; Linux system. We see that the &lt;code&gt;host&lt;&#x2f;code&gt; triple is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt;, which includes the CPU architecture (&lt;code&gt;x86_64&lt;&#x2f;code&gt;), the vendor (&lt;code&gt;unknown&lt;&#x2f;code&gt;), the operating system (&lt;code&gt;linux&lt;&#x2f;code&gt;), and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Application_binary_interface&quot;&gt;ABI&lt;&#x2f;a&gt; (&lt;code&gt;gnu&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;By compiling for our host triple, the Rust compiler and the linker assume that there is an underlying operating system such as Linux or Windows that use the C runtime by default, which causes the linker errors. So to avoid the linker errors, we can compile for a different environment with no underlying operating system.&lt;&#x2f;p&gt;
&lt;p&gt;An example for such a bare metal environment is the &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2f;code&gt; target triple, which describes an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Embedded_system&quot;&gt;embedded&lt;&#x2f;a&gt; &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;ARM_architecture&quot;&gt;ARM&lt;&#x2f;a&gt; system. The details are not important, all that matters is that the target triple has no underlying operating system, which is indicated by the &lt;code&gt;none&lt;&#x2f;code&gt; in the target triple. To be able to compile for this target, we need to add it in rustup:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rustup target add thumbv7em-none-eabihf
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This downloads a copy of the standard (and core) library for the system. Now we can build our freestanding executable for this target:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo build --target thumbv7em-none-eabihf
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By passing a &lt;code&gt;--target&lt;&#x2f;code&gt; argument we &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Cross_compiler&quot;&gt;cross compile&lt;&#x2f;a&gt; our executable for a bare metal target system. Since the target system has no operating system, the linker does not try to link the C runtime and our build succeeds without any linker errors.&lt;&#x2f;p&gt;
&lt;p&gt;This is the approach that we will use for building our OS kernel. Instead of &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2f;code&gt;, we will use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rustc&#x2f;targets&#x2f;custom.html&quot;&gt;custom target&lt;&#x2f;a&gt; that describes a &lt;code&gt;x86_64&lt;&#x2f;code&gt; bare metal environment. The details will be explained in the next post.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;linker-arguments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linker-arguments&quot; aria-label=&quot;Anchor link for: linker-arguments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Linker Arguments&lt;&#x2f;h3&gt;
&lt;p&gt;Instead of compiling for a bare metal system, it is also possible to resolve the linker errors by passing a certain set of arguments to the linker. This isn&#x27;t the approach that we will use for our kernel, therefore this section is optional and only provided for completeness. Click on &lt;em&gt;&amp;quot;Linker Arguments&amp;quot;&lt;&#x2f;em&gt; below to show the optional content.&lt;&#x2f;p&gt;
&lt;details&gt;
&lt;summary&gt;Linker Arguments&lt;&#x2f;summary&gt;
&lt;p&gt;In this section we discuss the linker errors that occur on Linux, Windows, and macOS, and explain how to solve them by passing additional arguments to the linker. Note that the executable format and the linker differ between operating systems, so that a different set of arguments is required for each system.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;linux&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#linux&quot; aria-label=&quot;Anchor link for: linux&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Linux&lt;&#x2f;h4&gt;
&lt;p&gt;On Linux the following linker error occurs (shortened):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; [â€¦]
  = note: &#x2f;usr&#x2f;lib&#x2f;gcc&#x2f;..&#x2f;x86_64-linux-gnu&#x2f;Scrt1.o: In function `_start&amp;#39;:
          (.text+0x12): undefined reference to `__libc_csu_fini&amp;#39;
          &#x2f;usr&#x2f;lib&#x2f;gcc&#x2f;..&#x2f;x86_64-linux-gnu&#x2f;Scrt1.o: In function `_start&amp;#39;:
          (.text+0x19): undefined reference to `__libc_csu_init&amp;#39;
          &#x2f;usr&#x2f;lib&#x2f;gcc&#x2f;..&#x2f;x86_64-linux-gnu&#x2f;Scrt1.o: In function `_start&amp;#39;:
          (.text+0x25): undefined reference to `__libc_start_main&amp;#39;
          collect2: error: ld returned 1 exit status
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that the linker includes the startup routine of the C runtime by default, which is also called &lt;code&gt;_start&lt;&#x2f;code&gt;. It requires some symbols of the C standard library &lt;code&gt;libc&lt;&#x2f;code&gt; that we don&#x27;t include due to the &lt;code&gt;no_std&lt;&#x2f;code&gt; attribute, therefore the linker can&#x27;t resolve these references. To solve this, we can tell the linker that it should not link the C startup routine by passing the &lt;code&gt;-nostartfiles&lt;&#x2f;code&gt; flag.&lt;&#x2f;p&gt;
&lt;p&gt;One way to pass linker attributes via cargo is the &lt;code&gt;cargo rustc&lt;&#x2f;code&gt; command. The command behaves exactly like &lt;code&gt;cargo build&lt;&#x2f;code&gt;, but allows to pass options to &lt;code&gt;rustc&lt;&#x2f;code&gt;, the underlying Rust compiler. &lt;code&gt;rustc&lt;&#x2f;code&gt; has the &lt;code&gt;-C link-arg&lt;&#x2f;code&gt; flag, which passes an argument to the linker. Combined, our new build command looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-arg=-nostartfiles
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now our crate builds as a freestanding executable on Linux!&lt;&#x2f;p&gt;
&lt;p&gt;We didn&#x27;t need to specify the name of our entry point function explicitly since the linker looks for a function with the name &lt;code&gt;_start&lt;&#x2f;code&gt; by default.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;windows&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#windows&quot; aria-label=&quot;Anchor link for: windows&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Windows&lt;&#x2f;h4&gt;
&lt;p&gt;On Windows, a different linker error occurs (shortened):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `link.exe` failed: exit code: 1561
  |
  = note: &amp;quot;C:\\Program Files (x86)\\â€¦\\link.exe&amp;quot; [â€¦]
  = note: LINK : fatal error LNK1561: entry point must be defined
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &amp;quot;entry point must be defined&amp;quot; error means that the linker can&#x27;t find the entry point. On Windows, the default entry point name &lt;a href=&quot;https:&#x2f;&#x2f;docs.microsoft.com&#x2f;en-us&#x2f;cpp&#x2f;build&#x2f;reference&#x2f;entry-entry-point-symbol&quot;&gt;depends on the used subsystem&lt;&#x2f;a&gt;. For the &lt;code&gt;CONSOLE&lt;&#x2f;code&gt; subsystem the linker looks for a function named &lt;code&gt;mainCRTStartup&lt;&#x2f;code&gt; and for the &lt;code&gt;WINDOWS&lt;&#x2f;code&gt; subsystem it looks for a function named &lt;code&gt;WinMainCRTStartup&lt;&#x2f;code&gt;. To override the default and tell the linker to look for our &lt;code&gt;_start&lt;&#x2f;code&gt; function instead, we can pass an &lt;code&gt;&#x2f;ENTRY&lt;&#x2f;code&gt; argument to the linker:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-arg=&#x2f;ENTRY:_start
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;From the different argument format we clearly see that the Windows linker is a completely different program than the Linux linker.&lt;&#x2f;p&gt;
&lt;p&gt;Now a different linker error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `link.exe` failed: exit code: 1221
  |
  = note: &amp;quot;C:\\Program Files (x86)\\â€¦\\link.exe&amp;quot; [â€¦]
  = note: LINK : fatal error LNK1221: a subsystem can&amp;#39;t be inferred and must be
          defined
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This error occurs because Windows executables can use different &lt;a href=&quot;https:&#x2f;&#x2f;docs.microsoft.com&#x2f;en-us&#x2f;cpp&#x2f;build&#x2f;reference&#x2f;entry-entry-point-symbol&quot;&gt;subsystems&lt;&#x2f;a&gt;. For normal programs they are inferred depending on the entry point name: If the entry point is named &lt;code&gt;main&lt;&#x2f;code&gt;, the &lt;code&gt;CONSOLE&lt;&#x2f;code&gt; subsystem is used, and if the entry point is named &lt;code&gt;WinMain&lt;&#x2f;code&gt;, the &lt;code&gt;WINDOWS&lt;&#x2f;code&gt; subsystem is used. Since our &lt;code&gt;_start&lt;&#x2f;code&gt; function has a different name, we need to specify the subsystem explicitly:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&amp;quot;&#x2f;ENTRY:_start &#x2f;SUBSYSTEM:console&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;code&gt;CONSOLE&lt;&#x2f;code&gt; subsystem here, but the &lt;code&gt;WINDOWS&lt;&#x2f;code&gt; subsystem would work too. Instead of passing &lt;code&gt;-C link-arg&lt;&#x2f;code&gt; multiple times, we use &lt;code&gt;-C link-args&lt;&#x2f;code&gt; which takes a space separated list of arguments.&lt;&#x2f;p&gt;
&lt;p&gt;With this command, our executable should build successfully on Windows.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;macos&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#macos&quot; aria-label=&quot;Anchor link for: macos&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
macOS&lt;&#x2f;h4&gt;
&lt;p&gt;On macOS, the following linker error occurs (shortened):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; [â€¦]
  = note: ld: entry point (_main) undefined. for architecture x86_64
          clang: error: linker command failed with exit code 1 [â€¦]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This error message tells us that the linker can&#x27;t find an entry point function with the default name &lt;code&gt;main&lt;&#x2f;code&gt; (for some reason all functions are prefixed with a &lt;code&gt;_&lt;&#x2f;code&gt; on macOS). To set the entry point to our &lt;code&gt;_start&lt;&#x2f;code&gt; function, we pass the &lt;code&gt;-e&lt;&#x2f;code&gt; linker argument:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&amp;quot;-e __start&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;-e&lt;&#x2f;code&gt; flag specifies the name of the entry point function. Since all functions have an additional &lt;code&gt;_&lt;&#x2f;code&gt; prefix on macOS, we need to set the entry point to &lt;code&gt;__start&lt;&#x2f;code&gt; instead of &lt;code&gt;_start&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now the following linker error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; [â€¦]
  = note: ld: dynamic main executables must link with libSystem.dylib
          for architecture x86_64
          clang: error: linker command failed with exit code 1 [â€¦]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;macOS &lt;a href=&quot;https:&#x2f;&#x2f;developer.apple.com&#x2f;library&#x2f;content&#x2f;qa&#x2f;qa1118&#x2f;_index.html&quot;&gt;does not officially support statically linked binaries&lt;&#x2f;a&gt; and requires programs to link the &lt;code&gt;libSystem&lt;&#x2f;code&gt; library by default. To override this and link a static binary, we pass the &lt;code&gt;-static&lt;&#x2f;code&gt; flag to the linker:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&amp;quot;-e __start -static&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This still not suffices, as a third linker error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: linking with `cc` failed: exit code: 1
  |
  = note: &amp;quot;cc&amp;quot; [â€¦]
  = note: ld: library not found for -lcrt0.o
          clang: error: linker command failed with exit code 1 [â€¦]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This error occurs because programs on macOS link to &lt;code&gt;crt0&lt;&#x2f;code&gt; (â€œC runtime zeroâ€) by default. This is similar to the error we had on Linux and can be also solved by adding the &lt;code&gt;-nostartfiles&lt;&#x2f;code&gt; linker argument:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&amp;quot;-e __start -static -nostartfiles&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now our program should build successfully on macOS.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;unifying-the-build-commands&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unifying-the-build-commands&quot; aria-label=&quot;Anchor link for: unifying-the-build-commands&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Unifying the Build Commands&lt;&#x2f;h4&gt;
&lt;p&gt;Right now we have different build commands depending on the host platform, which is not ideal. To avoid this, we can create a file named &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; that contains the platform specific arguments:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2f;config

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;linux&amp;quot;)&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-arg=-nostartfiles&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;windows&amp;quot;)&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-args=&#x2f;ENTRY:_start &#x2f;SUBSYSTEM:console&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;macos&amp;quot;)&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rustflags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-C&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;link-args=-e __start -static -nostartfiles&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;rustflags&lt;&#x2f;code&gt; key contains arguments that are automatically added to every invocation of &lt;code&gt;rustc&lt;&#x2f;code&gt;. For more information on the &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; file check out the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;config.html&quot;&gt;official documentation&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now our program should be buildable on all three platforms with a simple &lt;code&gt;cargo build&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;should-you-do-this&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#should-you-do-this&quot; aria-label=&quot;Anchor link for: should-you-do-this&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Should You Do This?&lt;&#x2f;h4&gt;
&lt;p&gt;While it&#x27;s possible to build a freestanding executable for Linux, Windows, and macOS, it&#x27;s probably not a good idea. The reason is that our executable still expects various things, for example that a stack is initialized when the &lt;code&gt;_start&lt;&#x2f;code&gt; function is called. Without the C runtime, some of these requirements might not be fulfilled, which might cause our program to fail, e.g. through a segmentation fault.&lt;&#x2f;p&gt;
&lt;p&gt;If you want to create a minimal binary that runs on top of an existing operating system, including &lt;code&gt;libc&lt;&#x2f;code&gt; and setting the &lt;code&gt;#[start]&lt;&#x2f;code&gt; attribute as described &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.16.0&#x2f;book&#x2f;no-stdlib.html&quot;&gt;here&lt;&#x2f;a&gt; is probably a better idea.&lt;&#x2f;p&gt;
&lt;&#x2f;details&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;A minimal freestanding Rust binary looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;code&gt;src&#x2f;main.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t link the Rust standard library
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_main] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; disable all Rust-level entry points

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; this function is the entry point, since the linker looks for a function
    &#x2f;&#x2f; named `_start` by default
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;crate_name&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;authors &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Author Name &amp;lt;author@example.com&amp;gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# the profile used for `cargo build`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.dev&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# disable stack unwinding on panic

# the profile used for `cargo build --release`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;profile.release&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;panic &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# disable stack unwinding on panic
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To build this binary, we need to compile for a bare metal target such as &lt;code&gt;thumbv7em-none-eabihf&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo build --target thumbv7em-none-eabihf
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Alternatively, we can compile it for the host system by passing additional linker arguments:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# Linux
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt; --&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; -C link-arg=-nostartfiles
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# Windows
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&#x2f;ENTRY:_start &#x2f;SUBSYSTEM:console&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# macOS
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo rustc -- -C link-args=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-e __start -static -nostartfiles&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that this is just a minimal example of a freestanding Rust binary. This binary expects various things, for example that a stack is initialized when the &lt;code&gt;_start&lt;&#x2f;code&gt; function is called. &lt;strong&gt;So it probably for any real use of such a binary, more steps are required&lt;&#x2f;strong&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; explains the steps needed for turning our freestanding binary into a minimal operating system kernel. This includes creating a custom target, combining our executable with a bootloader, and learning how to print something to the screen.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>A Minimal Rust Kernel</title>
                <pubDate>Sat, 10 Feb 2018 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/minimal-rust-kernel/</link>
                <guid>https://os.phil-opp.com/minimal-rust-kernel/</guid>
                <description>&lt;p&gt;In this post we create a minimal 64-bit Rust kernel for the x86 architecture. We build upon the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;&quot;&gt;freestanding Rust binary&lt;&#x2f;a&gt; from the previous post to create a bootable disk image, that prints something to the screen.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog is openly developed on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&quot;&gt;GitHub&lt;&#x2f;a&gt;. If you have any problems or questions, please open an issue there. You can also leave comments &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;#comments&quot;&gt;at the bottom&lt;&#x2f;a&gt;. The complete source code for this post can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;post-02&quot;&gt;&lt;code&gt;post-02&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; branch.&lt;&#x2f;p&gt;
&lt;!-- toc --&gt;
&lt;h2 id=&quot;the-boot-process&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-boot-process&quot; aria-label=&quot;Anchor link for: the-boot-process&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Boot Process&lt;&#x2f;h2&gt;
&lt;p&gt;When you turn on a computer, it begins executing firmware code that is stored in motherboard &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Read-only_memory&quot;&gt;ROM&lt;&#x2f;a&gt;. This code performs a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Power-on_self-test&quot;&gt;power-on self-test&lt;&#x2f;a&gt;, detects available RAM, and pre-initializes the CPU and hardware. Afterwards it looks for a bootable disk and starts booting the operating system kernel.&lt;&#x2f;p&gt;
&lt;p&gt;On x86, there are two firmware standards: the â€œBasic Input&#x2f;Output Systemâ€œ (&lt;strong&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;BIOS&quot;&gt;BIOS&lt;&#x2f;a&gt;&lt;&#x2f;strong&gt;) and the newer â€œUnified Extensible Firmware Interfaceâ€ (&lt;strong&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Unified_Extensible_Firmware_Interface&quot;&gt;UEFI&lt;&#x2f;a&gt;&lt;&#x2f;strong&gt;). The BIOS standard is old and outdated, but simple and well-supported on any x86 machine since the 1980s. UEFI, in contrast, is more modern and has much more features, but is more complex to set up (at least in my opinion).&lt;&#x2f;p&gt;
&lt;p&gt;Currently, we only provide BIOS support, but support for UEFI is planned, too. If you&#x27;d like to help us with this, check out the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;349&quot;&gt;Github issue&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;bios-boot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#bios-boot&quot; aria-label=&quot;Anchor link for: bios-boot&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
BIOS Boot&lt;&#x2f;h3&gt;
&lt;p&gt;Almost all x86 systems have support for BIOS booting, including newer UEFI-based machines that use an emulated BIOS. This is great, because you can use the same boot logic across all machines from the last centuries. But this wide compatibility is at the same time the biggest disadvantage of BIOS booting, because it means that the CPU is put into a 16-bit compatibility mode called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Real_mode&quot;&gt;real mode&lt;&#x2f;a&gt; before booting so that archaic bootloaders from the 1980s would still work.&lt;&#x2f;p&gt;
&lt;p&gt;But let&#x27;s start from the beginning:&lt;&#x2f;p&gt;
&lt;p&gt;When you turn on a computer, it loads the BIOS from some special flash memory located on the motherboard. The BIOS runs self test and initialization routines of the hardware, then it looks for bootable disks. If it finds one, the control is transferred to its &lt;em&gt;bootloader&lt;&#x2f;em&gt;, which is a 512-byte portion of executable code stored at the disk&#x27;s beginning. Most bootloaders are larger than 512 bytes, so bootloaders are commonly split into a small first stage, which fits into 512 bytes, and a second stage, which is subsequently loaded by the first stage.&lt;&#x2f;p&gt;
&lt;p&gt;The bootloader has to determine the location of the kernel image on the disk and load it into memory. It also needs to switch the CPU from the 16-bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Real_mode&quot;&gt;real mode&lt;&#x2f;a&gt; first to the 32-bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Protected_mode&quot;&gt;protected mode&lt;&#x2f;a&gt;, and then to the 64-bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Long_mode&quot;&gt;long mode&lt;&#x2f;a&gt;, where 64-bit registers and the complete main memory are available. Its third job is to query certain information (such as a memory map) from the BIOS and pass it to the OS kernel.&lt;&#x2f;p&gt;
&lt;p&gt;Writing a bootloader is a bit cumbersome as it requires assembly language and a lot of non insightful steps like â€œwrite this magic value to this processor registerâ€. Therefore we don&#x27;t cover bootloader creation in this post and instead provide a tool named &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&quot;&gt;bootimage&lt;&#x2f;a&gt; that automatically prepends a bootloader to your kernel.&lt;&#x2f;p&gt;
&lt;p&gt;If you are interested in building your own bootloader: Stay tuned, a set of posts on this topic is already planned! &lt;!-- , check out our â€œ_[Writing a Bootloader]_â€ posts, where we explain in detail how a bootloader is built. --&gt;&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-multiboot-standard&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-multiboot-standard&quot; aria-label=&quot;Anchor link for: the-multiboot-standard&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Multiboot Standard&lt;&#x2f;h4&gt;
&lt;p&gt;To avoid that every operating system implements its own bootloader, which is only compatible with a single OS, the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Free_Software_Foundation&quot;&gt;Free Software Foundation&lt;&#x2f;a&gt; created an open bootloader standard called &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;Multiboot&quot;&gt;Multiboot&lt;&#x2f;a&gt; in 1995. The standard defines an interface between the bootloader and operating system, so that any Multiboot compliant bootloader can load any Multiboot compliant operating system. The reference implementation is &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;GNU_GRUB&quot;&gt;GNU GRUB&lt;&#x2f;a&gt;, which is the most popular bootloader for Linux systems.&lt;&#x2f;p&gt;
&lt;p&gt;To make a kernel Multiboot compliant, one just needs to insert a so-called &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;grub&#x2f;manual&#x2f;multiboot&#x2f;multiboot.html#OS-image-format&quot;&gt;Multiboot header&lt;&#x2f;a&gt; at the beginning of the kernel file. This makes it very easy to boot an OS in GRUB. However, GRUB and the Multiboot standard have some problems too:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;They support only the 32-bit protected mode. This means that you still have to do the CPU configuration to switch to the 64-bit long mode.&lt;&#x2f;li&gt;
&lt;li&gt;They are designed to make the bootloader simple instead of the kernel. For example, the kernel needs to be linked with an &lt;a href=&quot;https:&#x2f;&#x2f;wiki.osdev.org&#x2f;Multiboot#Multiboot_2&quot;&gt;adjusted default page size&lt;&#x2f;a&gt;, because GRUB can&#x27;t find the Multiboot header otherwise. Another example is that the &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;grub&#x2f;manual&#x2f;multiboot&#x2f;multiboot.html#Boot-information-format&quot;&gt;boot information&lt;&#x2f;a&gt;, which is passed to the kernel, contains lots of architecture dependent structures instead of providing clean abstractions.&lt;&#x2f;li&gt;
&lt;li&gt;Both GRUB and the Multiboot standard are only sparsely documented.&lt;&#x2f;li&gt;
&lt;li&gt;GRUB needs to be installed on the host system to create a bootable disk image from the kernel file. This makes development on Windows or Mac more difficult.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Because of these drawbacks we decided to not use GRUB or the Multiboot standard. However, we plan to add Multiboot support to our &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&quot;&gt;bootimage&lt;&#x2f;a&gt; tool, so that it&#x27;s possible to load your kernel on a GRUB system too. If you&#x27;re interested in writing a Multiboot compliant kernel, check out the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;&quot;&gt;first edition&lt;&#x2f;a&gt; of this blog series.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;uefi&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#uefi&quot; aria-label=&quot;Anchor link for: uefi&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
UEFI&lt;&#x2f;h3&gt;
&lt;p&gt;(We don&#x27;t provide UEFI support at the moment, but we would love to! If you&#x27;d like to help, please tell us in the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;349&quot;&gt;Github issue&lt;&#x2f;a&gt;.)&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-minimal-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-minimal-kernel&quot; aria-label=&quot;Anchor link for: a-minimal-kernel&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Minimal Kernel&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we roughly know how a computer boots, it&#x27;s time to create our own minimal kernel. Our goal is to create a disk image that prints a â€œHello World!â€ to the screen when booted. For that we build upon the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;&quot;&gt;freestanding Rust binary&lt;&#x2f;a&gt; from the previous post.&lt;&#x2f;p&gt;
&lt;p&gt;As you may remember, we built the freestanding binary through &lt;code&gt;cargo&lt;&#x2f;code&gt;, but depending on the operating system we needed different entry point names and compile flags. That&#x27;s because &lt;code&gt;cargo&lt;&#x2f;code&gt; builds for the &lt;em&gt;host system&lt;&#x2f;em&gt; by default, i.e. the system you&#x27;re running on. This isn&#x27;t something we want for our kernel, because a kernel that runs on top of e.g. Windows does not make much sense. Instead, we want to compile for a clearly defined &lt;em&gt;target system&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;installing-rust-nightly&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#installing-rust-nightly&quot; aria-label=&quot;Anchor link for: installing-rust-nightly&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Installing Rust Nightly&lt;&#x2f;h3&gt;
&lt;p&gt;Rust has three release channels: &lt;em&gt;stable&lt;&#x2f;em&gt;, &lt;em&gt;beta&lt;&#x2f;em&gt;, and &lt;em&gt;nightly&lt;&#x2f;em&gt;. The Rust Book explains the difference between these channels really well, so take a minute and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;appendix-07-nightly-rust.html#choo-choo-release-channels-and-riding-the-trains&quot;&gt;check it out&lt;&#x2f;a&gt;. For building an operating system we will need some experimental features that are only available on the nightly channel, so we need to install a nightly version of Rust.&lt;&#x2f;p&gt;
&lt;p&gt;To manage Rust installations I highly recommend &lt;a href=&quot;https:&#x2f;&#x2f;www.rustup.rs&#x2f;&quot;&gt;rustup&lt;&#x2f;a&gt;. It allows you to install nightly, beta, and stable compilers side-by-side and makes it easy to update them. With rustup you can use a nightly compiler for the current directory by running &lt;code&gt;rustup override add nightly&lt;&#x2f;code&gt;. Alternatively, you can add a file called &lt;code&gt;rust-toolchain&lt;&#x2f;code&gt; with the content &lt;code&gt;nightly&lt;&#x2f;code&gt; to the project&#x27;s root directory. You can check that you have a nightly version installed by running &lt;code&gt;rustc --version&lt;&#x2f;code&gt;: The version number should contain &lt;code&gt;-nightly&lt;&#x2f;code&gt; at the end.&lt;&#x2f;p&gt;
&lt;p&gt;The nightly compiler allows us to opt-in to various experimental features by using so-called &lt;em&gt;feature flags&lt;&#x2f;em&gt; at the top of our file. For example, we could enable the experimental &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;unstable-book&#x2f;language-features&#x2f;asm.html&quot;&gt;&lt;code&gt;asm!&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; for inline assembly by adding &lt;code&gt;#![feature(asm)]&lt;&#x2f;code&gt; to the top of our &lt;code&gt;main.rs&lt;&#x2f;code&gt;. Note that such experimental features are completely unstable, which means that future Rust versions might change or remove them without prior warning. For this reason we will only use them if absolutely necessary.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;target-specification&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specification&quot; aria-label=&quot;Anchor link for: target-specification&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Target Specification&lt;&#x2f;h3&gt;
&lt;p&gt;Cargo supports different target systems through the &lt;code&gt;--target&lt;&#x2f;code&gt; parameter. The target is described by a so-called &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;clang.llvm.org&#x2f;docs&#x2f;CrossCompilation.html#target-triple&quot;&gt;target triple&lt;&#x2f;a&gt;&lt;&#x2f;em&gt;, which describes the CPU architecture, the vendor, the operating system, and the &lt;a href=&quot;https:&#x2f;&#x2f;stackoverflow.com&#x2f;a&#x2f;2456882&quot;&gt;ABI&lt;&#x2f;a&gt;. For example, the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target triple describes a system with a &lt;code&gt;x86_64&lt;&#x2f;code&gt; CPU, no clear vendor and a Linux operating system with the GNU ABI. Rust supports &lt;a href=&quot;https:&#x2f;&#x2f;forge.rust-lang.org&#x2f;platform-support.html&quot;&gt;many different target triples&lt;&#x2f;a&gt;, including &lt;code&gt;arm-linux-androideabi&lt;&#x2f;code&gt; for Android or &lt;a href=&quot;https:&#x2f;&#x2f;www.hellorust.com&#x2f;setup&#x2f;wasm-target&#x2f;&quot;&gt;&lt;code&gt;wasm32-unknown-unknown&lt;&#x2f;code&gt; for WebAssembly&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;For our target system, however, we require some special configuration parameters (e.g. no underlying OS), so none of the &lt;a href=&quot;https:&#x2f;&#x2f;forge.rust-lang.org&#x2f;platform-support.html&quot;&gt;existing target triples&lt;&#x2f;a&gt; fits. Fortunately, Rust allows us to define our own target through a JSON file. For example, a JSON file that describes the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linux&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pre-link-args&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-m64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;],
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;morestack&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;false
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most fields are required by LLVM to generate code for that platform. For example, the &lt;a href=&quot;https:&#x2f;&#x2f;llvm.org&#x2f;docs&#x2f;LangRef.html#data-layout&quot;&gt;&lt;code&gt;data-layout&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; field defines the size of various integer, floating point, and pointer types. Then there are fields that Rust uses for conditional compilation, such as &lt;code&gt;target-pointer-width&lt;&#x2f;code&gt;. The third kind of fields define how the crate should be built. For example, the &lt;code&gt;pre-link-args&lt;&#x2f;code&gt; field specifies arguments passed to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Linker_(computing)&quot;&gt;linker&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We also target &lt;code&gt;x86_64&lt;&#x2f;code&gt; systems with our kernel, so our target specification will look very similar to the one above. Let&#x27;s start by creating a &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; file (choose any name you like) with the common content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we changed the OS in the &lt;code&gt;llvm-target&lt;&#x2f;code&gt; and the &lt;code&gt;os&lt;&#x2f;code&gt; field to &lt;code&gt;none&lt;&#x2f;code&gt;, because we will run on bare metal.&lt;&#x2f;p&gt;
&lt;p&gt;We add the following build-related entries:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ld.lld&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rust-lld&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of using the platform&#x27;s default linker (which might not support Linux targets), we use the cross platform &lt;a href=&quot;https:&#x2f;&#x2f;lld.llvm.org&#x2f;&quot;&gt;LLD&lt;&#x2f;a&gt; linker that is shipped with Rust for linking our kernel.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This setting specifies that the target doesn&#x27;t support &lt;a href=&quot;http:&#x2f;&#x2f;www.bogotobogo.com&#x2f;cplusplus&#x2f;stackunwinding.php&quot;&gt;stack unwinding&lt;&#x2f;a&gt; on panic, so instead the program should abort directly. This has the same effect as the &lt;code&gt;panic = &amp;quot;abort&amp;quot;&lt;&#x2f;code&gt; option in our Cargo.toml, so we can remove it from there. (Note that in contrast to the Cargo.toml option, this target option also applies when we recompile the &lt;code&gt;core&lt;&#x2f;code&gt; library later in this post. So be sure to add this option, even if you prefer to keep the Cargo.toml option.)&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We&#x27;re writing a kernel, so we&#x27;ll need to handle interrupts at some point. To do that safely, we have to disable a certain stack pointer optimization called the &lt;em&gt;â€œred zoneâ€&lt;&#x2f;em&gt;, because it would cause stack corruptions otherwise. For more information, see our separate post about &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;red-zone&#x2f;&quot;&gt;disabling the red zone&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;features&lt;&#x2f;code&gt; field enables&#x2f;disables target features. We disable the &lt;code&gt;mmx&lt;&#x2f;code&gt; and &lt;code&gt;sse&lt;&#x2f;code&gt; features by prefixing them with a minus and enable the &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature by prefixing it with a plus. Note that there must be no spaces between different flags, otherwise LLVM fails to interpret the features string.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;mmx&lt;&#x2f;code&gt; and &lt;code&gt;sse&lt;&#x2f;code&gt; features determine support for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2f;a&gt; instructions, which can often speed up programs significantly. However, using the large SIMD registers in OS kernels leads to performance problems. The reason is that the kernel needs to restore all registers to their original state before continuing an interrupted program. This means that the kernel has to save the complete SIMD state to main memory on each system call or hardware interrupt. Since the SIMD state is very large (512â€“1600 bytes) and interrupts can occur very often, these additional save&#x2f;restore operations considerably harm performance. To avoid this, we disable SIMD for our kernel (not for applications running on top!).&lt;&#x2f;p&gt;
&lt;p&gt;A problem with disabling SIMD is that floating point operations on &lt;code&gt;x86_64&lt;&#x2f;code&gt; require SIMD registers by default. To solve this problem, we add the &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature, which emulates all floating point operations through software functions based on normal integers.&lt;&#x2f;p&gt;
&lt;p&gt;For more information, see our post on &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;disable-simd&#x2f;&quot;&gt;disabling SIMD&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Putting it Together&lt;&#x2f;h4&gt;
&lt;p&gt;Our target specification file now looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;executables&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ld.lld&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rust-lld&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;building-our-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-our-kernel&quot; aria-label=&quot;Anchor link for: building-our-kernel&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Building our Kernel&lt;&#x2f;h3&gt;
&lt;p&gt;Compiling for our new target will use Linux conventions (I&#x27;m not quite sure why, I assume that it&#x27;s just LLVM&#x27;s default). This means that we need an entry point named &lt;code&gt;_start&lt;&#x2f;code&gt; as described in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;main.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_std] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t link the Rust standard library
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![no_main] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; disable all Rust-level entry points

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::panic::PanicInfo;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; This function is called on panic.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[panic_handler]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic(_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PanicInfo) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

#[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; don&amp;#39;t mangle the name of this function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; this function is the entry point, since the linker looks for a function
    &#x2f;&#x2f; named `_start` by default
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the entry point needs to be called &lt;code&gt;_start&lt;&#x2f;code&gt; regardless of your host OS. The Windows and macOS entry points from the previous post should be deleted.&lt;&#x2f;p&gt;
&lt;p&gt;We can now build the kernel for our new target by passing the name of the JSON file as &lt;code&gt;--target&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo build --target x86_64-blog_os.json

error[E0463]: can&amp;#39;t find crate for `core`
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It fails! The error tells us that the Rust compiler no longer finds the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;index.html&quot;&gt;&lt;code&gt;core&lt;&#x2f;code&gt; library&lt;&#x2f;a&gt;. This library contains basic Rust types such as &lt;code&gt;Result&lt;&#x2f;code&gt;, &lt;code&gt;Option&lt;&#x2f;code&gt;, and iterators, and is implicitly linked to all &lt;code&gt;no_std&lt;&#x2f;code&gt; crates.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2f;em&gt; library. So it is only valid for supported host triples (e.g., &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt;) but not for our custom target. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2f;code&gt; for these targets first.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;cargo-xbuild&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cargo-xbuild&quot; aria-label=&quot;Anchor link for: cargo-xbuild&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Cargo xbuild&lt;&#x2f;h4&gt;
&lt;p&gt;That&#x27;s where &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;cargo-xbuild&quot;&gt;&lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; comes in. It is a wrapper for &lt;code&gt;cargo build&lt;&#x2f;code&gt; that automatically cross-compiles &lt;code&gt;core&lt;&#x2f;code&gt; and other built-in libraries. We can install it by executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo install cargo-xbuild
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The command depends on the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can rerun the above command with &lt;code&gt;xbuild&lt;&#x2f;code&gt; instead of &lt;code&gt;build&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo xbuild --target x86_64-blog_os.json
   Compiling core v0.0.0 (&#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;libcore)
   Compiling compiler_builtins v0.1.5
   Compiling rustc-std-workspace-core v1.0.0 (&#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;tools&#x2f;rustc-std-workspace-core)
   Compiling alloc v0.0.0 (&#x2f;tmp&#x2f;xargo.PB7fj9KZJhAI)
    Finished release [optimized + debuginfo] target(s) in 45.18s
   Compiling blog_os v0.1.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt; cross-compiles the &lt;code&gt;core&lt;&#x2f;code&gt;, &lt;code&gt;compiler_builtin&lt;&#x2f;code&gt;, and &lt;code&gt;alloc&lt;&#x2f;code&gt; libraries for our new custom target. Since these libraries use a lot of unstable features internally, this only works with a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;freestanding-rust-binary&#x2f;#installing-rust-nightly&quot;&gt;nightly Rust compiler&lt;&#x2f;a&gt;. Afterwards, &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt; successfully compiles our &lt;code&gt;blog_os&lt;&#x2f;code&gt; crate.&lt;&#x2f;p&gt;
&lt;p&gt;Now we are able to build our kernel for a bare metal target. However, our &lt;code&gt;_start&lt;&#x2f;code&gt; entry point, which will be called by the boot loader, is still empty. So let&#x27;s output something to screen from it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;set-a-default-target&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#set-a-default-target&quot; aria-label=&quot;Anchor link for: set-a-default-target&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Set a Default Target&lt;&#x2f;h3&gt;
&lt;p&gt;To avoid passing the &lt;code&gt;--target&lt;&#x2f;code&gt; parameter on every invocation of &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;, we can override the default target. To do this, we create a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;config.html&quot;&gt;cargo configuration&lt;&#x2f;a&gt; file at &lt;code&gt;.cargo&#x2f;config&lt;&#x2f;code&gt; with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2f;config

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;build&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;target &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-blog_os.json&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This tells &lt;code&gt;cargo&lt;&#x2f;code&gt; to use our &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; target when no explicit &lt;code&gt;--target&lt;&#x2f;code&gt; argument is passed. This means that we can now build our kernel with a simple &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;. For more information on cargo configuration options, check out the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;config.html&quot;&gt;official documentation&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;printing-to-screen&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-to-screen&quot; aria-label=&quot;Anchor link for: printing-to-screen&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing to Screen&lt;&#x2f;h3&gt;
&lt;p&gt;The easiest way to print text to the screen at this stage is the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;VGA-compatible_text_mode&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;. It is a special memory area mapped to the VGA hardware that contains the contents displayed on screen. It normally consists of 25 lines that each contain 80 character cells. Each character cell displays an ASCII character with some foreground and background colors. The screen output looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;upload.wikimedia.org&#x2f;wikipedia&#x2f;commons&#x2f;f&#x2f;f8&#x2f;Codepage-437.png&quot; alt=&quot;screen output for common ASCII characters&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We will discuss the exact layout of the VGA buffer in the next post, where we write a first small driver for it. For printing â€œHello World!â€, we just need to know that the buffer is located at address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; and that each character cell consists of an ASCII byte and a color byte.&lt;&#x2f;p&gt;
&lt;p&gt;The implementation looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HELLO&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;_start() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vga_buffer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;byte) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HELLO&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.iter().enumerate() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer.offset(i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as isize * &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte;
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer.offset(i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as isize * &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we cast the integer &lt;code&gt;0xb8000&lt;&#x2f;code&gt; into a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer&quot;&gt;raw pointer&lt;&#x2f;a&gt;. Then we &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch13-02-iterators.html&quot;&gt;iterate&lt;&#x2f;a&gt; over the bytes of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ch10-03-lifetime-syntax.html#the-static-lifetime&quot;&gt;static&lt;&#x2f;a&gt; &lt;code&gt;HELLO&lt;&#x2f;code&gt; &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference&#x2f;tokens.html#byte-string-literals&quot;&gt;byte string&lt;&#x2f;a&gt;. We use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.enumerate&quot;&gt;&lt;code&gt;enumerate&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to additionally get a running variable &lt;code&gt;i&lt;&#x2f;code&gt;. In the body of the for loop, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;primitive.pointer.html#method.offset&quot;&gt;&lt;code&gt;offset&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method to write the string byte and the corresponding color byte (&lt;code&gt;0xb&lt;&#x2f;code&gt; is a light cyan).&lt;&#x2f;p&gt;
&lt;p&gt;Note that there&#x27;s an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch19-01-unsafe-rust.html&quot;&gt;&lt;code&gt;unsafe&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; block around all memory writes. The reason is that the Rust compiler can&#x27;t prove that the raw pointers we create are valid. They could point anywhere and lead to data corruption. By putting them into an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block we&#x27;re basically telling the compiler that we are absolutely sure that the operations are valid. Note that an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block does not turn off Rust&#x27;s safety checks. It only allows you to do &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;stable&#x2f;book&#x2f;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;four additional things&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;I want to emphasize that &lt;strong&gt;this is not the way we want to do things in Rust!&lt;&#x2f;strong&gt; It&#x27;s very easy to mess up when working with raw pointers inside unsafe blocks, for example, we could easily write behind the buffer&#x27;s end if we&#x27;re not careful.&lt;&#x2f;p&gt;
&lt;p&gt;So we want to minimize the use of &lt;code&gt;unsafe&lt;&#x2f;code&gt; as much as possible. Rust gives us the ability to do this by creating safe abstractions. For example, we could create a VGA buffer type that encapsulates all unsafety and ensures that it is &lt;em&gt;impossible&lt;&#x2f;em&gt; to do anything wrong from the outside. This way, we would only need minimal amounts of &lt;code&gt;unsafe&lt;&#x2f;code&gt; and can be sure that we don&#x27;t violate &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory_safety&quot;&gt;memory safety&lt;&#x2f;a&gt;. We will create such a safe VGA buffer abstraction in the next post.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;running-our-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#running-our-kernel&quot; aria-label=&quot;Anchor link for: running-our-kernel&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Running our Kernel&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we have an executable that does something perceptible, it is time to run it. First, we need to turn our compiled kernel into a bootable disk image by linking it with a bootloader. Then we can run the disk image in the &lt;a href=&quot;https:&#x2f;&#x2f;www.qemu.org&#x2f;&quot;&gt;QEMU&lt;&#x2f;a&gt; virtual machine or boot it on real hardware using an USB stick.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-a-bootimage&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-bootimage&quot; aria-label=&quot;Anchor link for: creating-a-bootimage&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a Bootimage&lt;&#x2f;h3&gt;
&lt;p&gt;To turn our compiled kernel into a bootable disk image, we need to link it with a bootloader. As we learned in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;#the-boot-process&quot;&gt;section about booting&lt;&#x2f;a&gt;, the bootloader is responsible for initializing the CPU and loading our kernel.&lt;&#x2f;p&gt;
&lt;p&gt;Instead of writing our own bootloader, which is a project on its own, we use the &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;bootloader&quot;&gt;&lt;code&gt;bootloader&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; crate. This crate implements a basic BIOS bootloader without any C dependencies, just Rust and inline assembly. To use it for booting our kernel, we need to add a dependency on it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bootloader &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.8.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Adding the bootloader as dependency is not enough to actually create a bootable disk image. The problem is that we need to link our kernel with the bootloader after compilation, but cargo has no support for &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;cargo&#x2f;issues&#x2f;545&quot;&gt;post-build scripts&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To solve this problem, we created a tool named &lt;code&gt;bootimage&lt;&#x2f;code&gt; that first compiles the kernel and bootloader, and then links them together to create a bootable disk image. To install the tool, execute the following command in your terminal:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo install bootimage --version &amp;quot;^0.7.7&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;^0.7.7&lt;&#x2f;code&gt; is a so-called &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;specifying-dependencies.html#caret-requirements&quot;&gt;&lt;em&gt;caret requirement&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;, which means &amp;quot;version &lt;code&gt;0.7.7&lt;&#x2f;code&gt; or a later compatible version&amp;quot;. So if we find a bug and publish version &lt;code&gt;0.7.8&lt;&#x2f;code&gt; or &lt;code&gt;0.7.9&lt;&#x2f;code&gt;, cargo would automatically use the latest version, as long as it is still a version &lt;code&gt;0.7.x&lt;&#x2f;code&gt;. However, it wouldn&#x27;t choose version &lt;code&gt;0.8.0&lt;&#x2f;code&gt;, because it is not considered as compatible. Note that dependencies in your &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; are caret requirements by default, so the same rules are applied to our bootloader dependency.&lt;&#x2f;p&gt;
&lt;p&gt;For running &lt;code&gt;bootimage&lt;&#x2f;code&gt; and building the bootloader, you need to have the &lt;code&gt;llvm-tools-preview&lt;&#x2f;code&gt; rustup component installed. You can do so by executing &lt;code&gt;rustup component add llvm-tools-preview&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;After installing &lt;code&gt;bootimage&lt;&#x2f;code&gt; and adding the &lt;code&gt;llvm-tools-preview&lt;&#x2f;code&gt; component, we can create a bootable disk image by executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo bootimage
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that the tool recompiles our kernel using &lt;code&gt;cargo xbuild&lt;&#x2f;code&gt;, so it will automatically pick up any changes you make. Afterwards it compiles the bootloader, which might take a while. Like all crate dependencies it is only built once and then cached, so subsequent builds will be much faster. Finally, &lt;code&gt;bootimage&lt;&#x2f;code&gt; combines the bootloader and your kernel to a bootable disk image.&lt;&#x2f;p&gt;
&lt;p&gt;After executing the command, you should see a bootable disk image named &lt;code&gt;bootimage-blog_os.bin&lt;&#x2f;code&gt; in your &lt;code&gt;target&#x2f;x86_64-blog_os&#x2f;debug&lt;&#x2f;code&gt; directory. You can boot it in a virtual machine or copy it to an USB drive to boot it on real hardware. (Note that this is not a CD image, which have a different format, so burning it to a CD doesn&#x27;t work).&lt;&#x2f;p&gt;
&lt;h4 id=&quot;how-does-it-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-does-it-work&quot; aria-label=&quot;Anchor link for: how-does-it-work&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
How does it work?&lt;&#x2f;h4&gt;
&lt;p&gt;The &lt;code&gt;bootimage&lt;&#x2f;code&gt; tool performs the following steps behind the scenes:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;It compiles our kernel to an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Executable_and_Linkable_Format&quot;&gt;ELF&lt;&#x2f;a&gt; file.&lt;&#x2f;li&gt;
&lt;li&gt;It compiles the bootloader dependency as a standalone executable.&lt;&#x2f;li&gt;
&lt;li&gt;It links the bytes of the kernel ELF file to the bootloader.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;When booted, the bootloader reads and parses the appended ELF file. It then maps the program segments to virtual addresses in the page tables, zeroes the &lt;code&gt;.bss&lt;&#x2f;code&gt; section, and sets up a stack. Finally, it reads the entry point address (our &lt;code&gt;_start&lt;&#x2f;code&gt; function) and jumps to it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;booting-it-in-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#booting-it-in-qemu&quot; aria-label=&quot;Anchor link for: booting-it-in-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Booting it in QEMU&lt;&#x2f;h3&gt;
&lt;p&gt;We can now boot the disk image in a virtual machine. To boot it in &lt;a href=&quot;https:&#x2f;&#x2f;www.qemu.org&#x2f;&quot;&gt;QEMU&lt;&#x2f;a&gt;, execute the following command:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 -drive format=raw,file=target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;bootimage-blog_os.bin
warning: TCG doesn&amp;#39;t support requested feature: CPUID.01H:ECX.vmx [bit 5]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This opens a separate window with that looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;minimal-rust-kernel&#x2f;qemu.png&quot; alt=&quot;QEMU showing &amp;quot;Hello World!&amp;quot;&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that our &amp;quot;Hello World!&amp;quot; is visible on the screen.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;real-machine&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#real-machine&quot; aria-label=&quot;Anchor link for: real-machine&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Real Machine&lt;&#x2f;h3&gt;
&lt;p&gt;It is also possible to write it to an USB stick and boot it on a real machine:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; dd if=target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;bootimage-blog_os.bin of=&#x2f;dev&#x2f;sdX &amp;amp;&amp;amp; sync
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Where &lt;code&gt;sdX&lt;&#x2f;code&gt; is the device name of your USB stick. &lt;strong&gt;Be careful&lt;&#x2f;strong&gt; to choose the correct device name, because everything on that device is overwritten.&lt;&#x2f;p&gt;
&lt;p&gt;After writing the image to the USB stick, you can run it on real hardware by booting from it. You probably need to use a special boot menu or change the boot order in your BIOS configuration to boot from the USB stick. Note that it currently doesn&#x27;t work for UEFI machines, since the &lt;code&gt;bootloader&lt;&#x2f;code&gt; crate has no UEFI support yet.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;using-cargo-run&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-cargo-run&quot; aria-label=&quot;Anchor link for: using-cargo-run&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using &lt;code&gt;cargo run&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;To make it easier to run our kernel in QEMU, we can set the &lt;code&gt;runner&lt;&#x2f;code&gt; configuration key for cargo:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in .cargo&#x2f;config

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;cfg(target_os = &amp;quot;none&amp;quot;)&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;runner &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;bootimage runner&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;target.&#x27;cfg(target_os = &amp;quot;none&amp;quot;)&#x27;&lt;&#x2f;code&gt; table applies to all targets that have set the &lt;code&gt;&amp;quot;os&amp;quot;&lt;&#x2f;code&gt; field of their target configuration file to &lt;code&gt;&amp;quot;none&amp;quot;&lt;&#x2f;code&gt;. This includes our &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; target. The &lt;code&gt;runner&lt;&#x2f;code&gt; key specifies the command that should be invoked for &lt;code&gt;cargo run&lt;&#x2f;code&gt;. The command is run after a successful build with the executable path passed as first argument. See the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;cargo&#x2f;reference&#x2f;config.html&quot;&gt;cargo documentation&lt;&#x2f;a&gt; for more details.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;bootimage runner&lt;&#x2f;code&gt; command is specifically designed to be usable as a &lt;code&gt;runner&lt;&#x2f;code&gt; executable. It links the given executable with the project&#x27;s bootloader dependency and then launches QEMU. See the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-osdev&#x2f;bootimage&quot;&gt;Readme of &lt;code&gt;bootimage&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for more details and possible configuration options.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use &lt;code&gt;cargo xrun&lt;&#x2f;code&gt; to compile our kernel and boot it in QEMU. Like &lt;code&gt;xbuild&lt;&#x2f;code&gt;, the &lt;code&gt;xrun&lt;&#x2f;code&gt; subcommand builds the sysroot crates before invoking the actual cargo command. The subcommand is also provided by &lt;code&gt;cargo-xbuild&lt;&#x2f;code&gt;, so you don&#x27;t need to install an additional tool.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the next post, we will explore the VGA text buffer in more detail and write a safe interface for it. We will also add support for the &lt;code&gt;println&lt;&#x2f;code&gt; macro.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Handling Exceptions</title>
                <pubDate>Sun, 26 Mar 2017 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/handling-exceptions/</link>
                <guid>https://os.phil-opp.com/handling-exceptions/</guid>
                <description>&lt;p&gt;In this post, we start exploring CPU exceptions. Exceptions occur in various erroneous situations, for example when accessing an invalid memory address or when dividing by zero. To catch them, we have to set up an &lt;em&gt;interrupt descriptor table&lt;&#x2f;em&gt; that provides handler functions. At the end of this post, our kernel will be able to catch &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Breakpoint&quot;&gt;breakpoint exceptions&lt;&#x2f;a&gt; and to resume normal execution afterwards.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, the complete source code is available on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_9&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions&quot; aria-label=&quot;Anchor link for: exceptions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exceptions&lt;&#x2f;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2f;p&gt;
&lt;p&gt;We&#x27;ve already seen several types of exceptions in our kernel:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2f;strong&gt;: This exception occurs when the current instruction is invalid. For example, this exception occurred when we tried to use SSE instructions before enabling SSE. Without SSE, the CPU didn&#x27;t know the &lt;code&gt;movups&lt;&#x2f;code&gt; and &lt;code&gt;movaps&lt;&#x2f;code&gt; instructions, so it throws an exception when it stumbles over them.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2f;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2f;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2f;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2f;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2f;em&gt;. We can&#x27;t catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system. This causes the bootloops we experienced in the previous posts.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;For the full list of exceptions check out the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;OSDev wiki&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Descriptor Table&lt;&#x2f;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2f;em&gt; (IDT). In this table we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2f;th&gt;&lt;th&gt;Name                     &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [0:15]  &lt;&#x2f;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;GDT selector             &lt;&#x2f;td&gt;&lt;td&gt;Selector of a code segment in the GDT.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Options                  &lt;&#x2f;td&gt;&lt;td&gt;(see below)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [16:31] &lt;&#x2f;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [32:63] &lt;&#x2f;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Reserved                 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits  &lt;&#x2f;th&gt;&lt;th&gt;Name                              &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2   &lt;&#x2f;td&gt;&lt;td&gt;Interrupt Stack Table Index       &lt;&#x2f;td&gt;&lt;td&gt;0: Don&#x27;t switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7   &lt;&#x2f;td&gt;&lt;td&gt;Reserved              &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8     &lt;&#x2f;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate   &lt;&#x2f;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11  &lt;&#x2f;td&gt;&lt;td&gt;must be one                       &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12    &lt;&#x2f;td&gt;&lt;td&gt;must be zero                      &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;13â€‘14 &lt;&#x2f;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)  &lt;&#x2f;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;15    &lt;&#x2f;td&gt;&lt;td&gt;Present                           &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;Exception Table&lt;&#x2f;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the â€œVector nr.â€ column.&lt;&#x2f;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2f;a&gt; register. (We will use these values later in this post.)&lt;&#x2f;li&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14-th entry when a page fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;Check if the entry is present. Raise a double fault if not.&lt;&#x2f;li&gt;
&lt;li&gt;Disable interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2f;li&gt;
&lt;li&gt;Load the specified GDT selector into the CS segment.&lt;&#x2f;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;h2 id=&quot;an-idt-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#an-idt-type&quot; aria-label=&quot;Anchor link for: an-idt-type&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
An IDT Type&lt;&#x2f;h2&gt;
&lt;p&gt;Instead of creating our own IDT type, we will use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2f;code&gt; struct&lt;&#x2f;a&gt; of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate, which looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;debug: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;non_maskable_interrupt: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;breakpoint: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;overflow: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bound_range_exceeded: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid_opcode: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;device_not_available: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;double_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid_tss: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;segment_not_present: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_segment_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;general_protection_fault: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_fault: IdtEntry&amp;lt;PageFaultHandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x87_floating_point: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alignment_check: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;machine_check: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;simd_floating_point: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;virtualization: IdtEntry&amp;lt;HandlerFunc&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;security_exception: IdtEntry&amp;lt;HandlerFuncWithErrCode&amp;gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts: [IdtEntry&amp;lt;HandlerFunc&amp;gt;; 224],
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; some fields omitted
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The fields have the type &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.IdtEntry.html&quot;&gt;&lt;code&gt;IdtEntry&amp;lt;F&amp;gt;&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;, which is a struct that represents the fields of an IDT entry (see the table above). The type parameter &lt;code&gt;F&lt;&#x2f;code&gt; defines the expected handler function type. We see that some entries require a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFunc.html&quot;&gt;&lt;code&gt;HandlerFunc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and some entries require a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;. The page fault even has its own special type: &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.PageFaultHandlerFunc.html&quot;&gt;&lt;code&gt;PageFaultHandlerFunc&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s look at the &lt;code&gt;HandlerFunc&lt;&#x2f;code&gt; type first:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ExceptionStackFrame);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;type-aliases.html&quot;&gt;type alias&lt;&#x2f;a&gt; for an &lt;code&gt;extern &amp;quot;x86-interrupt&amp;quot; fn&lt;&#x2f;code&gt; type. The &lt;code&gt;extern&lt;&#x2f;code&gt; keyword defines a function with a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ffi.html#foreign-calling-conventions&quot;&gt;foreign calling convention&lt;&#x2f;a&gt; and is often used to communicate with C code (&lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt;). But what is the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention?&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-interrupt-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-calling-convention&quot; aria-label=&quot;Anchor link for: the-interrupt-calling-convention&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Calling Convention&lt;&#x2f;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the called function and executes it. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2f;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted &lt;code&gt;call&lt;&#x2f;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;Calling conventions&lt;&#x2f;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt;):&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2f;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2f;code&gt; and &lt;code&gt;rdx&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;issues&#x2f;600&quot;&gt;there isn&#x27;t even a Rust ABI yet&lt;&#x2f;a&gt;). So these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preserved and Scratch Registers&lt;&#x2f;h3&gt;
&lt;p&gt;The calling convention divides the registers in two parts: &lt;em&gt;preserved&lt;&#x2f;em&gt; and &lt;em&gt;scratch&lt;&#x2f;em&gt; registers.&lt;&#x2f;p&gt;
&lt;p&gt;The values of &lt;em&gt;preserved&lt;&#x2f;em&gt; registers must remain unchanged across function calls. So a called function (the &lt;em&gt;â€œcalleeâ€&lt;&#x2f;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called &lt;em&gt;â€œcallee-savedâ€&lt;&#x2f;em&gt;. A common pattern is to save these registers to the stack at the function&#x27;s beginning and restore them just before returning.&lt;&#x2f;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite &lt;em&gt;scratch&lt;&#x2f;em&gt; registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it before the function call (e.g. by pushing it to the stack). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers &lt;&#x2f;th&gt;&lt;th&gt;scratch registers&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2f;code&gt;, &lt;code&gt;rbx&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, &lt;code&gt;r12&lt;&#x2f;code&gt;, &lt;code&gt;r13&lt;&#x2f;code&gt;, &lt;code&gt;r14&lt;&#x2f;code&gt;, &lt;code&gt;r15&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;, &lt;code&gt;r10&lt;&#x2f;code&gt;, &lt;code&gt;r11&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2f;em&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2f;em&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2f;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2f;code&gt; on the stack (because it&#x27;s a callee-saved register).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;preserving-all-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserving-all-registers&quot; aria-label=&quot;Anchor link for: preserving-all-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preserving all Registers&lt;&#x2f;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In most cases we don&#x27;t even know at compile time if the generated code will cause an exception. For example, the compiler can&#x27;t know if an instruction causes a stack overflow or a page fault.&lt;&#x2f;p&gt;
&lt;p&gt;Since we don&#x27;t know when an exception occurs, we can&#x27;t backup any registers before. This means that we can&#x27;t use a calling convention that relies on caller-saved registers for exception handlers. Instead, we need a calling convention means that preserves &lt;em&gt;all registers&lt;&#x2f;em&gt;. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is such a calling convention, so it guarantees that all register values are restored to their original values on function return.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-exception-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-exception-stack-frame&quot; aria-label=&quot;Anchor link for: the-exception-stack-frame&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Exception Stack Frame&lt;&#x2f;h3&gt;
&lt;p&gt;On a normal function call (using the &lt;code&gt;call&lt;&#x2f;code&gt; instruction), the CPU pushes the return address before jumping to the target function. On function return (using the &lt;code&gt;ret&lt;&#x2f;code&gt; instruction), the CPU pops this return address and jumps to it. So the stack frame of a normal function call looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;For exception and interrupt handlers, however, pushing a return address would not suffice, since interrupt handlers often run in a different context (stack pointer, CPU flags, etc.). Instead, the CPU performs the following steps when an interrupt occurs:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack pointer&lt;&#x2f;strong&gt;: An interrupt can occur at any instructions, so the stack pointer can have any value, too. However, some CPU instructions (e.g. some SSE instructions) require that the stack pointer is aligned on a 16 byte boundary, therefore the CPU performs such an alignment right after the interrupt.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Switching stacks&lt;&#x2f;strong&gt; (in some cases): A stack switch occurs when the CPU privilege level changes, for example when a CPU exception occurs in an user mode program. It is also possible to configure stack switches for specific interrupts using the so-called &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; (described in the next post).&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the old stack pointer&lt;&#x2f;strong&gt;: The CPU pushes the values of the stack pointer (&lt;code&gt;rsp&lt;&#x2f;code&gt;) and the stack segment (&lt;code&gt;ss&lt;&#x2f;code&gt;) registers at the time when the interrupt occurred (before the alignment). This makes it possible to restore the original stack pointer when returning from an interrupt handler.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing and updating the &lt;code&gt;RFLAGS&lt;&#x2f;code&gt; register&lt;&#x2f;strong&gt;: The &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;&lt;code&gt;RFLAGS&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; register contains various control and status bits. On interrupt entry, the CPU changes some bits and pushes the old value.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing the instruction pointer&lt;&#x2f;strong&gt;: Before jumping to the interrupt handler function, the CPU pushes the instruction pointer (&lt;code&gt;rip&lt;&#x2f;code&gt;) and the code segment (&lt;code&gt;cs&lt;&#x2f;code&gt;). This is comparable to the return address push of a normal function call.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Pushing an error code&lt;&#x2f;strong&gt; (for some exceptions): For some specific exceptions such as page faults, the CPU pushes an error code, which describes the cause of the exception.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Invoking the interrupt handler&lt;&#x2f;strong&gt;: The CPU reads the address and the segment descriptor of the interrupt handler function from the corresponding field in the IDT. It then invokes this handler by loading the values into the &lt;code&gt;rip&lt;&#x2f;code&gt; and &lt;code&gt;cs&lt;&#x2f;code&gt; registers.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;So the &lt;em&gt;exception stack frame&lt;&#x2f;em&gt; looks like this:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate, the exception stack frame is represented by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.ExceptionStackFrame.html&quot;&gt;&lt;code&gt;ExceptionStackFrame&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct. It is passed to interrupt handlers as &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; and can be used to retrieve additional information about the exception&#x27;s cause. The struct contains no error code field, since only some few exceptions push an error code. These exceptions use the separate &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;type.HandlerFuncWithErrCode.html&quot;&gt;&lt;code&gt;HandlerFuncWithErrCode&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; function type, which has an additional &lt;code&gt;error_code&lt;&#x2f;code&gt; argument.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;behind-the-scenes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#behind-the-scenes&quot; aria-label=&quot;Anchor link for: behind-the-scenes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Behind the Scenes&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is a powerful abstraction that hides almost all of the messy details of the exception handling process. However, sometimes it&#x27;s useful to know what&#x27;s happening behind the curtain. Here is a short overview of the things that the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention takes care of:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Retrieving the arguments&lt;&#x2f;strong&gt;: Most calling conventions expect that the arguments are passed in registers. This is not possible for exception handlers, since we must not overwrite any register values before backing them up on the stack. Instead, the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is aware that the arguments already lie on the stack at a specific offset.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Returning using &lt;code&gt;iretq&lt;&#x2f;code&gt;&lt;&#x2f;strong&gt;: Since the exception stack frame completely differs from stack frames of normal function calls, we can&#x27;t return from handlers functions through the normal &lt;code&gt;ret&lt;&#x2f;code&gt; instruction. Instead, the &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction must be used.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Handling the error code&lt;&#x2f;strong&gt;: The error code, which is pushed for some exceptions, makes things much more complex. It changes the stack alignment (see the next point) and needs to be popped off the stack before returning. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention handles all that complexity. However, it doesn&#x27;t know which handler function is used for which exception, so it needs to deduce that information from the number of function arguments. That means that the programmer is still responsible to use the correct function type for each exception. Luckily, the &lt;code&gt;Idt&lt;&#x2f;code&gt; type defined by the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate ensures that the correct function types are used.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Aligning the stack&lt;&#x2f;strong&gt;: There are some instructions (especially SSE instructions) that require a 16-byte stack alignment. The CPU ensures this alignment whenever an exception occurs, but for some exceptions it destroys it again later when it pushes an error code. The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention takes care of this by realigning the stack in this case.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;If you are interested in more details: We also have a series of posts that explains exception handling using &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2f;a&gt; linked &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;#too-much-magic&quot;&gt;at the end of this post&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we&#x27;ve understood the theory, it&#x27;s time to handle CPU exceptions in our kernel. We start by creating a new &lt;code&gt;interrupts&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;In the new module, we create an &lt;code&gt;init&lt;&#x2f;code&gt; function, that creates a new &lt;code&gt;Idt&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::Idt;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt::new();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can add handler functions. We start by adding a handler for the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Breakpoint&quot;&gt;breakpoint exception&lt;&#x2f;a&gt;. The breakpoint exception is the perfect exception to test exception handling. Its only purpose is to temporary pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2f;code&gt; is executed.&lt;&#x2f;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;01&#x2f;27&#x2f;how-debuggers-work-part-2-breakpoints&quot;&gt;&amp;quot;&lt;em&gt;How debuggers work&lt;&#x2f;em&gt;&amp;quot;&lt;&#x2f;a&gt; series.&lt;&#x2f;p&gt;
&lt;p&gt;For our use case, we don&#x27;t need to overwrite any instructions (it wouldn&#x27;t even be possible since we &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#using-the-correct-flags&quot;&gt;set the page table flags&lt;&#x2f;a&gt; to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s create a simple &lt;code&gt;breakpoint_handler&lt;&#x2f;code&gt; function and add it to our IDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::idt::ExceptionStackFrame;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt::new();
    idt.breakpoint.set_handler_fn(breakpoint_handler);
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;breakpoint_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ExceptionStackFrame)
{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: BREAKPOINT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our handler just outputs a message and pretty-prints the exception stack frame.&lt;&#x2f;p&gt;
&lt;p&gt;When we try to compile it, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: x86-interrupt ABI is experimental and subject to change (see issue #40180)
  --&amp;gt; src&#x2f;interrupts.rs:8:1
   |
8  |   extern &amp;quot;x86-interrupt&amp;quot; fn breakpoint_handler(
   |  _^ starting here...
9  | |     stack_frame: &amp;amp;mut ExceptionStackFrame)
10 | | {
11 | |     println!(&amp;quot;EXCEPTION: BREAKPOINT\n{:#?}&amp;quot;, stack_frame);
12 | | }
   | |_^ ...ending here
   |
   = help: add #![feature(abi_x86_interrupt)] to the crate attributes to enable
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This error occurs because the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention is still unstable. To use it anyway, we have to explicitly enable it by adding &lt;code&gt;#![feature(abi_x86_interrupt)]&lt;&#x2f;code&gt; on the top of our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the IDT&lt;&#x2f;h3&gt;
&lt;p&gt;In order that the CPU uses our new interrupt descriptor table, we need to load it using the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;lgdt:lidt&quot;&gt;&lt;code&gt;lidt&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; instruction. The &lt;code&gt;Idt&lt;&#x2f;code&gt; struct of the &lt;code&gt;x86_64&lt;&#x2f;code&gt; provides a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.Idt.html#method.load&quot;&gt;&lt;code&gt;load&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; method function for that. Let&#x27;s try to use it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt::new();
    idt.breakpoint.set_handler_fn(breakpoint_handler);
    idt.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we try to compile it now, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `idt` does not live long enough
  --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:43:5
   |
43 |     idt.load();
   |     ^^^ does not live long enough
44 | }
   | - borrowed value only lives until here
   |
   = note: borrowed value must be valid for the static lifetime...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the &lt;code&gt;load&lt;&#x2f;code&gt; methods expects a &lt;code&gt;&amp;amp;&#x27;static self&lt;&#x2f;code&gt;, that is a reference that is valid for the complete runtime of the program. The reason is that the CPU will access this table on every interrupt until we load a different IDT. So using a shorter lifetime than &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; could lead to use-after-free bugs.&lt;&#x2f;p&gt;
&lt;p&gt;In fact, this is exactly what happens here. Our &lt;code&gt;idt&lt;&#x2f;code&gt; is created on the stack, so it is only valid inside the &lt;code&gt;init&lt;&#x2f;code&gt; function. Afterwards the stack memory is reused for other functions, so the CPU would interpret random stack memory as IDT. Luckily, the &lt;code&gt;Idt::load&lt;&#x2f;code&gt; method encodes this lifetime requirement in its function definition, so that the Rust compiler is able to prevent this possible bug at compile time.&lt;&#x2f;p&gt;
&lt;p&gt;In order to fix this problem, we need to store our &lt;code&gt;idt&lt;&#x2f;code&gt; at a place where it has a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime. To achieve this, we could either allocate our IDT on the heap using &lt;code&gt;Box&lt;&#x2f;code&gt; and then convert it to a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; reference or we can store the IDT as a &lt;code&gt;static&lt;&#x2f;code&gt;. Let&#x27;s try the latter:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt::new();

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.breakpoint.set_handler_fn(breakpoint_handler);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;There are two problems with this. First, statics are immutable, so we can&#x27;t modify the breakpoint entry from our &lt;code&gt;init&lt;&#x2f;code&gt; function. Second, the &lt;code&gt;Idt::new&lt;&#x2f;code&gt; function is not a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;0911-const-fn.md&quot;&gt;&lt;code&gt;const&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt;, so it can&#x27;t be used to initialize a &lt;code&gt;static&lt;&#x2f;code&gt;. We could solve this problem by using a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;&lt;code&gt;static mut&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; of type &lt;code&gt;Option&amp;lt;Idt&amp;gt;&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;static mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Option&amp;lt;Idt&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(Idt::new());
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.as_mut_ref().unwrap();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt.load();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This variant compiles without errors but it&#x27;s far from idiomatic. &lt;code&gt;static mut&lt;&#x2f;code&gt;s are very prone to data races, so we need an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html#unsafe-superpowers&quot;&gt;&lt;code&gt;unsafe&lt;&#x2f;code&gt; block&lt;&#x2f;a&gt; on each access. Also, we need to explicitly &lt;code&gt;unwrap&lt;&#x2f;code&gt; the &lt;code&gt;IDT&lt;&#x2f;code&gt; on each use, since might be &lt;code&gt;None&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Lazy Statics to the Rescue&lt;&#x2f;h4&gt;
&lt;p&gt;The one-time initialization of statics with non-const functions is a common problem in Rust. Fortunately, there already exists a good solution in a crate named &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;lazy_static&#x2f;0.2.4&#x2f;lazy_static&#x2f;&quot;&gt;lazy_static&lt;&#x2f;a&gt;. This crate provides a &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro that defines a lazily initialized &lt;code&gt;static&lt;&#x2f;code&gt;. Instead of computing its value at compile time, the &lt;code&gt;static&lt;&#x2f;code&gt; laziliy initializes itself when it&#x27;s accessed the first time. Thus, the initialization happens at runtime so that arbitrarily complex initialization code is possible.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; crate to our project:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; lazy_static;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.4&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2f;code&gt; feature, since we don&#x27;t link the standard library. We also need the &lt;code&gt;#[macro_use]&lt;&#x2f;code&gt; attribute on the &lt;code&gt;extern crate&lt;&#x2f;code&gt; line to import the &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can create our static IDT using &lt;code&gt;lazy_static&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt::new();
        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note how this solution requires no &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks or &lt;code&gt;unwrap&lt;&#x2f;code&gt; calls.&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;aside-how-does-the-lazy-static-macro-work&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#aside-how-does-the-lazy-static-macro-work&quot; aria-label=&quot;Anchor link for: aside-how-does-the-lazy-static-macro-work&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Aside: How does the &lt;code&gt;lazy_static!&lt;&#x2f;code&gt; macro work?&lt;&#x2f;h5&gt;
&lt;p&gt;The macro generates a &lt;code&gt;static&lt;&#x2f;code&gt; of type &lt;code&gt;Once&amp;lt;Idt&amp;gt;&lt;&#x2f;code&gt;. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html&quot;&gt;&lt;code&gt;Once&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type is provided by the &lt;code&gt;spin&lt;&#x2f;code&gt; crate and allows deferred one-time initialization. It is implemented using an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;sync&#x2f;atomic&#x2f;struct.AtomicUsize.html&quot;&gt;&lt;code&gt;AtomicUsize&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for synchronization and an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cell&#x2f;struct.UnsafeCell.html&quot;&gt;&lt;code&gt;UnsafeCell&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; for storing the (possibly unitialized) value. So this solution also uses &lt;code&gt;unsafe&lt;&#x2f;code&gt; behind the scenes, but it is abstracted away in a safe interface.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h3&gt;
&lt;p&gt;Now we should be able to handle breakpoint exceptions! Let&#x27;s try it in our &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(...) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init(boot_info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; invoke a breakpoint exception
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::interrupts::int3();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it in QEMU now (using &lt;code&gt;make run&lt;&#x2f;code&gt;), we see the following:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;qemu-breakpoint-exception.png&quot; alt=&quot;QEMU printing EXCEPTION: BREAKPOINT and the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It works! The CPU successfully invokes our breakpoint handler, which prints the message, and then returns back to the &lt;code&gt;rust_main&lt;&#x2f;code&gt; function, where the &lt;code&gt;It did not crash!&lt;&#x2f;code&gt; message is printed.&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;&#x2f;strong&gt;: If it doesn&#x27;t work and a boot loop occurs, this might be caused by a kernel stack overflow. Try increasing the stack size to at least 16kB (4096 * 4 bytes) in the &lt;code&gt;boot.asm&lt;&#x2f;code&gt; file.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;We see that the exception stack frame tells us the instruction and stack pointers at the time when the exception occurred. This information is very useful when debugging unexpected exceptions. For example, we can look at the corresponding assembly line using &lt;code&gt;objdump&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep -B5 &amp;quot;1140a6:&amp;quot;
00000000001140a0 &amp;lt;x86_64::instructions::interrupts::int3::h015bf61815bb8afe&amp;gt;:
  1140a0:	55                   	push   %rbp
  1140a1:	48 89 e5             	mov    %rsp,%rbp
  1140a4:	50                   	push   %rax
  1140a5:	cc                   	int3
  1140a6:	48 83 c4 08          	add    $0x8,%rsp
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;-d&lt;&#x2f;code&gt; flags disassembles the &lt;code&gt;code&lt;&#x2f;code&gt; section and &lt;code&gt;-C&lt;&#x2f;code&gt; flag makes function names more readable by &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Name_mangling&quot;&gt;demangling&lt;&#x2f;a&gt; them. The &lt;code&gt;-B&lt;&#x2f;code&gt; flag of &lt;code&gt;grep&lt;&#x2f;code&gt; specifies the number of preceding lines that should be shown (5 in our case).&lt;&#x2f;p&gt;
&lt;p&gt;We clearly see the &lt;code&gt;int3&lt;&#x2f;code&gt; exception that caused the breakpoint exception at address &lt;code&gt;1140a5&lt;&#x2f;code&gt;. Waitâ€¦ the stored instruction pointer was &lt;code&gt;1140a6&lt;&#x2f;code&gt;, which is a normal &lt;code&gt;add&lt;&#x2f;code&gt; operation. What&#x27;s happening here?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;faults-aborts-and-traps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#faults-aborts-and-traps&quot; aria-label=&quot;Anchor link for: faults-aborts-and-traps&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Faults, Aborts, and Traps&lt;&#x2f;h3&gt;
&lt;p&gt;The answer is that the stored instruction pointer only points to the causing instruction for &lt;em&gt;fault&lt;&#x2f;em&gt; type exceptions, but not for &lt;em&gt;trap&lt;&#x2f;em&gt; or &lt;em&gt;abort&lt;&#x2f;em&gt; type exceptions. The difference between these types is the following:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Faults&lt;&#x2f;strong&gt; are exceptions that can be corrected so that the program can continue as if nothing happened. An example is the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;page fault&lt;&#x2f;a&gt;, which can often be resolved by loading the accessed page from the disk into memory.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Aborts&lt;&#x2f;strong&gt; are fatal exceptions that can&#x27;t be recovered. Examples are &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Machine_Check&quot;&gt;machine check exception&lt;&#x2f;a&gt; or the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Double_Fault&quot;&gt;double fault&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Traps&lt;&#x2f;strong&gt; are only reported to the kernel, but don&#x27;t hinder the continuation of the program. Examples are the breakpoint exception and the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Overflow&quot;&gt;overflow exception&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The reason for the diffent instruction pointer values is that the stored value is also the return address. So for faults, the instruction that caused the exception is restarted and might cause the same exception again if it&#x27;s not resolved. This would not make much sense for traps, since invoking the breakpoint exception again would just cause another breakpoint exception&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-breakpoint-restart-use-cases&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;. Thus the instruction pointer points to the &lt;em&gt;next&lt;&#x2f;em&gt; instruction for these exceptions.&lt;&#x2f;p&gt;
&lt;p&gt;In some cases, the distinction between faults and traps is vague. For example, the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Debug&quot;&gt;debug exception&lt;&#x2f;a&gt; behaves like a fault in some cases, but like a trap in others. So to find out the meaning of the saved instruction pointer, it is a good idea to read the official documentation for the exception, which can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;www.amd.com&#x2f;system&#x2f;files&#x2f;TechDocs&#x2f;24593.pdf&quot;&gt;AMD64 manual&lt;&#x2f;a&gt; in Section 8.2. For example, for the breakpoint exception it says:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;#BP&lt;&#x2f;code&gt; is a trap-type exception. The saved instruction pointer points to the byte after the &lt;code&gt;INT3&lt;&#x2f;code&gt; instruction.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;The documentation of the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; struct and the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;OSDev Wiki&lt;&#x2f;a&gt; also contain this information.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;too-much-magic&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#too-much-magic&quot; aria-label=&quot;Anchor link for: too-much-magic&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Too much Magic?&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;idt&#x2f;struct.Idt.html&quot;&gt;&lt;code&gt;Idt&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; type made the exception handling process relatively straightforward and painless. If this was too much magic for you and you like to learn all the gory details of exception handling, we got you covered: Our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;extra&#x2f;naked-exceptions&#x2f;&quot;&gt;â€œHandling Exceptions with Naked Functionsâ€&lt;&#x2f;a&gt; series shows how to handle exceptions without the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and also creates its own &lt;code&gt;Idt&lt;&#x2f;code&gt; type. Historically, these posts were the main exception handling posts before the &lt;code&gt;x86-interrupt&lt;&#x2f;code&gt; calling convention and the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate existed.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;We&#x27;ve successfully caught our first exception and returned from it! The next step is to add handlers for other common exceptions such as page faults. We also need to make sure that we never cause a &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Triple_Fault&quot;&gt;triple fault&lt;&#x2f;a&gt;, since it causes a complete system reset. The next post explains how we can avoid this by correctly catching &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Double_Fault#Double_Fault&quot;&gt;double faults&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-breakpoint-restart-use-cases&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;There are valid use cases for restarting an instruction that caused a breakpoint. The most common use case is a debugger: When setting a breakpoint on some code line, the debugger overwrites the corresponding instruction with an &lt;code&gt;int3&lt;&#x2f;code&gt; instruction, so that the CPU traps when that line is executed. When the user continues execution, the debugger swaps in the original instruction and continues the program from the replaced instruction.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Double Faults</title>
                <pubDate>Mon, 02 Jan 2017 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/double-faults/</link>
                <guid>https://os.phil-opp.com/double-faults/</guid>
                <description>&lt;p&gt;In this post we explore double faults in detail. We also set up an &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; to catch double faults on a separate kernel stack. This way, we can completely prevent triple faults, even on kernel stack overflow.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, the complete source code is available on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_10&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2f;&#x2f;gitter.im&#x2f;phil-opp&#x2f;blog_os&quot;&gt;gitter chat&lt;&#x2f;a&gt; and a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-is-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-is-a-double-fault&quot; aria-label=&quot;Anchor link for: what-is-a-double-fault&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What is a Double Fault?&lt;&#x2f;h2&gt;
&lt;p&gt;In simplified terms, a double fault is a special exception that occurs when the CPU fails to invoke an exception handler. For example, it occurs when a page fault is triggered but there is no page fault handler registered in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;Interrupt Descriptor Table&lt;&#x2f;a&gt; (IDT). So it&#x27;s kind of similar to catch-all blocks in programming languages with exceptions, e.g. &lt;code&gt;catch(...)&lt;&#x2f;code&gt; in C++ or &lt;code&gt;catch(Exception e)&lt;&#x2f;code&gt; in Java or C#.&lt;&#x2f;p&gt;
&lt;p&gt;A double fault behaves like a normal exception. It has the vector number &lt;code&gt;8&lt;&#x2f;code&gt; and we can define a normal handler function for it in the IDT. It is really important to provide a double fault handler, because if a double fault is unhandled a fatal &lt;em&gt;triple fault&lt;&#x2f;em&gt; occurs. Triple faults can&#x27;t be caught and most hardware reacts with a system reset.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;triggering-a-double-fault&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#triggering-a-double-fault&quot; aria-label=&quot;Anchor link for: triggering-a-double-fault&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Triggering a Double Fault&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s provoke a double fault by triggering an exception for that we didn&#x27;t define a handler function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a page fault
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    };

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We try to write to address &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;, but the corresponding page is not present in the page tables. Thus, a page fault occurs. We haven&#x27;t registered a page fault handler in our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;IDT&lt;&#x2f;a&gt;, so a double fault occurs.&lt;&#x2f;p&gt;
&lt;p&gt;When we start our kernel now, we see that it enters an endless boot loop:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-faults&#x2f;boot-loop.gif&quot; alt=&quot;boot loop&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The reason for the boot loop is the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU tries to write to &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;, which causes a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU looks at the corresponding entry in the IDT and sees that the present bit isn&#x27;t set. Thus, it can&#x27;t call the page fault handler and a double fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU looks at the IDT entry of the double fault handler, but this entry is also non-present. Thus, a &lt;em&gt;triple&lt;&#x2f;em&gt; fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;A triple fault is fatal. QEMU reacts to it like most real hardware and issues a system reset.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;So in order to prevent this triple fault, we need to either provide a handler function for page faults or a double fault handler. Let&#x27;s start with the latter, since we want to avoid triple faults in all cases.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-double-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-double-fault-handler&quot; aria-label=&quot;Anchor link for: a-double-fault-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Double Fault Handler&lt;&#x2f;h3&gt;
&lt;p&gt;A double fault is a normal exception with an error code, so we can use our &lt;code&gt;handler_with_error_code&lt;&#x2f;code&gt; macro to create a wrapper function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();

        idt.breakpoint.set_handler_fn(breakpoint_handler);
        idt.double_fault.set_handler_fn(double_fault_handler);

        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; our new double fault handler
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86-interrupt&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;double_fault_handler(
    stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ExceptionStackFrame, _error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DOUBLE FAULT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our handler prints a short error message and dumps the exception stack frame. The error code of the double fault handler is always zero, so there&#x27;s no reason to print it.&lt;&#x2f;p&gt;
&lt;p&gt;When we start our kernel now, we should see that the double fault handler is invoked:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-faults&#x2f;qemu-catch-double-fault.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It worked! Here is what happens this time:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU executes tries to write to &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;, which causes a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;Like before, the CPU looks at the corresponding entry in the IDT and sees that the present bit isn&#x27;t set. Thus, a double fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU jumps to the â€“ now present â€“ double fault handler.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The triple fault (and the boot-loop) no longer occurs, since the CPU can now call the double fault handler.&lt;&#x2f;p&gt;
&lt;p&gt;That was quite straightforward! So why do we need a whole post for this topic? Well, we&#x27;re now able to catch &lt;em&gt;most&lt;&#x2f;em&gt; double faults, but there are some cases where our current approach doesn&#x27;t suffice.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;causes-of-double-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#causes-of-double-faults&quot; aria-label=&quot;Anchor link for: causes-of-double-faults&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Causes of Double Faults&lt;&#x2f;h2&gt;
&lt;p&gt;Before we look at the special cases, we need to know the exact causes of double faults. Above, we used a pretty vague definition:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A double fault is a special exception that occurs when the CPU fails to invoke an exception handler.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;What does &lt;em&gt;â€œfails to invokeâ€&lt;&#x2f;em&gt; mean exactly? The handler is not present? The handler is &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;vm-beyondphys.pdf&quot;&gt;swapped out&lt;&#x2f;a&gt;? And what happens if a handler causes exceptions itself?&lt;&#x2f;p&gt;
&lt;p&gt;For example, what happens ifâ€¦ :&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;a divide-by-zero exception occurs, but the corresponding handler function is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;a page fault occurs, but the page fault handler is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;a divide-by-zero handler causes a breakpoint exception, but the breakpoint handler is swapped out?&lt;&#x2f;li&gt;
&lt;li&gt;our kernel overflows its stack and the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2f;a&gt; is hit?&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;Fortunately, the AMD64 manual (&lt;a href=&quot;https:&#x2f;&#x2f;www.amd.com&#x2f;system&#x2f;files&#x2f;TechDocs&#x2f;24593.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) has an exact definition (in Section 8.2.9). According to it, a â€œdouble fault exception &lt;em&gt;can&lt;&#x2f;em&gt; occur when a second exception occurs during the handling of a prior (first) exception handlerâ€. The &lt;em&gt;â€œcanâ€&lt;&#x2f;em&gt; is important: Only very specific combinations of exceptions lead to a double fault. These combinations are:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;First Exception &lt;&#x2f;th&gt;&lt;th&gt;Second Exception&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Divide-by-zero_Error&quot;&gt;Divide-by-zero&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2f;a&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;Page Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Invalid_TSS&quot;&gt;Invalid TSS&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Segment_Not_Present&quot;&gt;Segment Not Present&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Stack-Segment_Fault&quot;&gt;Stack-Segment Fault&lt;&#x2f;a&gt;,&lt;br&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#General_Protection_Fault&quot;&gt;General Protection Fault&lt;&#x2f;a&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;So for example a divide-by-zero fault followed by a page fault is fine (the page fault handler is invoked), but a divide-by-zero fault followed by a general-protection fault leads to a double fault.&lt;&#x2f;p&gt;
&lt;p&gt;With the help of this table, we can answer the first three of the above questions:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;If a divide-by-zero exception occurs and the corresponding handler function is swapped out, a &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;li&gt;If a page fault occurs and the page fault handler is swapped out, a &lt;em&gt;double fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;double fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;li&gt;If a divide-by-zero handler causes a breakpoint exception, the CPU tries to invoke the breakpoint handler. If the breakpoint handler is swapped out, a &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs and the &lt;em&gt;page fault handler&lt;&#x2f;em&gt; is invoked.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;In fact, even the case of a non-present handler follows this scheme: A non-present handler causes a &lt;em&gt;segment-not-present&lt;&#x2f;em&gt; exception. We didn&#x27;t define a segment-not-present handler, so another segment-not-present exception occurs. According to the table, this leads to a double fault.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;kernel-stack-overflow&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-stack-overflow&quot; aria-label=&quot;Anchor link for: kernel-stack-overflow&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Kernel Stack Overflow&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s look at the fourth question:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What happens if our kernel overflows its stack and the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2f;a&gt; is hit?&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;When our kernel overflows its stack and hits the guard page, a &lt;em&gt;page fault&lt;&#x2f;em&gt; occurs. The CPU looks up the page fault handler in the IDT and tries to push the &lt;a href=&quot;http:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages.html#exceptions-in-detail&quot;&gt;exception stack frame&lt;&#x2f;a&gt; onto the stack. However, our current stack pointer still points to the non-present guard page. Thus, a second page fault occurs, which causes a double fault (according to the above table).&lt;&#x2f;p&gt;
&lt;p&gt;So the CPU tries to call our &lt;em&gt;double fault handler&lt;&#x2f;em&gt; now. However, on a double fault the CPU tries to push the exception stack frame, too. Our stack pointer still points to the guard page, so a &lt;em&gt;third&lt;&#x2f;em&gt; page fault occurs, which causes a &lt;em&gt;triple fault&lt;&#x2f;em&gt; and a system reboot. So our current double fault handler can&#x27;t avoid a triple fault in this case.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s try it ourselves! We can easily provoke a kernel stack overflow by calling a function that recurses endlessly:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow() {
        stack_overflow(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; for each recursion, the return address is pushed
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a stack overflow
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we try this code in QEMU, we see that the system enters a boot-loop again.&lt;&#x2f;p&gt;
&lt;p&gt;So how can we avoid this problem? We can&#x27;t omit the pushing of the exception stack frame, since the CPU itself does it. So we need to ensure somehow that the stack is always valid when a double fault exception occurs. Fortunately, the x86_64 architecture has a solution to this problem.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;switching-stacks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-stacks&quot; aria-label=&quot;Anchor link for: switching-stacks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Switching Stacks&lt;&#x2f;h2&gt;
&lt;p&gt;The x86_64 architecture is able to switch to a predefined, known-good stack when an exception occurs. This switch happens at hardware level, so it can be performed before the CPU pushes the exception stack frame.&lt;&#x2f;p&gt;
&lt;p&gt;This switching mechanism is implemented as an &lt;em&gt;Interrupt Stack Table&lt;&#x2f;em&gt; (IST). The IST is a table of 7 pointers to known-good stacks. In Rust-like pseudo code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InterruptStackTable {
    stack_pointers: [Option&amp;lt;StackPointer&amp;gt;; 7],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For each exception handler, we can choose a stack from the IST through the &lt;code&gt;options&lt;&#x2f;code&gt; field in the corresponding &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;#the-interrupt-descriptor-table&quot;&gt;IDT entry&lt;&#x2f;a&gt;. For example, we could use the first stack in the IST for our double fault handler. Then the CPU would automatically switch to this stack whenever a double fault occurs. This switch would happen before anything is pushed, so it would prevent the triple fault.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;allocating-a-new-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-a-new-stack&quot; aria-label=&quot;Anchor link for: allocating-a-new-stack&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocating a new Stack&lt;&#x2f;h3&gt;
&lt;p&gt;In order to fill an Interrupt Stack Table later, we need a way to allocate new stacks. Therefore we extend our &lt;code&gt;memory&lt;&#x2f;code&gt; module with a new &lt;code&gt;stack_allocator&lt;&#x2f;code&gt; submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_allocator;

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we create a new &lt;code&gt;StackAllocator&lt;&#x2f;code&gt; struct and a constructor function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;stack_allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::paging::PageIter;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;StackAllocator {
    range: PageIter,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;StackAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(page_range: PageIter) -&amp;gt; StackAllocator {
        StackAllocator { range: page_range }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We create a simple &lt;code&gt;StackAllocator&lt;&#x2f;code&gt; that allocates stacks from a given range of pages (&lt;code&gt;PageIter&lt;&#x2f;code&gt; is an Iterator over a range of pages; we introduced it &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;#mapping-the-heap&quot;&gt;in the kernel heap post&lt;&#x2f;a&gt;.).&lt;&#x2f;p&gt;
&lt;p&gt;We add a &lt;code&gt;alloc_stack&lt;&#x2f;code&gt; method that allocates a new stack:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;stack_allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::paging::{self, Page, ActivePageTable};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, FrameAllocator};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;StackAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_stack&amp;lt;FA: FrameAllocator&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                                           active_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable,
                                           frame_allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; FA,
                                           size_in_pages: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
                                           -&amp;gt; Option&amp;lt;Stack&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; size_in_pages &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* a zero sized stack makes no sense *&#x2f;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; clone the range, since we only want to change it on success
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; range &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.range.clone();

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; try to allocate the stack pages and a guard page
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; guard_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; range.next();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; range.next();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; size_in_pages &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            stack_start
        } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; choose the (size_in_pages-2)th element, since index
            &#x2f;&#x2f; starts at 0 and we already allocated the start page
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;            range.nth(size_in_pages &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        };

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(guard_page, stack_start, stack_end) {
            (Some(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;), Some(start), Some(end)) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; success! write back updated range
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.range &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; range;

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; map stack pages to physical frames
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::range_inclusive(start, end) {
                    active_table.map(page, paging::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, frame_allocator);
                }

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; create a new stack
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; top_of_stack &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; end.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
                Some(Stack::new(top_of_stack, start.start_address()))
            }
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_ =&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* not enough pages *&#x2f;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The method takes mutable references to the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;#page-table-ownership&quot;&gt;ActivePageTable&lt;&#x2f;a&gt; and a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;#a-frame-allocator&quot;&gt;FrameAllocator&lt;&#x2f;a&gt;, since it needs to map the new virtual stack pages to physical frames. We define that the stack size is a multiple of the page size.&lt;&#x2f;p&gt;
&lt;p&gt;Instead of operating directly on &lt;code&gt;self.range&lt;&#x2f;code&gt;, we &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;clone&#x2f;trait.Clone.html#tymethod.clone&quot;&gt;clone&lt;&#x2f;a&gt; it and only write it back on success. This way, subsequent stack allocations can still succeed if there are pages left (e.g., a call with &lt;code&gt;size_in_pages = 3&lt;&#x2f;code&gt; can still succeed after a failed call with &lt;code&gt;size_in_pages = 100&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;In order to be able to clone &lt;code&gt;PageIter&lt;&#x2f;code&gt;, we add a &lt;code&gt;#[derive(Clone)]&lt;&#x2f;code&gt; to its definition in &lt;code&gt;src&#x2f;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;. We also need to make the &lt;code&gt;start_address&lt;&#x2f;code&gt; method of the &lt;code&gt;Page&lt;&#x2f;code&gt; type public (in the same file).&lt;&#x2f;p&gt;
&lt;p&gt;The actual allocation is straightforward: First, we choose the next page as &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#creating-a-guard-page&quot;&gt;guard page&lt;&#x2f;a&gt;. Then we choose the next &lt;code&gt;size_in_pages&lt;&#x2f;code&gt; pages as stack pages using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.nth&quot;&gt;Iterator::nth&lt;&#x2f;a&gt;. If all three variables are &lt;code&gt;Some&lt;&#x2f;code&gt;, the allocation succeeded and we map the stack pages to physical frames using &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;#more-mapping-functions&quot;&gt;ActivePageTable::map&lt;&#x2f;a&gt;. The guard page remains unmapped.&lt;&#x2f;p&gt;
&lt;p&gt;Finally, we create and return a new &lt;code&gt;Stack&lt;&#x2f;code&gt;, which we define as follows:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;stack_allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Stack {
    top: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    bottom: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Stack {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(top: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, bottom: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Stack {
        assert!(top &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; bottom);
        Stack {
            top: top,
            bottom: bottom,
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;top(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.top
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bottom(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.bottom
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Stack&lt;&#x2f;code&gt; struct describes a stack though its top and bottom addresses.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-memory-controller&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-memory-controller&quot; aria-label=&quot;Anchor link for: the-memory-controller&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Memory Controller&lt;&#x2f;h4&gt;
&lt;p&gt;Now we&#x27;re able to allocate a new double fault stack. However, we add one more level of abstraction to make things easier. For that we add a new &lt;code&gt;MemoryController&lt;&#x2f;code&gt; type to our &lt;code&gt;memory&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::stack_allocator::Stack;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;MemoryController {
    active_table: paging::ActivePageTable,
    frame_allocator: AreaFrameAllocator,
    stack_allocator: stack_allocator::StackAllocator,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;MemoryController {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc_stack(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, size_in_pages: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;Stack&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController { &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table,
                                    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator,
                                    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ref mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_allocator } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self;
        stack_allocator.alloc_stack(active_table, frame_allocator,
                                    size_in_pages)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;MemoryController&lt;&#x2f;code&gt; struct holds the three types that are required for &lt;code&gt;alloc_stack&lt;&#x2f;code&gt; and provides a simpler interface (only one argument). The &lt;code&gt;alloc_stack&lt;&#x2f;code&gt; wrapper just takes the tree types as &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; through &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;book&#x2f;patterns.html#destructuring&quot;&gt;destructuring&lt;&#x2f;a&gt; and forwards them to the &lt;code&gt;stack_allocator&lt;&#x2f;code&gt;. The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.30.0&#x2f;book&#x2f;second-edition&#x2f;ch18-03-pattern-syntax.html#creating-references-in-patterns-with-ref-and-ref-mut&quot;&gt;ref mut&lt;&#x2f;a&gt;-s are needed to take the inner fields by mutable reference. Note that we&#x27;re re-exporting the &lt;code&gt;Stack&lt;&#x2f;code&gt; type since it is returned by &lt;code&gt;alloc_stack&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The last step is to create a &lt;code&gt;StackAllocator&lt;&#x2f;code&gt; and return a &lt;code&gt;MemoryController&lt;&#x2f;code&gt; from &lt;code&gt;memory::init&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation) -&amp;gt; MemoryController {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_alloc_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_alloc_range &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::range_inclusive(stack_alloc_start,
                                                      stack_alloc_end);
        stack_allocator::StackAllocator::new(stack_alloc_range)
    };

    MemoryController {
        active_table: active_table,
        frame_allocator: frame_allocator,
        stack_allocator: stack_allocator,
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We create a new &lt;code&gt;StackAllocator&lt;&#x2f;code&gt; with a range of 100 pages starting right after the last heap page.&lt;&#x2f;p&gt;
&lt;p&gt;In order to do arithmetic on pages (e.g. calculate the hundredth page after &lt;code&gt;stack_alloc_start&lt;&#x2f;code&gt;), we implement &lt;code&gt;Add&amp;lt;usize&amp;gt;&lt;&#x2f;code&gt; for &lt;code&gt;Page&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ops::Add;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Add&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Page;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;add(self, rhs: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Page {
        Page { number: self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; rhs }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h4 id=&quot;allocating-a-double-fault-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocating-a-double-fault-stack&quot; aria-label=&quot;Anchor link for: allocating-a-double-fault-stack&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocating a Double Fault Stack&lt;&#x2f;h4&gt;
&lt;p&gt;Now we can allocate a new double fault stack by passing the memory controller to our &lt;code&gt;interrupts::init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; set up guard page and map the heap pages
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init(boot_info); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new return type

    &#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new argument

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}


&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::MemoryController;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_controller: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; double_fault_stack &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller.alloc_stack(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We allocate a 4096 bytes stack (one page) for our double fault handler. Now we just need some way to tell the CPU that it should use this stack for handling double faults.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-ist-and-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-ist-and-tss&quot; aria-label=&quot;Anchor link for: the-ist-and-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The IST and TSS&lt;&#x2f;h3&gt;
&lt;p&gt;The Interrupt Stack Table (IST) is part of an old legacy structure called &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Task_state_segment&quot;&gt;Task State Segment&lt;&#x2f;a&gt;&lt;&#x2f;em&gt; (TSS). The TSS used to hold various information (e.g. processor register state) about a task in 32-bit mode and was for example used for &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Context_Switching#Hardware_Context_Switching&quot;&gt;hardware context switching&lt;&#x2f;a&gt;. However, hardware context switching is no longer supported in 64-bit mode and the format of the TSS changed completely.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, the TSS no longer holds any task specific information at all. Instead, it holds two stack tables (the IST is one of them). The only common field between the 32-bit and 64-bit TSS is the pointer to the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Task_state_segment#I.2FO_port_permissions&quot;&gt;I&#x2f;O port permissions bitmap&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The 64-bit TSS has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field  &lt;&#x2f;th&gt;&lt;th&gt;Type&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u32&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Privilege Stack Table &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;[u64; 3]&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;Interrupt Stack Table &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;[u64; 7]&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u64&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;span style=&quot;opacity: 0.5&quot;&gt;(reserved)&lt;&#x2f;span&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;I&#x2f;O Map Base Address &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;u16&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The &lt;em&gt;Privilege Stack Table&lt;&#x2f;em&gt; is used by the CPU when the privilege level changes. For example, if an exception occurs while the CPU is in user mode (privilege level 3), the CPU normally switches to kernel mode (privilege level 0) before invoking the exception handler. In that case, the CPU would switch to the 0th stack in the Privilege Stack Table (since 0 is the target privilege level). We don&#x27;t have any user mode programs yet, so we ignore this table for now.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;creating-a-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-tss&quot; aria-label=&quot;Anchor link for: creating-a-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a TSS&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s create a new TSS that contains our double fault stack in its interrupt stack table. For that we need a TSS struct. Fortunately, the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate already contains a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;structures&#x2f;tss&#x2f;struct.TaskStateSegment.html&quot;&gt;&lt;code&gt;TaskStateSegment&lt;&#x2f;code&gt; struct&lt;&#x2f;a&gt; that we can use:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::tss::TaskStateSegment;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s create a new TSS in our &lt;code&gt;interrupts::init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtualAddress;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_controller: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; double_fault_stack &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller.alloc_stack(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TaskStateSegment::new();
    tss.interrupt_stack_table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; VirtualAddress(
        double_fault_stack.top());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We define that the 0th IST entry is the double fault stack (any other IST index would work too). We create a new TSS through the &lt;code&gt;TaskStateSegment::new&lt;&#x2f;code&gt; function and load the top address (stacks grow downwards) of the double fault stack into the 0th entry.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;loading-the-tss&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-tss&quot; aria-label=&quot;Anchor link for: loading-the-tss&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the TSS&lt;&#x2f;h4&gt;
&lt;p&gt;Now that we created a new TSS, we need a way to tell the CPU that it should use it. Unfortunately, this is a bit cumbersome, since the TSS is a Task State &lt;em&gt;Segment&lt;&#x2f;em&gt; (for historical reasons). So instead of loading the table directly, we need to add a new segment descriptor to the &lt;a href=&quot;http:&#x2f;&#x2f;www.flingos.co.uk&#x2f;docs&#x2f;reference&#x2f;Global-Descriptor-Table&#x2f;&quot;&gt;Global Descriptor Table&lt;&#x2f;a&gt; (GDT). Then we can load our TSS invoking the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;ltr&quot;&gt;&lt;code&gt;ltr&lt;&#x2f;code&gt; instruction&lt;&#x2f;a&gt; with the respective GDT index.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-global-descriptor-table-again&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table-again&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table-again&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Global Descriptor Table (again)&lt;&#x2f;h3&gt;
&lt;p&gt;The Global Descriptor Table (GDT) is a relict that was used for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_memory_segmentation&quot;&gt;memory segmentation&lt;&#x2f;a&gt; before paging became the de facto standard. It is still needed in 64-bit mode for various things such as kernel&#x2f;user mode configuration or TSS loading.&lt;&#x2f;p&gt;
&lt;p&gt;We already created a GDT &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;#the-global-descriptor-table&quot;&gt;when switching to long mode&lt;&#x2f;a&gt;. Back then, we used assembly to create valid code and data segment descriptors, which were required to enter 64-bit mode. We could just edit that assembly file and add an additional TSS descriptor. However, we now have the expressiveness of Rust, so let&#x27;s do it in Rust instead.&lt;&#x2f;p&gt;
&lt;p&gt;We start by creating a new &lt;code&gt;interrupts::gdt&lt;&#x2f;code&gt; submodule. For that we need to rename the &lt;code&gt;src&#x2f;interrupts.rs&lt;&#x2f;code&gt; file to &lt;code&gt;src&#x2f;interrupts&#x2f;mod.rs&lt;&#x2f;code&gt;. Then we can create a new submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Gdt {
    table: [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; 8],
    next_free: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Gdt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; Gdt {
        Gdt {
            table: [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;],
            next_free: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We create a simple &lt;code&gt;Gdt&lt;&#x2f;code&gt; struct with two fields. The &lt;code&gt;table&lt;&#x2f;code&gt; field contains the actual GDT modeled as a &lt;code&gt;[u64; 8]&lt;&#x2f;code&gt;. Theoretically, a GDT can have up to 8192 entries, but this doesn&#x27;t make much sense in 64-bit mode (since there is no real segmentation support). Eight entries should be more than enough for our system.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;next_free&lt;&#x2f;code&gt; field stores the index of the next free entry. We initialize it with &lt;code&gt;1&lt;&#x2f;code&gt; since the 0th entry needs always needs to be 0 in a valid GDT.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;user-and-system-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#user-and-system-segments&quot; aria-label=&quot;Anchor link for: user-and-system-segments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
User and System Segments&lt;&#x2f;h4&gt;
&lt;p&gt;There are two types of GDT entries in long mode: user and system segment descriptors. Descriptors for code and data segment segments are user segment descriptors. They contain no addresses since segments always span the complete address space on x86_64 (real segmentation is no longer supported). Thus, user segment descriptors only contain a few flags (e.g. present or user mode) and fit into a single &lt;code&gt;u64&lt;&#x2f;code&gt; entry.&lt;&#x2f;p&gt;
&lt;p&gt;System descriptors such as TSS descriptors are different. They often contain a base address and a limit (e.g. TSS start and length) and thus need more than 64 bits. Therefore, system segments are 128 bits. They are stored as two consecutive entries in the GDT.&lt;&#x2f;p&gt;
&lt;p&gt;Consequently, we model a &lt;code&gt;Descriptor&lt;&#x2f;code&gt; as an &lt;code&gt;enum&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Descriptor {
    UserSegment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
    SystemSegment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The flag bits are common between all descriptor types, so we create a general &lt;code&gt;DescriptorFlags&lt;&#x2f;code&gt; type (using the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bitflags&#x2f;0.9.1&#x2f;bitflags&#x2f;macro.bitflags.html&quot;&gt;bitflags&lt;&#x2f;a&gt; macro):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bitflags! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;DescriptorFlags: u64 {
        const CONFORMING        = 1 &amp;lt;&amp;lt; 42;
        const EXECUTABLE        = 1 &amp;lt;&amp;lt; 43;
        const USER_SEGMENT      = 1 &amp;lt;&amp;lt; 44;
        const PRESENT           = 1 &amp;lt;&amp;lt; 47;
        const LONG_MODE         = 1 &amp;lt;&amp;lt; 53;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We only add flags that are relevant in 64-bit mode. For example, we omit the read&#x2f;write bit, since it is completely ignored by the CPU in 64-bit mode.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;code-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#code-segments&quot; aria-label=&quot;Anchor link for: code-segments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Code Segments&lt;&#x2f;h4&gt;
&lt;p&gt;We add a function to create kernel mode code segments:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Descriptor {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_code_segment() -&amp;gt; Descriptor {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;USER_SEGMENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;EXECUTABLE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;LONG_MODE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        Descriptor::UserSegment(flags.bits())
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We set the &lt;code&gt;USER_SEGMENT&lt;&#x2f;code&gt; bit to indicate a 64 bit user segment descriptor (otherwise the CPU expects a 128 bit system segment descriptor). The &lt;code&gt;PRESENT&lt;&#x2f;code&gt;, &lt;code&gt;EXECUTABLE&lt;&#x2f;code&gt;, and &lt;code&gt;LONG_MODE&lt;&#x2f;code&gt; bits are also needed for a 64-bit mode code segment.&lt;&#x2f;p&gt;
&lt;p&gt;The data segment registers &lt;code&gt;ds&lt;&#x2f;code&gt;, &lt;code&gt;ss&lt;&#x2f;code&gt;, and &lt;code&gt;es&lt;&#x2f;code&gt; are completely ignored in 64-bit mode, so we don&#x27;t need any data segment descriptors in our GDT.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;tss-segments&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#tss-segments&quot; aria-label=&quot;Anchor link for: tss-segments&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
TSS Segments&lt;&#x2f;h4&gt;
&lt;p&gt;A TSS descriptor is a system segment descriptor with the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)                &lt;&#x2f;th&gt;&lt;th&gt;Name &lt;&#x2f;th&gt;&lt;th&gt;Meaning&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-15 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;limit 0-15&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;the first 2 byte of the TSS&#x27;s limit&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;16-39 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;base 0-23&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;the first 3 byte of the TSS&#x27;s base address&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;40-43 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;type&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;must be &lt;code&gt;0b1001&lt;&#x2f;code&gt; for an available 64-bit TSS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;44    &lt;&#x2f;td&gt;&lt;td&gt;zero &lt;&#x2f;td&gt;&lt;td&gt;must be 0&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;45-46 &lt;&#x2f;td&gt;&lt;td&gt;privilege &lt;&#x2f;td&gt;&lt;td&gt;the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Security#Rings&quot;&gt;ring level&lt;&#x2f;a&gt;: 0 for kernel, 3 for user&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;47 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;present&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;must be 1 for valid selectors&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;48-51 &lt;&#x2f;td&gt;&lt;td&gt;limit 16-19 &lt;&#x2f;td&gt;&lt;td&gt;bits 16 to 19 of the segment&#x27;s limit&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;52 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;freely available to the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;53-54 &lt;&#x2f;td&gt;&lt;td&gt;ignored &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;55 &lt;&#x2f;td&gt;&lt;td&gt;granularity &lt;&#x2f;td&gt;&lt;td&gt;if it&#x27;s set, the limit is the number of pages, else it&#x27;s a byte number&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;56-63 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;base 24-31&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;the fourth byte of the base address&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;64-95 &lt;&#x2f;td&gt;&lt;td&gt;&lt;strong&gt;base 32-63&lt;&#x2f;strong&gt; &lt;&#x2f;td&gt;&lt;td&gt;the last four bytes of the base address&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;96-127 &lt;&#x2f;td&gt;&lt;td&gt;ignored&#x2f;must be zero &lt;&#x2f;td&gt;&lt;td&gt;bits 104-108 must be zero, the rest is ignored&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;We only need the bold fields for our TSS descriptor. For example, we don&#x27;t need the &lt;code&gt;limit 16-19&lt;&#x2f;code&gt; field since a TSS has a fixed size that is smaller than &lt;code&gt;2^16&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add a function to our descriptor that creates a TSS descriptor for a given TSS:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::tss::TaskStateSegment;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Descriptor {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;tss_segment(tss: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; TaskStateSegment) -&amp;gt; Descriptor {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::mem::size_of;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bit_field::BitField;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; low &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.bits();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; base
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        low.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;40&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, ptr.get_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
        low.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;56&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, ptr.get_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; limit (the `-1` in needed since the bound is inclusive)
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        low.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, (size_of::&amp;lt;TaskStateSegment&amp;gt;() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; type (0b1001 = available 64-bit tss)
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        low.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;40&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;44&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b1001&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; high &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        high.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, ptr.get_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));

        Descriptor::SystemSegment(low, high)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;set_bits&lt;&#x2f;code&gt; and &lt;code&gt;get_bits&lt;&#x2f;code&gt; methods are provided by the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bit_field&#x2f;0.6.0&#x2f;bit_field&#x2f;trait.BitField.html#method.get_bit&quot;&gt;&lt;code&gt;BitField&lt;&#x2f;code&gt; trait&lt;&#x2f;a&gt; of the &lt;code&gt;bit_fields&lt;&#x2f;code&gt; crate. They allow us to easily get or set specific bits in an integer without using bit masks or shift operations. For example, we can do &lt;code&gt;x.set_bits(8..12, 42)&lt;&#x2f;code&gt; instead of &lt;code&gt;x = (x &amp;amp; 0xfffff0ff) | (42 &amp;lt;&amp;lt; 8)&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To link the &lt;code&gt;bit_fields&lt;&#x2f;code&gt; crate, we modify our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; and our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bit_field &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.7.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; bit_field;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We require the &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime for the &lt;code&gt;TaskStateSegment&lt;&#x2f;code&gt; reference, since the hardware might access it on every interrupt as long as the OS runs.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;adding-descriptors-to-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adding-descriptors-to-the-gdt&quot; aria-label=&quot;Anchor link for: adding-descriptors-to-the-gdt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Adding Descriptors to the GDT&lt;&#x2f;h4&gt;
&lt;p&gt;In order to add descriptors to the GDT, we add a &lt;code&gt;add_entry&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::PrivilegeLevel;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Gdt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;add_entry(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, entry: Descriptor) -&amp;gt; SegmentSelector {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry {
            Descriptor::UserSegment(value) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.push(value),
            Descriptor::SystemSegment(value_low, value_high) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.push(value_low);
                self.push(value_high);
                index
            }
        };
        SegmentSelector::new(index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, PrivilegeLevel::Ring0)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;For an user segment we just push the &lt;code&gt;u64&lt;&#x2f;code&gt; and remember the index. For a system segment, we push the low and high &lt;code&gt;u64&lt;&#x2f;code&gt; and use the index of the low value. We then use this index to return a new &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86&#x2f;0.8.0&#x2f;x86&#x2f;shared&#x2f;segmentation&#x2f;struct.SegmentSelector.html#method.new&quot;&gt;SegmentSelector&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;push&lt;&#x2f;code&gt; method looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Gdt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;push(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, value: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.table.len() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free;
            self.table[index] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; value;
            self.next_free &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            index
        } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;GDT full&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The method just writes to the &lt;code&gt;next_free&lt;&#x2f;code&gt; entry and returns the corresponding index. If there is no free entry left, we panic since this likely indicates a programming error (we should never need to create more than two or three GDT entries for our kernel).&lt;&#x2f;p&gt;
&lt;h4 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the GDT&lt;&#x2f;h4&gt;
&lt;p&gt;To load the GDT, we add a new &lt;code&gt;load&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;gdt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Gdt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tables::{DescriptorTablePointer, lgdt};
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::mem::size_of;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; DescriptorTablePointer {
            base: self.table.as_ptr() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            limit: (self.table.len() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;size_of::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        };

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ lgdt(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr) };
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;struct.DescriptorTablePointer.html&quot;&gt;&lt;code&gt;DescriptorTablePointer&lt;&#x2f;code&gt; struct&lt;&#x2f;a&gt; and the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.1&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;fn.lgdt.html&quot;&gt;&lt;code&gt;lgdt&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt; provided by the &lt;code&gt;x86_64&lt;&#x2f;code&gt; crate to load our GDT. Again, we require a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; reference since the GDT possibly needs to live for the rest of the run time.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Putting it together&lt;&#x2f;h3&gt;
&lt;p&gt;We now have a double fault stack and are able to create and load a TSS (which contains an IST). So let&#x27;s put everything together to catch kernel stack overflows.&lt;&#x2f;p&gt;
&lt;p&gt;We already created a new TSS in our &lt;code&gt;interrupts::init&lt;&#x2f;code&gt; function. Now we can load this TSS by creating a new GDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_controller: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; double_fault_stack &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller.alloc_stack(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TaskStateSegment::new();
    tss.interrupt_stack_table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; VirtualAddress(
        double_fault_stack.top());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt::Gdt::new();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; code_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::kernel_code_segment());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;tss));
    gdt.load();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, when we try to compile it, the following errors occur:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `tss` does not live long enough
   --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:118:68
    |
118 |    let tss_selector = gdt.add_entry(gdt::Descriptor::tss_segment(&amp;amp;tss));
    |                                         does not live long enough ^^^
...
122 | }
    | - borrowed value only lives until here
    |
    = note: borrowed value must be valid for the static lifetime...

error: `gdt` does not live long enough
   --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:119:5
    |
119 |    gdt.load();
    |    ^^^ does not live long enough
...
122 | }
    | - borrowed value only lives until here
    |
    = note: borrowed value must be valid for the static lifetime...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that we require that the TSS and GDT are valid for the rest of the run time (i.e. for the &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime). But our created &lt;code&gt;tss&lt;&#x2f;code&gt; and &lt;code&gt;gdt&lt;&#x2f;code&gt; live on the stack and are thus destroyed at the end of the &lt;code&gt;init&lt;&#x2f;code&gt; function. So how do we fix this problem?&lt;&#x2f;p&gt;
&lt;p&gt;We could allocate our TSS and GDT on the heap using &lt;code&gt;Box&lt;&#x2f;code&gt; and use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;boxed&#x2f;struct.Box.html#method.into_raw&quot;&gt;into_raw&lt;&#x2f;a&gt; and a bit of &lt;code&gt;unsafe&lt;&#x2f;code&gt; to convert it to &lt;code&gt;&amp;amp;&#x27;static&lt;&#x2f;code&gt; references (&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;1233&quot;&gt;RFC 1233&lt;&#x2f;a&gt; was closed unfortunately).&lt;&#x2f;p&gt;
&lt;p&gt;Alternatively, we could store them in a &lt;code&gt;static&lt;&#x2f;code&gt; somehow. The &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;lazy_static&#x2f;0.2.2&#x2f;lazy_static&#x2f;&quot;&gt;&lt;code&gt;lazy_static&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; doesn&#x27;t work here, since we need access to the &lt;code&gt;MemoryController&lt;&#x2f;code&gt; for initialization. However, we can use its fundamental building block, the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html&quot;&gt;&lt;code&gt;spin::Once&lt;&#x2f;code&gt; type&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;spin-once&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#spin-once&quot; aria-label=&quot;Anchor link for: spin-once&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
spin::Once&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s try to solve our problem using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html&quot;&gt;&lt;code&gt;spin::Once&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Once;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Once&amp;lt;TaskStateSegment&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Once::new();
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Once&amp;lt;gdt::Gdt&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Once::new();
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Once&lt;&#x2f;code&gt; type allows us to initialize a &lt;code&gt;static&lt;&#x2f;code&gt; at runtime. It is safe because the only way to access the static value is through the provided methods (&lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html#method.call_once&quot;&gt;call_once&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html#method.try&quot;&gt;try&lt;&#x2f;a&gt;, and &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Once.html#method.wait&quot;&gt;wait&lt;&#x2f;a&gt;). Thus, no value can be read before initialization and the value can only be initialized once.&lt;&#x2f;p&gt;
&lt;p&gt;(The &lt;code&gt;Once&lt;&#x2f;code&gt; was added in spin 0.4, so you&#x27;re probably need to update your spin dependency.)&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s rewrite our &lt;code&gt;interrupts::init&lt;&#x2f;code&gt; function to use the static &lt;code&gt;TSS&lt;&#x2f;code&gt; and &lt;code&gt;GDT&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_controller: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; double_fault_stack &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_controller.alloc_stack(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;could not allocate double fault stack&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;TSS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.call_once(|| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TaskStateSegment::new();
        tss.interrupt_stack_table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; VirtualAddress(
            double_fault_stack.top());
        tss
    });

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.call_once(|| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt::Gdt::new();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; code_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::
                            kernel_code_segment());
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;tss));
        gdt
    });
    gdt.load();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now it should compile again!&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-final-steps&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-final-steps&quot; aria-label=&quot;Anchor link for: the-final-steps&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The final Steps&lt;&#x2f;h4&gt;
&lt;p&gt;We&#x27;re almost done. We successfully loaded our new GDT, which contains a TSS descriptor. Now there are just a few steps left:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;We changed our GDT, so we should reload the &lt;code&gt;cs&lt;&#x2f;code&gt;, the code segment register. This required since the old segment selector could point a different GDT descriptor now (e.g. a TSS descriptor).&lt;&#x2f;li&gt;
&lt;li&gt;We loaded a GDT that contains a TSS selector, but we still need to tell the CPU that it should use that TSS.&lt;&#x2f;li&gt;
&lt;li&gt;As soon as our TSS is loaded, the CPU has access to a valid interrupt stack table (IST). Then we can tell the CPU that it should use our new double fault stack by modifying our double fault IDT entry.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;For the first two steps, we need access to the &lt;code&gt;code_selector&lt;&#x2f;code&gt; and &lt;code&gt;tss_selector&lt;&#x2f;code&gt; variables outside of the closure. We can achieve this by moving the &lt;code&gt;let&lt;&#x2f;code&gt; declarations out of the closure:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(memory_controller: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryController) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::gdt::SegmentSelector;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::segmentation::set_cs;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tables::load_tss;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; code_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; SegmentSelector(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; tss_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; SegmentSelector(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;GDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.call_once(|| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt::Gdt::new();
        code_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::kernel_code_segment());
        tss_selector &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; gdt.add_entry(gdt::Descriptor::tss_segment(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;tss));
        gdt
    });
    gdt.load();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; reload code segment register
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_cs(code_selector);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; load TSS
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load_tss(tss_selector);
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We first set the descriptors to &lt;code&gt;empty&lt;&#x2f;code&gt; and then update them from inside the closure (which implicitly borrows them as &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt;). Now we&#x27;re able to reload the code segment register using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.2&#x2f;x86_64&#x2f;instructions&#x2f;segmentation&#x2f;fn.set_cs.html&quot;&gt;&lt;code&gt;set_cs&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; and to load the TSS using &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.2&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;fn.load_tss.html&quot;&gt;&lt;code&gt;load_tss&lt;&#x2f;code&gt;&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now that we loaded a valid TSS and interrupt stack table, we can set the stack index for our double fault handler in the IDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupt&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
        unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            idt.double_fault.set_handler_fn(double_fault_handler)
                .set_stack_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;DOUBLE_FAULT_IST_INDEX &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        }
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;set_stack_index&lt;&#x2f;code&gt; method is unsafe because the the caller must ensure that the used index is valid and not already used for another exception.&lt;&#x2f;p&gt;
&lt;p&gt;That&#x27;s it! Now the CPU should switch to the double fault stack whenever a double fault occurs. Thus, we are able to catch &lt;em&gt;all&lt;&#x2f;em&gt; double faults, including kernel stack overflows:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;double-faults&#x2f;qemu-double-fault-on-stack-overflow.png&quot; alt=&quot;QEMU printing EXCEPTION: DOUBLE FAULT and a dump of the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;From now on we should never see a triple fault again!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we mastered exceptions, it&#x27;s time to explore another kind of interrupts: interrupts from external devices such as timers, keyboards, or network controllers. These hardware interrupts are very similar to exceptions, e.g. they are also dispatched through the IDT.&lt;&#x2f;p&gt;
&lt;p&gt;However, unlike exceptions, they don&#x27;t arise directly on the CPU. Instead, an &lt;em&gt;interrupt controller&lt;&#x2f;em&gt; aggregates these interrupts and forwards them to CPU depending on their priority. In the next posts we will explore the two interrupt controller variants on x86: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Intel_8259&quot;&gt;Intel 8259&lt;&#x2f;a&gt; (â€œPICâ€) and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Advanced_Programmable_Interrupt_Controller&quot;&gt;APIC&lt;&#x2f;a&gt;. This will allow us to react to keyboard and mouse input.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Returning from Exceptions</title>
                <pubDate>Wed, 21 Sep 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/returning-from-exceptions/</link>
                <guid>https://os.phil-opp.com/returning-from-exceptions/</guid>
                <description>&lt;p&gt;In this post, we learn how to return from exceptions correctly. In the course of this, we will explore the &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction, the C calling convention, multimedia registers, and the red zone.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;returning_from_exceptions&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2f;&#x2f;gitter.im&#x2f;phil-opp&#x2f;blog_os&quot;&gt;gitter chat&lt;&#x2f;a&gt; and a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2f;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;extra&#x2f;naked-exceptions&#x2f;&quot;&gt;â€œHandling Exceptions with Naked Functionsâ€&lt;&#x2f;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;â€œHandling Exceptionsâ€&lt;&#x2f;a&gt; post.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;Most exceptions are fatal and can&#x27;t be resolved. For example, we can&#x27;t return from a divide-by-zero exception in a reasonable way. However, there are some exceptions that we can resolve:&lt;&#x2f;p&gt;
&lt;p&gt;Imagine a system that uses &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Memory-mapped_file&quot;&gt;memory mapped files&lt;&#x2f;a&gt;: We map a file into the virtual address space without loading it into memory. Whenever we access a part of the file for the first time, a page fault occurs. However, this page fault is not fatal. We can resolve it by loading the corresponding page from disk into memory and setting the &lt;code&gt;present&lt;&#x2f;code&gt; flag in the page table. Then we can return from the page fault handler and restart the failed instruction, which now successfully accesses the file data.&lt;&#x2f;p&gt;
&lt;p&gt;Memory mapped files are completely out of scope for us right now (we have neither a file concept nor a hard disk driver). So we need an exception that we can resolve easily so that we can return from it in a reasonable way. Fortunately, there is an exception that needs no resolution at all: the breakpoint exception.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-breakpoint-exception&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-breakpoint-exception&quot; aria-label=&quot;Anchor link for: the-breakpoint-exception&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Breakpoint Exception&lt;&#x2f;h2&gt;
&lt;p&gt;The breakpoint exception is the perfect exception to test our upcoming return-from-exception logic. Its only purpose is to temporary pause a program when the breakpoint instruction &lt;code&gt;int3&lt;&#x2f;code&gt; is executed.&lt;&#x2f;p&gt;
&lt;p&gt;The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction with the original instruction again and continues the program. For more details, see the &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;01&#x2f;27&#x2f;how-debuggers-work-part-2-breakpoints&quot;&gt;How debuggers work&lt;&#x2f;a&gt; series.&lt;&#x2f;p&gt;
&lt;p&gt;For our use case, we don&#x27;t need to overwrite any instructions (it wouldn&#x27;t even be possible since we &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;#using-the-correct-flags&quot;&gt;set the page table flags&lt;&#x2f;a&gt; to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;catching-breakpoints&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#catching-breakpoints&quot; aria-label=&quot;Anchor link for: catching-breakpoints&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Catching Breakpoints&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s start by defining a handler function for the breakpoint exception:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;breakpoint_handler(stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_frame };
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: BREAKPOINT at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        stack_frame.instruction_pointer, stack_frame);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We print an error message and also output the instruction pointer and the rest of the stack frame. Note that this function does &lt;em&gt;not&lt;&#x2f;em&gt; return yet, since our &lt;code&gt;handler!&lt;&#x2f;code&gt; macro still requires a diverging function.&lt;&#x2f;p&gt;
&lt;p&gt;We need to register our new handler function in the interrupt descriptor table (IDT):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();

        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(divide_by_zero_handler));
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(breakpoint_handler)); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(invalid_opcode_handler));
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler_with_error_code!(page_fault_handler));

        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We set the IDT entry with number 3 since it&#x27;s the vector number of the breakpoint exception.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h4&gt;
&lt;p&gt;In order to test it, we insert an &lt;code&gt;int3&lt;&#x2f;code&gt; instruction in our &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; needed for the `int!` macro
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x86_64;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(...) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; trigger a breakpoint exception
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ int!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we execute &lt;code&gt;make run&lt;&#x2f;code&gt;, we see the following:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;qemu-breakpoint-handler.png&quot; alt=&quot;QEMU showing EXCEPTION: BREAKPOINT at 0x110970 and a dump of the exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It works! Now we â€œjustâ€ need to return from the breakpoint handler somehow so that we see the &lt;code&gt;It did not crash&lt;&#x2f;code&gt; message again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;returning-from-exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#returning-from-exceptions&quot; aria-label=&quot;Anchor link for: returning-from-exceptions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Returning from Exceptions&lt;&#x2f;h2&gt;
&lt;p&gt;So how do we return from exceptions? To make it easier, we look at a normal function return first:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;function-stack-frame.svg&quot; alt=&quot;function stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;When calling a function, the &lt;code&gt;call&lt;&#x2f;code&gt; instruction pushes the return address on the stack. When the called function is finished, it can return to the parent function through the &lt;code&gt;ret&lt;&#x2f;code&gt; instruction, which pops the return address from the stack and then jumps to it.&lt;&#x2f;p&gt;
&lt;p&gt;The exception stack frame, in contrast, looks a bit different:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Instead of pushing a return address, the CPU pushes the stack and instruction pointers (with their segment descriptors), the RFLAGS register, and an optional error code. It also aligns the stack pointer to a 16 byte boundary before pushing values.&lt;&#x2f;p&gt;
&lt;p&gt;So we can&#x27;t use a normal &lt;code&gt;ret&lt;&#x2f;code&gt; instruction, since it expects a different stack frame layout. Instead, there is a special instruction for returning from exceptions: &lt;code&gt;iretq&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-iretq-instruction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-iretq-instruction&quot; aria-label=&quot;Anchor link for: the-iretq-instruction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;iretq&lt;&#x2f;code&gt; Instruction&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction is the one and only way to return from exceptions and is specifically designed for this purpose. The AMD64 manual (&lt;a href=&quot;https:&#x2f;&#x2f;support.amd.com&#x2f;TechDocs&#x2f;24594.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) even demands that &lt;code&gt;iretq&lt;&#x2f;code&gt; â€œ&lt;em&gt;must&lt;&#x2f;em&gt; be used to terminate the exception or interrupt handler associated with the exceptionâ€.&lt;&#x2f;p&gt;
&lt;p&gt;IRETQ restores &lt;code&gt;rip&lt;&#x2f;code&gt;, &lt;code&gt;cs&lt;&#x2f;code&gt;, &lt;code&gt;rflags&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, and &lt;code&gt;ss&lt;&#x2f;code&gt; from the values saved on the stack and thus continues the interrupted program. The instruction does not handle the optional error code, so it must be popped from the stack before.&lt;&#x2f;p&gt;
&lt;p&gt;We see that &lt;code&gt;iretq&lt;&#x2f;code&gt; treats the stored instruction pointer as return address. For most exceptions, the stored &lt;code&gt;rip&lt;&#x2f;code&gt; points to the instruction that caused the fault. So by executing &lt;code&gt;iretq&lt;&#x2f;code&gt;, we restart the failing instruction. This makes sense because we should have resolved the exception when returning from it, so the instruction should no longer fail (e.g. the accessed part of the memory mapped file is now present in memory).&lt;&#x2f;p&gt;
&lt;p&gt;The situation is a bit different for the breakpoint exception, since it needs no resolution. Restarting the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction wouldn&#x27;t make sense, since it would cause a new breakpoint exception and we would enter an endless loop. For this reason the hardware designers decided that the stored &lt;code&gt;rip&lt;&#x2f;code&gt; should point to the next instruction after the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s check this for our breakpoint handler. Remember, the handler printed the following message (see the image above):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EXCEPTION: BREAKPOINT at 0x110970
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So let&#x27;s disassemble the instruction at &lt;code&gt;0x110970&lt;&#x2f;code&gt; and its predecessor:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep -B1 &amp;quot;110970:&amp;quot;
11096f:	cc                   	int3
110970:	48 c7 01 2a 00 00 00 	movq   $0x2a,(%rcx)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that &lt;code&gt;0x110970&lt;&#x2f;code&gt; indeed points to the next instruction after &lt;code&gt;int3&lt;&#x2f;code&gt;. So we can simply jump to the stored instruction pointer when we want to return from the breakpoint exception.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s update our &lt;code&gt;handler!&lt;&#x2f;code&gt; macro to support non-diverging exception handlers:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame)) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; no longer diverging
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;add rsp, 8 &#x2f;&#x2f; undo stack pointer alignment
                      iretq&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When an exception handler returns from the &lt;code&gt;call&lt;&#x2f;code&gt; instruction, we use the &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction to continue the interrupted program. Note that we need to undo the stack pointer alignment before, so that &lt;code&gt;rsp&lt;&#x2f;code&gt; points to the end of the exception stack frame again.&lt;&#x2f;p&gt;
&lt;p&gt;We&#x27;ve changed the handler function type, so we need to adjust our existing exception handlers:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

extern &amp;quot;C&amp;quot; fn divide_by_zero_handler(
-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {...}
+   stack_frame: &amp;amp;ExceptionStackFrame) {...}

extern &amp;quot;C&amp;quot; fn invalid_opcode_handler(
-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {...}
+   stack_frame: &amp;amp;ExceptionStackFrame) {...}

extern &amp;quot;C&amp;quot; fn breakpoint_handler(
-   stack_frame: &amp;amp;ExceptionStackFrame) -&amp;gt; ! {
+   stack_frame: &amp;amp;ExceptionStackFrame) {
    println!(...);
-   loop {}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we also removed the &lt;code&gt;loop {}&lt;&#x2f;code&gt; at the end of our &lt;code&gt;breakpoint_handler&lt;&#x2f;code&gt; so that it no longer diverges. The &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; and the &lt;code&gt;invalid_opcode_handler&lt;&#x2f;code&gt; still diverge (albeit the new function type would allow a return).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing&quot; aria-label=&quot;Anchor link for: testing&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s try our new &lt;code&gt;iretq&lt;&#x2f;code&gt; logic:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;qemu-breakpoint-return-page-fault.png&quot; alt=&quot;QEMU output with EXCEPTION BREAKPOINT and EXCEPTION PAGE FAULT but no It did not crash&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Instead of the expected &lt;em&gt;â€œIt did not crashâ€&lt;&#x2f;em&gt; message after the breakpoint exception, we get a page fault. The strange thing is that our kernel tried to access address &lt;code&gt;0x1&lt;&#x2f;code&gt;, which should never happen. So it seems like we messed up something important.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Debugging&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s debug it using GDB. For that we execute &lt;code&gt;make debug&lt;&#x2f;code&gt; in one terminal (which starts QEMU with the &lt;code&gt;-s -S&lt;&#x2f;code&gt; flags) and then &lt;code&gt;make gdb&lt;&#x2f;code&gt; (which starts and connects GDB) in a second terminal. For more information about GDB debugging, check out our &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-gdb&#x2f;&quot;&gt;Set Up GDB&lt;&#x2f;a&gt; guide.&lt;&#x2f;p&gt;
&lt;p&gt;First we want to check if our &lt;code&gt;iretq&lt;&#x2f;code&gt; was successful. Therefore we set a breakpoint on the &lt;code&gt;println!(&amp;quot;It did not crash line!&amp;quot;)&lt;&#x2f;code&gt; statement in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;. Let&#x27;s assume that it&#x27;s on line 61:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(gdb) break blog_os&#x2f;src&#x2f;lib.rs:61
Breakpoint 1 at 0x110a95: file &#x2f;home&#x2f;...&#x2f;blog_os&#x2f;src&#x2f;lib.rs, line 61.
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This line is after the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction, so we know that the &lt;code&gt;iretq&lt;&#x2f;code&gt; succeeded when the breakpoint is hit. To test this, we continue the execution:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(gdb) continue
Continuing.

Breakpoint 1, blog_os::rust_main (multiboot_information_address=1539136)
    at &#x2f;home&#x2f;...&#x2f;blog_os&#x2f;src&#x2f;lib.rs:61
61	    println!(&amp;quot;It did not crash!&amp;quot;);

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It worked! So our kernel successfully returned from the &lt;code&gt;int3&lt;&#x2f;code&gt; instruction, which means that the &lt;code&gt;iretq&lt;&#x2f;code&gt; itself works.&lt;&#x2f;p&gt;
&lt;p&gt;However, when we &lt;code&gt;continue&lt;&#x2f;code&gt; the execution again, we get the page fault. So the exception occurs somewhere in the &lt;code&gt;println&lt;&#x2f;code&gt; logic. This means that it occurs in code generated by the compiler (and not e.g. in inline assembly). But the compiler should never access &lt;code&gt;0x1&lt;&#x2f;code&gt;, so how is this happening?&lt;&#x2f;p&gt;
&lt;p&gt;The answer is that we&#x27;ve used the wrong &lt;em&gt;calling convention&lt;&#x2f;em&gt; for our exception handlers. Thus, we violate some compiler invariants so that the code that works fine without intermediate exceptions starts to violate memory safety when it&#x27;s executed after a breakpoint exception.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;calling-conventions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-conventions&quot; aria-label=&quot;Anchor link for: calling-conventions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Calling Conventions&lt;&#x2f;h2&gt;
&lt;p&gt;Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the (handler) function and executes the function. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.&lt;&#x2f;p&gt;
&lt;p&gt;However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted &lt;code&gt;call&lt;&#x2f;code&gt; instruction, while an exception might occur at &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;Calling conventions&lt;&#x2f;a&gt; specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt;):&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the first six integer arguments are passed in registers &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;additional arguments are passed on the stack&lt;&#x2f;li&gt;
&lt;li&gt;results are returned in &lt;code&gt;rax&lt;&#x2f;code&gt; and &lt;code&gt;rdx&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Note that Rust does not follow the C ABI (in fact, &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;issues&#x2f;600&quot;&gt;there isn&#x27;t even a Rust ABI yet&lt;&#x2f;a&gt;). So these rules apply only to functions declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;preserved-and-scratch-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preserved-and-scratch-registers&quot; aria-label=&quot;Anchor link for: preserved-and-scratch-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preserved and Scratch Registers&lt;&#x2f;h3&gt;
&lt;p&gt;The calling convention divides the registers in two parts: &lt;em&gt;preserved&lt;&#x2f;em&gt; and &lt;em&gt;scratch&lt;&#x2f;em&gt; registers.&lt;&#x2f;p&gt;
&lt;p&gt;The values of the preserved register must remain unchanged across function calls. So a called function (the &lt;em&gt;â€œcalleeâ€&lt;&#x2f;em&gt;) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called &lt;em&gt;â€œcallee-savedâ€&lt;&#x2f;em&gt;. A common pattern is to save these registers to the stack at the function&#x27;s beginning and restore them just before returning.&lt;&#x2f;p&gt;
&lt;p&gt;In contrast, a called function is allowed to overwrite scratch registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it (e.g. by pushing it to the stack before the function call). So the scratch registers are &lt;em&gt;caller-saved&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;On x86_64, the C calling convention specifies the following preserved and scratch registers:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;preserved registers &lt;&#x2f;th&gt;&lt;th&gt;scratch registers&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;rbp&lt;&#x2f;code&gt;, &lt;code&gt;rbx&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, &lt;code&gt;r12&lt;&#x2f;code&gt;, &lt;code&gt;r13&lt;&#x2f;code&gt;, &lt;code&gt;r14&lt;&#x2f;code&gt;, &lt;code&gt;r15&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;rax&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;, &lt;code&gt;r10&lt;&#x2f;code&gt;, &lt;code&gt;r11&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;callee-saved&lt;&#x2f;em&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;em&gt;caller-saved&lt;&#x2f;em&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a &lt;code&gt;push rbp&lt;&#x2f;code&gt;, which backups &lt;code&gt;rbp&lt;&#x2f;code&gt; on the stack (because it&#x27;s a callee-saved register).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-exception-calling-convention&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-exception-calling-convention&quot; aria-label=&quot;Anchor link for: the-exception-calling-convention&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Exception Calling Convention&lt;&#x2f;h3&gt;
&lt;p&gt;In contrast to function calls, exceptions can occur on &lt;em&gt;any&lt;&#x2f;em&gt; instruction. In most cases we don&#x27;t even know at compile time if the generated code will cause an exception. For example, the compiler can&#x27;t know if an instruction causes a stack overflow or an other page fault.&lt;&#x2f;p&gt;
&lt;p&gt;Since we don&#x27;t know when an exception occurs, we can&#x27;t backup any registers before. This means that we can&#x27;t use a calling convention that relies on caller-saved registers for our exception handlers. But we do so at the moment: Our exception handlers are declared as &lt;code&gt;extern &amp;quot;C&amp;quot; fn&lt;&#x2f;code&gt; and thus use the C calling convention.&lt;&#x2f;p&gt;
&lt;p&gt;So here is what happens:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rust_main&lt;&#x2f;code&gt; is executing; it writes some memory address into &lt;code&gt;rax&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;int3&lt;&#x2f;code&gt; instruction causes a breakpoint exception.&lt;&#x2f;li&gt;
&lt;li&gt;Our &lt;code&gt;breakpoint_handler&lt;&#x2f;code&gt; prints to the screen and assumes that it can overwrite &lt;code&gt;rax&lt;&#x2f;code&gt; freely (since it&#x27;s a scratch register). Somehow the value &lt;code&gt;0&lt;&#x2f;code&gt; ends up in &lt;code&gt;rax&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;We return from the breakpoint exception using &lt;code&gt;iretq&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;rust_main&lt;&#x2f;code&gt; continues and accesses the memory address in &lt;code&gt;rax&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU tries to access address &lt;code&gt;0x1&lt;&#x2f;code&gt;, which causes a page fault.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;So our exception handler erroneously assumes that the scratch registers were saved by the caller. But the caller (&lt;code&gt;rust_main&lt;&#x2f;code&gt;) couldn&#x27;t save any registers since it didn&#x27;t know that an exception occurs. So nobody saves &lt;code&gt;rax&lt;&#x2f;code&gt; and the other scratch registers, which leads to the page fault.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that we use a calling convention with caller-saved registers for our exception handlers. Instead, we need a calling convention means that preserves &lt;em&gt;all registers&lt;&#x2f;em&gt;. In other words, all registers must be callee-saved:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;all-registers-callee-saved&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;exception_handler() {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Unfortunately, Rust does not support such a calling convention. It was &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;pull&#x2f;1275&quot;&gt;proposed once&lt;&#x2f;a&gt;, but did not get accepted for various reasons. The primary reason was that such calling conventions can be simulated by writing a naked wrapper function.&lt;&#x2f;p&gt;
&lt;p&gt;(Remember: &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1201-naked-fns.md&quot;&gt;Naked functions&lt;&#x2f;a&gt; are functions without prologue and can contain only inline assembly. They were discussed in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;#naked-functions&quot;&gt;previous post&lt;&#x2f;a&gt;.)&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-naked-wrapper-function&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-naked-wrapper-function&quot; aria-label=&quot;Anchor link for: a-naked-wrapper-function&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A naked wrapper function&lt;&#x2f;h3&gt;
&lt;p&gt;Such a naked wrapper function might look like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;calling_convention_wrapper() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;
            push rax
            push rcx
            push rdx
            push rsi
            push rdi
            push r8
            push r9
            push r10
            push r11
            &#x2f;&#x2f; TODO: call exception handler with C calling convention
            pop r11
            pop r10
            pop r9
            pop r8
            pop rdi
            pop rsi
            pop rdx
            pop rcx
            pop rax
        &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This wrapper function saves all &lt;em&gt;scratch&lt;&#x2f;em&gt; registers to the stack before calling the exception handler and restores them afterwards. Note that we &lt;code&gt;pop&lt;&#x2f;code&gt; the registers in reverse order.&lt;&#x2f;p&gt;
&lt;p&gt;We don&#x27;t need to backup &lt;em&gt;preserved&lt;&#x2f;em&gt; registers since they are callee-saved in the C calling convention. Thus, the compiler already takes care of preserving their values.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-our-handler-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-our-handler-macro&quot; aria-label=&quot;Anchor link for: fixing-our-handler-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing our Handler Macro&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s update our handler macro to fix the calling convention problem. Therefore we need to backup and restore all scratch registers. For that we create two new macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! save_scratch_registers {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;push rax
              push rcx
              push rdx
              push rsi
              push rdi
              push r8
              push r9
              push r10
              push r11
        &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}

macro_rules! restore_scratch_registers {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop r11
              pop r10
              pop r9
              pop r8
              pop rdi
              pop rsi
              pop rdx
              pop rcx
              pop rax
            &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need to declare these macros &lt;em&gt;above&lt;&#x2f;em&gt; our &lt;code&gt;handler&lt;&#x2f;code&gt; macro, since macros are only available after their declaration.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use these macros to fix our &lt;code&gt;handler!&lt;&#x2f;code&gt; macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                save_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
                      add rdi, 9*8 &#x2f;&#x2f; calculate exception stack frame pointer
                      &#x2f;&#x2f; sub rsp, 8 (stack is aligned already)
                      call $0&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as
                             extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame))
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

                restore_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;
                      &#x2f;&#x2f; add rsp, 8 (undo stack alignment; not needed anymore)
                      iretq&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s important that we save the registers first, before we modify any of them. After the &lt;code&gt;call&lt;&#x2f;code&gt; instruction (but before &lt;code&gt;iretq&lt;&#x2f;code&gt;) we restore the registers again. Because we&#x27;re now changing &lt;code&gt;rsp&lt;&#x2f;code&gt; (by pushing the register values) before we load it into &lt;code&gt;rdi&lt;&#x2f;code&gt;, we would get a wrong exception stack frame pointer. Therefore we need to adjust it by adding the number of bytes we push. We push 9 registers that are 8 bytes each, so &lt;code&gt;9 * 8&lt;&#x2f;code&gt; bytes in total.&lt;&#x2f;p&gt;
&lt;p&gt;Note that we no longer need to manually align the stack pointer, because we&#x27;re pushing an uneven number of registers in &lt;code&gt;save_scratch_registers&lt;&#x2f;code&gt;. Thus the stack pointer already has the required 16-byte alignment.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-it-again&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it-again&quot; aria-label=&quot;Anchor link for: testing-it-again&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it again&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s test it again with our corrected &lt;code&gt;handler!&lt;&#x2f;code&gt; macro:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;qemu-breakpoint-return.png&quot; alt=&quot;QEMU output with EXCEPTION BREAKPOINT and It did not crash&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The page fault is gone and we see the &lt;em&gt;â€œIt did not crashâ€&lt;&#x2f;em&gt; message again!&lt;&#x2f;p&gt;
&lt;p&gt;So the page fault occurred because our exception handler didn&#x27;t preserve the scratch register &lt;code&gt;rax&lt;&#x2f;code&gt;. Our new &lt;code&gt;handler!&lt;&#x2f;code&gt; macro fixes this problem by saving all scratch registers (including &lt;code&gt;rax&lt;&#x2f;code&gt;) before calling exception handlers. Thus, &lt;code&gt;rax&lt;&#x2f;code&gt; still contains the valid memory address when &lt;code&gt;rust-main&lt;&#x2f;code&gt; continues execution.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;multimedia-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multimedia-registers&quot; aria-label=&quot;Anchor link for: multimedia-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Multimedia Registers&lt;&#x2f;h2&gt;
&lt;p&gt;When we discussed calling conventions above, we assummed that a x86_64 CPU only has the following 16 registers: &lt;code&gt;rax&lt;&#x2f;code&gt;, &lt;code&gt;rbx&lt;&#x2f;code&gt;, &lt;code&gt;rcx&lt;&#x2f;code&gt;, &lt;code&gt;rdx&lt;&#x2f;code&gt;, &lt;code&gt;rsi&lt;&#x2f;code&gt;, &lt;code&gt;rdi&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, &lt;code&gt;rbp&lt;&#x2f;code&gt;, &lt;code&gt;r8&lt;&#x2f;code&gt;, &lt;code&gt;r9&lt;&#x2f;code&gt;, &lt;code&gt;r10&lt;&#x2f;code&gt;, &lt;code&gt;r11&lt;&#x2f;code&gt;.&lt;code&gt;r12&lt;&#x2f;code&gt;, &lt;code&gt;r13&lt;&#x2f;code&gt;, &lt;code&gt;r14&lt;&#x2f;code&gt;, and &lt;code&gt;r15&lt;&#x2f;code&gt;. These registers are called &lt;em&gt;general purpose registers&lt;&#x2f;em&gt; since each of them can be used for arithmetic and load&#x2f;store instructions.&lt;&#x2f;p&gt;
&lt;p&gt;However, modern CPUs also have a set of &lt;em&gt;special purpose registers&lt;&#x2f;em&gt;, which can be used to improve performance in several use cases. On x86_64, the most important set of special purpose registers are the &lt;em&gt;multimedia registers&lt;&#x2f;em&gt;. These registers are larger than the general purpose registers and can be used to speed up audio&#x2f;video processing or matrix calculations. For example, we could use them to add two 4-dimensional vectors &lt;em&gt;in a single CPU instruction&lt;&#x2f;em&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;vector-addition.png&quot; alt=&quot;(1,2,3,4) + (5,6,7,8) = (6,8,10,12)&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Such multimedia instructions are called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2f;a&gt; instructions, because they simultaneously perform an operation (e.g. addition) on multiple data words. Good compilers are able to transform normal loops into such SIMD code automatically. This process is called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Automatic_vectorization&quot;&gt;auto-vectorization&lt;&#x2f;a&gt; and can lead to huge performance improvements.&lt;&#x2f;p&gt;
&lt;p&gt;However, auto-vectorization causes a problem for us: Most of the multimedia registers are caller-saved. According to our discussion of calling conventions above, this means that our exception handlers erroneously assume that they are allowed to overwrite them without preserving their values.&lt;&#x2f;p&gt;
&lt;p&gt;We don&#x27;t use any multimedia registers explicitly, but the Rust compiler might auto-vectorize our code (including the exception handlers). Thus we could silently clobber the multimedia registers, which leads to the same problems as above:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;xmm-overwrite.svg&quot; alt=&quot;example: program uses mm0, mm1, and mm2. Then the exception handler clobbers mm1.&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This example shows a program that is using the first three multimedia registers (&lt;code&gt;mm0&lt;&#x2f;code&gt; to &lt;code&gt;mm2&lt;&#x2f;code&gt;). At some point, an exception occurs and control is transferred to the exception handler. The exception handler uses &lt;code&gt;mm1&lt;&#x2f;code&gt; for its own data and thus overwrites the previous value. When the exception is resolved, the CPU continues the interrupted program again. However, the program is now corrupt since it relies on the original &lt;code&gt;mm1&lt;&#x2f;code&gt; value.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;saving-and-restoring-multimedia-registers&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#saving-and-restoring-multimedia-registers&quot; aria-label=&quot;Anchor link for: saving-and-restoring-multimedia-registers&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Saving and Restoring Multimedia Registers&lt;&#x2f;h3&gt;
&lt;p&gt;In order to fix this problem, we need to backup all caller-saved multimedia registers before we call the exception handler. The problem is that the set of multimedia registers varies between CPUs. There are different standards:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;MMX_(instruction_set)&quot;&gt;MMX&lt;&#x2f;a&gt;: The MMX instruction set was introduced in 1997 and defines eight 64 bit registers called &lt;code&gt;mm0&lt;&#x2f;code&gt; through &lt;code&gt;mm7&lt;&#x2f;code&gt;. These registers are just aliases for the registers of the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X87&quot;&gt;x87 floating point unit&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2f;a&gt;: The &lt;em&gt;Streaming SIMD Extensions&lt;&#x2f;em&gt; instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called &lt;code&gt;xmm0&lt;&#x2f;code&gt; through &lt;code&gt;xmm15&lt;&#x2f;code&gt; and are 128 bits each.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Advanced_Vector_Extensions&quot;&gt;AVX&lt;&#x2f;a&gt;: The &lt;em&gt;Advanced Vector Extensions&lt;&#x2f;em&gt; are extensions that further increase the size of the multimedia registers. The new registers are called &lt;code&gt;ymm0&lt;&#x2f;code&gt; through &lt;code&gt;ymm15&lt;&#x2f;code&gt; and are 256 bits each. They extend the &lt;code&gt;xmm&lt;&#x2f;code&gt; registers, so e.g. &lt;code&gt;xmm0&lt;&#x2f;code&gt; is the lower (or upper?) half of &lt;code&gt;ymm0&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;The Rust compiler (and LLVM) assume that the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target supports only MMX and SSE, so we don&#x27;t need to save the &lt;code&gt;ymm0&lt;&#x2f;code&gt; through &lt;code&gt;ymm15&lt;&#x2f;code&gt;. But we need to save &lt;code&gt;xmm0&lt;&#x2f;code&gt; through &lt;code&gt;xmm15&lt;&#x2f;code&gt; and also &lt;code&gt;mm0&lt;&#x2f;code&gt; through &lt;code&gt;mm7&lt;&#x2f;code&gt;. There is a special instruction to do this: &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;fxsave&quot;&gt;fxsave&lt;&#x2f;a&gt;. This instruction saves the floating point and multimedia state to a given address. It needs &lt;em&gt;512 bytes&lt;&#x2f;em&gt; to store that state.&lt;&#x2f;p&gt;
&lt;p&gt;In order to save&#x2f;restore the multimedia registers, we &lt;em&gt;could&lt;&#x2f;em&gt; add new macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! save_multimedia_registers {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;sub rsp, 512
              fxsave [rsp]
        &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}

macro_rules! restore_multimedia_registers {
    () &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;fxrstor [rsp]
              add rsp, 512
            &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we reserve the 512 bytes on the stack and then we use &lt;code&gt;fxsave&lt;&#x2f;code&gt; to backup the multimedia registers. In order to restore them later, we use the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;fxrstor&quot;&gt;fxrstor&lt;&#x2f;a&gt; instruction. Note that &lt;code&gt;fxsave&lt;&#x2f;code&gt; and &lt;code&gt;fxrstor&lt;&#x2f;code&gt; require a 16 byte aligned memory address.&lt;&#x2f;p&gt;
&lt;p&gt;However, &lt;em&gt;we won&#x27;t do it that way&lt;&#x2f;em&gt;. The problem is the large amount of memory required. We will reuse the same code when we handle hardware interrupts in a future post. So for each mouse click, pressed key, or arrived network package we need to write 512 bytes to memory. This would be a huge performance problem.&lt;&#x2f;p&gt;
&lt;p&gt;Fortunately, there exists an alternative solution.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;disabling-multimedia-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-multimedia-extensions&quot; aria-label=&quot;Anchor link for: disabling-multimedia-extensions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Disabling Multimedia Extensions&lt;&#x2f;h3&gt;
&lt;p&gt;We just disable MMX, SSE, and all the other fancy multimedia extensions in our kernel&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-userspace-sse&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;. This way, our exception handlers won&#x27;t clobber the multimedia registers because they won&#x27;t use them at all.&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-userspace-sse&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;Userspace programs will still be able to use the multimedia registers.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;p&gt;This solution has its own disadvantages, of course. For example, it leads to slower kernel code because the compiler can&#x27;t perform any auto-vectorization optimizations. But it&#x27;s still the faster solution (since we save many memory accesses) and most kernels do it this way (including Linux).&lt;&#x2f;p&gt;
&lt;p&gt;So how do we disable MMX and SSE? Well, we just tell the compiler that our target system doesn&#x27;t support it. Since the very beginning, we&#x27;re compiling our kernel for the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target. This worked fine so far, but now we want a different target without support for multimedia extensions. We can do so by creating a &lt;em&gt;target configuration file&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;target-specifications&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specifications&quot; aria-label=&quot;Anchor link for: target-specifications&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Target Specifications&lt;&#x2f;h3&gt;
&lt;p&gt;In order to disable the multimedia extensions for our kernel, we need to compile for a custom target. We want a target that is equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt;, but without MMX and SSE support. Rust allows us to specify such a target using a JSON configuration file.&lt;&#x2f;p&gt;
&lt;p&gt;A minimal target specification that describes the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;llvm-target&lt;&#x2f;code&gt; field specifies the target triple that is passed to LLVM. We want to derive a 64-bit Linux target, so we choose &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt;. The &lt;code&gt;data-layout&lt;&#x2f;code&gt; field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications separated by a &lt;code&gt;-&lt;&#x2f;code&gt; character. For example, the &lt;code&gt;e&lt;&#x2f;code&gt; means little endian and &lt;code&gt;S128&lt;&#x2f;code&gt; specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the &lt;a href=&quot;http:&#x2f;&#x2f;llvm.org&#x2f;docs&#x2f;LangRef.html#data-layout&quot;&gt;LLVM documentation&lt;&#x2f;a&gt; but there shouldn&#x27;t be a reason to change this string.&lt;&#x2f;p&gt;
&lt;p&gt;The other fields are used for conditional compilation. This allows crate authors to use &lt;code&gt;cfg&lt;&#x2f;code&gt; variables to write special code for depending on the OS or the architecture. There isn&#x27;t any up-to-date documentation about these fields but the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;c772948b687488a087356cb91432425662e034b9&#x2f;src&#x2f;librustc_back&#x2f;target&#x2f;mod.rs#L194-L214&quot;&gt;corresponding source code&lt;&#x2f;a&gt; is quite readable.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;disabling-mmx-and-sse&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-mmx-and-sse&quot; aria-label=&quot;Anchor link for: disabling-mmx-and-sse&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Disabling MMX and SSE&lt;&#x2f;h4&gt;
&lt;p&gt;In order to disable the multimedia extensions, we create a new target named &lt;code&gt;x86_64-blog_os&lt;&#x2f;code&gt;. To describe this target, we create a file named &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; in the project root with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target but has one additional option: &lt;code&gt;&amp;quot;features&amp;quot;: &amp;quot;-mmx,-sse&amp;quot;&lt;&#x2f;code&gt;. So we added two target &lt;em&gt;features&lt;&#x2f;em&gt;: &lt;code&gt;-mmx&lt;&#x2f;code&gt; and &lt;code&gt;-sse&lt;&#x2f;code&gt;. The minus prefix defines that our target does &lt;em&gt;not&lt;&#x2f;em&gt; support this feature. So by specifying &lt;code&gt;-mmx&lt;&#x2f;code&gt; and &lt;code&gt;-sse&lt;&#x2f;code&gt;, we disable the default &lt;code&gt;mmx&lt;&#x2f;code&gt; and &lt;code&gt;sse&lt;&#x2f;code&gt; features.&lt;&#x2f;p&gt;
&lt;p&gt;In order to compile for the new target, we need to adjust our Makefile:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;# in `Makefile`

 arch ?= x86_64
-target ?= $(arch)-unknown-linux-gnu
+target ?= $(arch)-blog_os
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The new target name (&lt;code&gt;x86_64-blog_os&lt;&#x2f;code&gt;) is the file name of the JSON configuration file without the &lt;code&gt;.json&lt;&#x2f;code&gt; extension.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;cross-compilation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cross-compilation&quot; aria-label=&quot;Anchor link for: cross-compilation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Cross compilation&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s try if our kernel still works with the new target:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; make run
Compiling raw-cpuid v2.0.1
Compiling rlibc v0.1.5
Compiling x86 v0.7.1
Compiling spin v0.3.5
error[E0463]: can&amp;#39;t find crate for `core`

error: aborting due to previous error

Build failed, waiting for other jobs to finish...
...
Makefile:52: recipe for target &amp;#39;cargo&amp;#39; failed
make: *** [cargo] Error 101
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It doesn&#x27;t compile anymore. The error tells us that the Rust compiler no longer finds the core library.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;index.html&quot;&gt;core library&lt;&#x2f;a&gt; is implicitly linked to all &lt;code&gt;no_std&lt;&#x2f;code&gt; crates and contains things such as &lt;code&gt;Result&lt;&#x2f;code&gt;, &lt;code&gt;Option&lt;&#x2f;code&gt;, and iterators. We&#x27;ve used that library without problems since &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;&quot;&gt;the very beginning&lt;&#x2f;a&gt;, so why is it no longer available?&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2f;em&gt; library. So it is only valid for the host triple, which is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; in our case. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2f;code&gt; for these targets first.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;xargo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#xargo&quot; aria-label=&quot;Anchor link for: xargo&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Xargo&lt;&#x2f;h4&gt;
&lt;p&gt;That&#x27;s where &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;japaric&#x2f;xargo&quot;&gt;xargo&lt;&#x2f;a&gt; comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo install xargo
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Xargo depends on the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Xargo is â€œa drop-in replacement for cargoâ€, so every cargo command also works with &lt;code&gt;xargo&lt;&#x2f;code&gt;. You can do e.g. &lt;code&gt;xargo --help&lt;&#x2f;code&gt;, &lt;code&gt;xargo clean&lt;&#x2f;code&gt;, or &lt;code&gt;xargo doc&lt;&#x2f;code&gt;. However, the &lt;code&gt;build&lt;&#x2f;code&gt; command gains additional functionality: &lt;code&gt;xargo build&lt;&#x2f;code&gt; will automatically cross compile the &lt;code&gt;core&lt;&#x2f;code&gt; library when compiling for custom targets.&lt;&#x2f;p&gt;
&lt;p&gt;That&#x27;s exactly what we want, so we change one letter in our Makefile:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;# in `Makefile`
...

cargo:
-	@cargo build --target $(target)
+	@xargo build --target $(target)
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the build goes through &lt;code&gt;xargo&lt;&#x2f;code&gt;, which should fix the compilation error. Let&#x27;s try it out:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; make run
Compiling core v0.0.0 (file:&#x2f;&#x2f;&#x2f;home&#x2f;â€¦&#x2f;.rustup&#x2f;toolchains&#x2f;nightly-x86_64-unknown-linux-gnu&#x2f;lib&#x2f;rustlib&#x2f;src&#x2f;rust&#x2f;src&#x2f;libcore)
LLVM ERROR: SSE register return with SSE disabled
error: Could not compile `core`.
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Well, we get a different error now, so it seems like we&#x27;re making progress :). It seems like there is a â€œSSE register returnâ€ although SSE is disabled. But what&#x27;s an â€œSSE register returnâ€?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;sse-register-return&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#sse-register-return&quot; aria-label=&quot;Anchor link for: sse-register-return&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
SSE Register Return&lt;&#x2f;h3&gt;
&lt;p&gt;Remember when we discussed calling conventions above? The calling convention defines which registers are used for return values. Well, the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt; defines that &lt;code&gt;xmm0&lt;&#x2f;code&gt; should be used for returning floating point values. So somewhere in the &lt;code&gt;core&lt;&#x2f;code&gt; library a function returns a float and LLVM doesn&#x27;t know what to do. The ABI says â€œuse &lt;code&gt;xmm0&lt;&#x2f;code&gt;â€ but the target specification says â€œdon&#x27;t use &lt;code&gt;xmm&lt;&#x2f;code&gt; registersâ€.&lt;&#x2f;p&gt;
&lt;p&gt;In order to fix this problem, we need to change our float ABI. The idea is to avoid normal hardware-supported floats and use a pure software implementation instead. We can do so by enabling the &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature for our target. For that, we edit &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The plus prefix tells LLVM to enable the &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s try &lt;code&gt;make run&lt;&#x2f;code&gt; again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; make run
   Compiling core v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;.rustup&#x2f;toolchains&#x2f;nightly-x86_64-unknown-linux-gnu&#x2f;lib&#x2f;rustlib&#x2f;src&#x2f;rust&#x2f;src&#x2f;libcore)
    Finished release [optimized] target(s) in 21.95 secs
   Compiling spin v0.4.5
   Compiling once v0.3.2
   Compiling x86 v0.8.0
   Compiling bitflags v0.9.1
   Compiling raw-cpuid v2.0.1
   Compiling rlibc v0.1.5
   Compiling linked_list_allocator v0.2.3
   Compiling volatile v0.1.0
   Compiling bitflags v0.4.0
   Compiling bit_field v0.5.0
   Compiling spin v0.3.5
   Compiling multiboot2 v0.1.0
   Compiling lazy_static v0.2.2
   Compiling hole_list_allocator v0.1.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;libs&#x2f;hole_list_allocator)
   Compiling blog_os v0.1.0 (file:&#x2f;&#x2f;&#x2f;â€¦)
error[E0463]: can&amp;#39;t find crate for `alloc`
  --&amp;gt; src&#x2f;lib.rs:33:1
   |
33 | extern crate alloc;
   | ^^^^^^^^^^^^^^^^^^^ can&amp;#39;t find crate

error: aborting due to previous error
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that &lt;code&gt;xargo&lt;&#x2f;code&gt; now compiles the &lt;code&gt;core&lt;&#x2f;code&gt; crate in release mode. Then it starts the normal cargo build. Cargo then recompiles all dependencies, since it needs to generate different code for the new target.&lt;&#x2f;p&gt;
&lt;p&gt;However, the build still fails. The reason is that xargo only installs &lt;code&gt;core&lt;&#x2f;code&gt; by default, but we also need the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate. We can enable it by creating a file named &lt;code&gt;Xargo.toml&lt;&#x2f;code&gt; with the following contents:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# Xargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.x86_64-blog_os.dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= {}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now xargo compiles &lt;code&gt;alloc&lt;&#x2f;code&gt;, too:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; make run
   Compiling core v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;.rustup&#x2f;toolchains&#x2f;nightly-x86_64-unknown-linux-gnu&#x2f;lib&#x2f;rustlib&#x2f;src&#x2f;rust&#x2f;src&#x2f;libcore)
   Compiling std_unicode v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;.rustup&#x2f;toolchains&#x2f;nightly-x86_64-unknown-linux-gnu&#x2f;lib&#x2f;rustlib&#x2f;src&#x2f;rust&#x2f;src&#x2f;libstd_unicode)
   Compiling alloc v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;.rustup&#x2f;toolchains&#x2f;nightly-x86_64-unknown-linux-gnu&#x2f;lib&#x2f;rustlib&#x2f;src&#x2f;rust&#x2f;src&#x2f;liballoc)
    Finished release [optimized] target(s) in 28.84 secs
   Compiling blog_os v0.1.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;Documents&#x2f;blog_os&#x2f;master)
warning: unused variable: `allocator` [â€¦]
warning: unused variable: `frame` [â€¦]

    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It worked! Now we have a kernel that never touches the multimedia registers! We can verify this by executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep &amp;quot;mm[0-9]&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If the command produces no output, our kernel uses neither MMX (&lt;code&gt;mm0&lt;&#x2f;code&gt; â€“ &lt;code&gt;mm7&lt;&#x2f;code&gt;) nor SSE (&lt;code&gt;xmm0&lt;&#x2f;code&gt; â€“ &lt;code&gt;xmm15&lt;&#x2f;code&gt;) registers.&lt;&#x2f;p&gt;
&lt;p&gt;So now our return-from-exception logic works without problems in &lt;em&gt;most&lt;&#x2f;em&gt; cases. However, there is still a pitfall hidden in the C calling convention, which might cause hideous bugs in some rare cases.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-red-zone&quot; aria-label=&quot;Anchor link for: the-red-zone&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Red Zone&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;09&#x2f;06&#x2f;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2f;a&gt; is an optimization of the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt; that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;red-zone.svg&quot; alt=&quot;stack frame with red zone&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The image shows the stack frame of a function with &lt;code&gt;n&lt;&#x2f;code&gt; local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.&lt;&#x2f;p&gt;
&lt;p&gt;The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that&#x27;s not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).&lt;&#x2f;p&gt;
&lt;p&gt;However, this optimization leads to huge problems with exceptions. Let&#x27;s assume that an exception occurs while a function uses the red zone:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;red-zone-overwrite.svg&quot; alt=&quot;red zone overwritten by exception handler&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won&#x27;t work correctly anymore when we return from the exception handler. It might fail or cause another exception, but it could also lead to strange bugs that &lt;a href=&quot;http:&#x2f;&#x2f;forum.osdev.org&#x2f;viewtopic.php?t=21720&quot;&gt;take weeks to debug&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;adjusting-our-exception-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adjusting-our-exception-handler&quot; aria-label=&quot;Anchor link for: adjusting-our-exception-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Adjusting our Exception Handler?&lt;&#x2f;h3&gt;
&lt;p&gt;The problem is that the &lt;a href=&quot;http:&#x2f;&#x2f;refspecs.linuxbase.org&#x2f;elf&#x2f;gabi41.pdf&quot;&gt;System V ABI&lt;&#x2f;a&gt; demands that the red zone &lt;em&gt;â€œshall not be modified by signal or interrupt handlers.â€&lt;&#x2f;em&gt; Our current exception handlers do not respect this. We could try to fix it by subtracting 128 from the stack pointer before pushing anything:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;sub &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rsp, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;128
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;save_scratch_registers()
...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
...
restore_scratch_registers()
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;add &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rsp, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;128

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;iretq
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;em&gt;This will not work.&lt;&#x2f;em&gt; The problem is that the CPU pushes the exception stack frame before even calling our handler function. So the CPU itself will clobber the red zone and there is nothing we can do about that. So our only chance is to disable the red zone.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;disabling-the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#disabling-the-red-zone&quot; aria-label=&quot;Anchor link for: disabling-the-red-zone&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Disabling the Red Zone&lt;&#x2f;h3&gt;
&lt;p&gt;The red zone is a property of our target, so in order to disable it we edit our &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; a last time:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;...
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add one additional option at the end: &lt;code&gt;&amp;quot;disable-redzone&amp;quot;: true&lt;&#x2f;code&gt;. As you might guess, this option disables the red zone optimization.&lt;&#x2f;p&gt;
&lt;p&gt;Now we have a red zone free kernel!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;exceptions-with-error-codes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-with-error-codes&quot; aria-label=&quot;Anchor link for: exceptions-with-error-codes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exceptions with Error Codes&lt;&#x2f;h2&gt;
&lt;p&gt;We&#x27;re now able to correctly return from exceptions without error codes. However, we still can&#x27;t return from exceptions that push an error code (e.g. page faults). Let&#x27;s fix that by updating our &lt;code&gt;handler_with_error_code&lt;&#x2f;code&gt; macro:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler_with_error_code {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2f;&#x2f; pop error code into rsi
                      mov rdi, rsp
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;iretq&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we change the type of the handler function: no more &lt;code&gt;-&amp;gt; !&lt;&#x2f;code&gt;, so it no longer needs to diverge. We also add an &lt;code&gt;iretq&lt;&#x2f;code&gt; instruction at the end.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can make our &lt;code&gt;page_fault_handler&lt;&#x2f;code&gt; non-diverging:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

 extern &amp;quot;C&amp;quot; fn page_fault_handler(stack_frame: &amp;amp;ExceptionStackFrame,
-   error_code: u64) -&amp;gt; ! { ... }
+   error_code: u64) { ... }
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, now we have the same problem as above: The handler function will overwrite the scratch registers and cause bugs when returning. Let&#x27;s fix this by invoking &lt;code&gt;save_scratch_registers&lt;&#x2f;code&gt; at the beginning:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler_with_error_code {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                save_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2f;&#x2f; pop error code into rsi
                      mov rdi, rsp
                      add rdi, 10*8 &#x2f;&#x2f; calculate exception stack frame pointer
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0
                      add rsp, 8 &#x2f;&#x2f; undo stack pointer alignment
                      &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                restore_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;iretq&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we backup the scratch registers to the stack right at the beginning and restore them just before the &lt;code&gt;iretq&lt;&#x2f;code&gt;. Like in the &lt;code&gt;handler&lt;&#x2f;code&gt; macro, we now need to add &lt;code&gt;10*8&lt;&#x2f;code&gt; to &lt;code&gt;rdi&lt;&#x2f;code&gt; in order to get the correct exception stack frame pointer (&lt;code&gt;save_scratch_registers&lt;&#x2f;code&gt; pushes nine 8 byte registers, plus the error code). We also need to undo the stack pointer alignment after the &lt;code&gt;call&lt;&#x2f;code&gt; &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-stack-alignment&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;.&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-stack-alignment&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;The stack alignment is actually wrong here, since we additionally pushed an uneven number of registers. However, the &lt;code&gt;pop rsi&lt;&#x2f;code&gt; is wrong too, since the error code is no longer at the top of the stack. When we fix that problem, the stack alignment becomes correct again. So I left it in to keep things simple.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;p&gt;Now we have one last bug: We &lt;code&gt;pop&lt;&#x2f;code&gt; the error code into &lt;code&gt;rsi&lt;&#x2f;code&gt;, but the error code is no longer at the top of the stack (since &lt;code&gt;save_scratch_registers&lt;&#x2f;code&gt; pushed 9 registers on top of it). So we need to do it differently:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler_with_error_code {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                save_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rsi, [rsp + 9*8] &#x2f;&#x2f; load error code into rsi
                      mov rdi, rsp
                      add rdi, 10*8 &#x2f;&#x2f; calculate exception stack frame pointer
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0
                      add rsp, 8 &#x2f;&#x2f; undo stack pointer alignment
                      &amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                restore_scratch_registers!();
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;add rsp, 8 &#x2f;&#x2f; pop error code
                      iretq&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;pop&lt;&#x2f;code&gt;, we&#x27;re calculating the error code address manually (&lt;code&gt;save_scratch_registers&lt;&#x2f;code&gt; pushes nine 8 byte registers) and load it into &lt;code&gt;rsi&lt;&#x2f;code&gt; using a &lt;code&gt;mov&lt;&#x2f;code&gt;. So now the error code stays on the stack. But &lt;code&gt;iretq&lt;&#x2f;code&gt; doesn&#x27;t handle the error code, so we need to pop it before invoking &lt;code&gt;iretq&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Phew! That was a lot of fiddling with assembly. Let&#x27;s test if it still works.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-1&quot; aria-label=&quot;Anchor link for: testing-1&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing&lt;&#x2f;h3&gt;
&lt;p&gt;First, we test if the exception stack frame pointer and the error code are still correct:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ int!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; provoke a page fault
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; }

println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This should cause the following error message:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EXCEPTION: PAGE FAULT while accessing 0xdeadbeaf
error code: CAUSED_BY_WRITE
ExceptionStackFrame {
    instruction_pointer: 1114753,
    code_segment: 8,
    cpu_flags: 2097158,
    stack_pointer: 1171104,
    stack_segment: 16
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The error code should still be &lt;code&gt;CAUSED_BY_WRITE&lt;&#x2f;code&gt; and the exception stack frame values should also be correct (e.g. &lt;code&gt;code_segment&lt;&#x2f;code&gt; should be 8 and &lt;code&gt;stack_segment&lt;&#x2f;code&gt; should be 16).&lt;&#x2f;p&gt;
&lt;h4 id=&quot;returning-from-page-faults&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#returning-from-page-faults&quot; aria-label=&quot;Anchor link for: returning-from-page-faults&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Returning from Page Faults&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s see what happens if we comment out the trailing &lt;code&gt;loop&lt;&#x2f;code&gt; in our page fault handler:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;qemu-page-fault-return.png&quot; alt=&quot;QEMU printing the same page fault message again and again&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that the same error message is printed over and over again. Here is what happens:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The CPU executes &lt;code&gt;rust_main&lt;&#x2f;code&gt; and tries to access &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;. This causes a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;The page fault handler prints an error message and returns without fixing the cause of the exception (&lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt; is still unaccessible).&lt;&#x2f;li&gt;
&lt;li&gt;The CPU restarts the instruction that caused the page fault and thus tries to access &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt; again. Of course, this causes a page fault again.&lt;&#x2f;li&gt;
&lt;li&gt;The page fault handler prints the error message and returns.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;â€¦ and so on. Thus, our code indefinitely jumps between the page fault handler and the instruction that accesses &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;This is a good thing! It means that our &lt;code&gt;iretq&lt;&#x2f;code&gt; logic is working correctly, since it returns to the correct instruction every time. So our &lt;code&gt;handler_with_error_code&lt;&#x2f;code&gt; macro seems to be correct.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;We are now able to catch exceptions and to return from them. However, there are still exceptions that completely crash our kernel by causing a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Triple_fault&quot;&gt;triple fault&lt;&#x2f;a&gt;. In the next post, we will fix this issue by handling a special type of exception: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Double_fault&quot;&gt;double fault&lt;&#x2f;a&gt;. Thus, we will be able to avoid random reboots in our kernel.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Better Exception Messages</title>
                <pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/better-exception-messages/</link>
                <guid>https://os.phil-opp.com/better-exception-messages/</guid>
                <description>&lt;p&gt;In this post, we explore exceptions in more detail. Our goal is to print additional information when an exception occurs, for example the values of the instruction and stack pointer. In the course of this, we will explore inline assembly and naked functions. We will also add a handler function for page faults and read the associated error code.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;better_exception_messages&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a &lt;a href=&quot;https:&#x2f;&#x2f;gitter.im&#x2f;phil-opp&#x2f;blog_os&quot;&gt;gitter chat&lt;&#x2f;a&gt; and a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2f;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;extra&#x2f;naked-exceptions&#x2f;&quot;&gt;â€œHandling Exceptions with Naked Functionsâ€&lt;&#x2f;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;â€œHandling Exceptionsâ€&lt;&#x2f;a&gt; post.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;h2 id=&quot;exceptions-in-detail&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-in-detail&quot; aria-label=&quot;Anchor link for: exceptions-in-detail&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exceptions in Detail&lt;&#x2f;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the currently-executed instruction. Whenever an exception occurs, the CPU interrupts its current work and starts an internal exception routine.&lt;&#x2f;p&gt;
&lt;p&gt;This routine involves reading the interrupt descriptor table and invoking the registered handler function. But first, the CPU pushes various information onto the stack, which describe the current state and provide information about the cause of the exception:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;exception-stack-frame.svg&quot; alt=&quot;exception stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The pushed information contain the instruction and stack pointer, the current CPU flags, and (for some exceptions) an error code, which contains further information about the cause of the exception. Let&#x27;s look at the fields in detail:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;First, the CPU aligns the stack pointer on a 16-byte boundary. This allows the handler function to use SSE instructions, which partly expect such an alignment.&lt;&#x2f;li&gt;
&lt;li&gt;After that, the CPU pushes the stack segment descriptor (SS) and the old stack pointer (from before the alignment) onto the stack. This allows us to restore the previous stack pointer when we want to resume the interrupted program.&lt;&#x2f;li&gt;
&lt;li&gt;Then the CPU pushes the contents of the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;RFLAGS&lt;&#x2f;a&gt; register. This register contains various state information of the interrupted program. For example, it indicates if interrupts were enabled and whether the last executed instruction returned zero.&lt;&#x2f;li&gt;
&lt;li&gt;Next the CPU pushes the instruction pointer and its code segment descriptor onto the stack. This tells us the address of the last executed instruction, which caused the exception.&lt;&#x2f;li&gt;
&lt;li&gt;Finally, the CPU pushes an error code for some exceptions. This error code only exists for exceptions such as page faults or general protection faults and provides additional information. For example, it tells us whether a page fault was caused by a read or a write request.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;printing-the-exception-stack-frame&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-the-exception-stack-frame&quot; aria-label=&quot;Anchor link for: printing-the-exception-stack-frame&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing the Exception Stack Frame&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s create a struct that represents the exception stack frame:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug)]
#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame {
    instruction_pointer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    code_segment: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    cpu_flags: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    stack_pointer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    stack_segment: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The divide-by-zero fault pushes no error code, so we leave it out for now. Note that the stack grows downwards in memory, so we need to declare the fields in reverse order (compared to the figure above).&lt;&#x2f;p&gt;
&lt;p&gt;Now we need a way to find the memory address of this stack frame. When we look at the above graphic again, we see that the start address of the exception stack frame is the new stack pointer. So we just need to read the value of &lt;code&gt;rsp&lt;&#x2f;code&gt; at the very beginning of our handler function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_handler() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov $0, rsp&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;=r&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(stack_frame) ::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_frame);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We&#x27;re using &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;book&#x2f;inline-assembly.html&quot;&gt;inline assembly&lt;&#x2f;a&gt; here to load the value from the &lt;code&gt;rsp&lt;&#x2f;code&gt; register into &lt;code&gt;stack_frame&lt;&#x2f;code&gt;. The syntax is a bit strange, so here&#x27;s a quick explanation:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;asm!&lt;&#x2f;code&gt; macro emits raw assembly instructions. This is the only way to read raw register values in Rust.&lt;&#x2f;li&gt;
&lt;li&gt;We insert a single assembly instruction: &lt;code&gt;mov $0, rsp&lt;&#x2f;code&gt;. It moves the value of &lt;code&gt;rsp&lt;&#x2f;code&gt; to some register (the &lt;code&gt;$0&lt;&#x2f;code&gt; is a placeholder for an arbitrary register, which gets filled by the compiler).&lt;&#x2f;li&gt;
&lt;li&gt;The colons are separators. After the first colon, the &lt;code&gt;asm!&lt;&#x2f;code&gt; macro expects output operands. We&#x27;re specifying our &lt;code&gt;stack_frame&lt;&#x2f;code&gt; variable as a single output operand here. The &lt;code&gt;=r&lt;&#x2f;code&gt; tells the compiler that it should use any register for the first placeholder &lt;code&gt;$0&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;After the second colon, we can specify input operands. We don&#x27;t need any, therefore we leave it empty.&lt;&#x2f;li&gt;
&lt;li&gt;After the third colon, the macro expects so called &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;book&#x2f;inline-assembly.html#clobbers&quot;&gt;clobbers&lt;&#x2f;a&gt;. We don&#x27;t change any register values, so we leave it empty too.&lt;&#x2f;li&gt;
&lt;li&gt;The last block (after the 4th colon) specifies options. The &lt;code&gt;intel&lt;&#x2f;code&gt; option tells the compiler that our code is in Intel assembly syntax (instead of the default AT&amp;amp;T syntax).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;So the inline assembly loads the stack pointer value to &lt;code&gt;stack_frame&lt;&#x2f;code&gt; at the very beginning of our function. Thus we have a pointer to the exception stack frame and are able to pretty-print its &lt;code&gt;Debug&lt;&#x2f;code&gt; formatting through the &lt;code&gt;{:#?}&lt;&#x2f;code&gt; argument.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s try it by executing &lt;code&gt;make run&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;qemu-print-stack-frame-try.png&quot; alt=&quot;qemu printing an ExceptionStackFrame with strange values&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Those &lt;code&gt;ExceptionStackFrame&lt;&#x2f;code&gt; values look very wrong. The instruction pointer definitely shouldn&#x27;t be 1 and the code segment should be &lt;code&gt;0x8&lt;&#x2f;code&gt; instead of some big number. So what&#x27;s going on here?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Debugging&lt;&#x2f;h3&gt;
&lt;p&gt;It seems like we somehow got the pointer wrong. The &lt;code&gt;ExceptionStackFrame&lt;&#x2f;code&gt; type and our inline assembly seem correct, so something must be modifying &lt;code&gt;rsp&lt;&#x2f;code&gt; before we load it into &lt;code&gt;stack_frame&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s see what&#x27;s happening by looking at the disassembly of our function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep -A20 &amp;quot;divide_by_zero_handler&amp;quot;

 [...]
000000000010ced0 &amp;lt;_ZN7blog_os10interrupts22divide_by_zero_handler17h62189e8E&amp;gt;:
 10ced0:	55                   	push   %rbp
 10ced1:	48 89 e5             	mov    %rsp,%rbp
 10ced4:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
 10cedb:	48 8d 45 98          	lea    -0x68(%rbp),%rax
 10cedf:	48 b9 1d 1d 1d 1d 1d 	movabs $0x1d1d1d1d1d1d1d1d,%rcx
 10cee6:	1d 1d 1d
 10cee9:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
 10ceed:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
 10cef1:	48 89 e1             	mov    %rsp,%rcx
 10cef4:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
 10cef8:  ...
[...]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; starts at address &lt;code&gt;0x10ced0&lt;&#x2f;code&gt;. Let&#x27;s look at the instruction at address &lt;code&gt;0x10cef1&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;mov %rsp,%rcx
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This is our inline assembly instruction, which loads the stack pointer into the &lt;code&gt;stack_frame&lt;&#x2f;code&gt; variable. It just looks a bit different, since it&#x27;s in AT&amp;amp;T syntax and contains &lt;code&gt;rcx&lt;&#x2f;code&gt; instead of our &lt;code&gt;$0&lt;&#x2f;code&gt; placeholder. It moves &lt;code&gt;rsp&lt;&#x2f;code&gt; to &lt;code&gt;rcx&lt;&#x2f;code&gt;, and then the next instruction (&lt;code&gt;mov %rcx,-0x8(%rbp)&lt;&#x2f;code&gt;) moves &lt;code&gt;rcx&lt;&#x2f;code&gt; to the variable on the stack.&lt;&#x2f;p&gt;
&lt;p&gt;We can clearly see the problem here: The compiler inserted various other instructions before our inline assembly. These instructions modify the stack pointer so that we don&#x27;t read the original &lt;code&gt;rsp&lt;&#x2f;code&gt; value and get a wrong pointer. But why is the compiler doing this?&lt;&#x2f;p&gt;
&lt;p&gt;The reason is that we need some place on the stack to store things like variables. Therefore the compiler inserts a so-called &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Function_prologue&quot;&gt;function prologue&lt;&#x2f;a&gt;&lt;&#x2f;em&gt;, which prepares the stack and reserves space for all variables. In our case, the compiler subtracts from the stack pointer to make room for i.a. our &lt;code&gt;stack_frame&lt;&#x2f;code&gt; variable. This prologue is the first thing in every function and comes before every other code.&lt;&#x2f;p&gt;
&lt;p&gt;So in order to correctly load the exception frame pointer, we need some way to circumvent the automatic prologue generation.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;naked-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#naked-functions&quot; aria-label=&quot;Anchor link for: naked-functions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Naked Functions&lt;&#x2f;h3&gt;
&lt;p&gt;Fortunately there is a way to disable the prologue: &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1201-naked-fns.md&quot;&gt;naked functions&lt;&#x2f;a&gt;. A naked function has no prologue and immediately starts with the first instruction of its body. However, most Rust code requires the prologue. Therefore naked functions should only contain inline assembly.&lt;&#x2f;p&gt;
&lt;p&gt;A naked function looks like this (note the &lt;code&gt;#[naked]&lt;&#x2f;code&gt; attribute):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;naked_function_example() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rax, 0x42&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rax&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Naked functions are highly unstable, so we need to add &lt;code&gt;#![feature(naked_functions)]&lt;&#x2f;code&gt; to our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;If you want to try it, insert it in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt; and call it from &lt;code&gt;rust_main&lt;&#x2f;code&gt;. When we inspect the disassembly, we see that the function prologue is missing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep -A5 &amp;quot;naked_function_example&amp;quot;
[...]
000000000010df90 &amp;lt;_ZN7blog_os22naked_function_example17ha9f733dfe42b595dE&amp;gt;:
  10df90:	48 c7 c0 2a 00 00 00 	mov    $0x42,%rax
  10df97:	c3                   	retq
  10df98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  10df9f:	00
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It contains just the specified inline assembly and a return instruction (you can ignore the junk values after the return statement). So let&#x27;s try to use a naked function to retrieve the exception frame pointer.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-naked-exception-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-naked-exception-handler&quot; aria-label=&quot;Anchor link for: a-naked-exception-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Naked Exception Handler&lt;&#x2f;h3&gt;
&lt;p&gt;We can&#x27;t use Rust code in naked functions, but we still want to use Rust in our exception handler. Therefore we split our handler function in two parts. A main exception handler in Rust and a small naked wrapper function, which just loads the exception frame pointer and then calls the main handler.&lt;&#x2f;p&gt;
&lt;p&gt;Our new two-stage exception handler looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* load exception frame pointer and call main handler *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_handler(stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame)
    -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_frame });
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The naked wrapper function retrieves the exception stack frame pointer and then calls the &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; with the pointer as argument. We can&#x27;t use Rust code in naked functions, so we need to do both things in inline assembly.&lt;&#x2f;p&gt;
&lt;p&gt;Retrieving the pointer to the exception stack frame is easy: We just need to load it from the &lt;code&gt;rsp&lt;&#x2f;code&gt; register. Our wrapper function has no prologue (it&#x27;s naked), so we can be sure that nothing modifies the register before.&lt;&#x2f;p&gt;
&lt;p&gt;Calling the main handler is a bit more complicated, since we need to pass the argument correctly. Our main handler uses the C calling convention, which specifies that the the first argument is passed in the &lt;code&gt;rdi&lt;&#x2f;code&gt; register. So we need to load the pointer value into &lt;code&gt;rdi&lt;&#x2f;code&gt; and then use the &lt;code&gt;call&lt;&#x2f;code&gt; instruction to call &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Translated to assembly, it looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rdi, rsp
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_handler
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It moves the exception stack frame pointer from &lt;code&gt;rsp&lt;&#x2f;code&gt; to &lt;code&gt;rdi&lt;&#x2f;code&gt;, where the first argument is expected, and then calls the main handler. Let&#x27;s create the corresponding inline assembly to complete our wrapper function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp; call $0&amp;quot;
             &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(divide_by_zero_handler &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
             : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of &lt;code&gt;call divide_by_zero_handler&lt;&#x2f;code&gt;, we use a placeholder again. The reason is Rust&#x27;s name mangling, which changes the name of the &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; function. To circumvent this, we pass a function pointer as input parameter (after the second colon). The &lt;code&gt;&amp;quot;i&amp;quot;&lt;&#x2f;code&gt; tells the compiler that it is an immediate value, which can be directly inserted for the placeholder. We also specify a clobber after the third colon, which tells the compiler that we change the value of the &lt;code&gt;rdi&lt;&#x2f;code&gt; register.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;intrinsics-unreachable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#intrinsics-unreachable&quot; aria-label=&quot;Anchor link for: intrinsics-unreachable&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Intrinsics::Unreachable&lt;&#x2f;h3&gt;
&lt;p&gt;When we try to compile it, we get the following error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: computation may converge in a function marked as diverging
  --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:23:1
   |&amp;gt;
23 |&amp;gt; extern &amp;quot;C&amp;quot; fn divide_by_zero_wrapper() -&amp;gt; ! {
   |&amp;gt; ^
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason is that we marked our &lt;code&gt;divide_by_zero_wrapper&lt;&#x2f;code&gt; function as diverging (the &lt;code&gt;!&lt;&#x2f;code&gt;). We call another diverging function in inline assembly, so it is clear that the function diverges. However, the Rust compiler doesn&#x27;t understand inline assembly, so it doesn&#x27;t know that. To fix this, we tell the compiler that all code after the &lt;code&gt;asm!&lt;&#x2f;code&gt; macro is unreachable:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp; call $0&amp;quot;
             &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(divide_by_zero_handler &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
             : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        ::core::intrinsics::unreachable();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;intrinsics&#x2f;fn.unreachable.html&quot;&gt;intrinsics::unreachable&lt;&#x2f;a&gt; function is unstable, so we need to add &lt;code&gt;#![feature(core_intrinsics)]&lt;&#x2f;code&gt; to our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;. It is just an annotation for the compiler and produces no real code. (Not to be confused with the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;macro.unreachable!.html&quot;&gt;unreachable!&lt;&#x2f;a&gt; macro, which is completely different!)&lt;&#x2f;p&gt;
&lt;h3 id=&quot;it-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#it-works&quot; aria-label=&quot;Anchor link for: it-works&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
It works!&lt;&#x2f;h3&gt;
&lt;p&gt;The last step is to update the interrupt descriptor table (IDT) to use our new wrapper function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, divide_by_zero_wrapper); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; changed
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we see a correct exception stack frame when we execute &lt;code&gt;make run&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;qemu-divide-by-zero-stack-frame.png&quot; alt=&quot;QEMU showing correct divide by zero stack frame&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h2 id=&quot;testing-on-real-hardware&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-on-real-hardware&quot; aria-label=&quot;Anchor link for: testing-on-real-hardware&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing on real Hardware&lt;&#x2f;h2&gt;
&lt;p&gt;Virtual machines such as QEMU are very convenient to quickly test our kernel. However, they might behave a bit different than real hardware in some situations. So we should test our kernel on real hardware, too.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s do it by burning it to an USB stick:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; sudo dd if=build&#x2f;os-x86_64.iso of=&#x2f;dev&#x2f;sdX; and sync
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Replace &lt;code&gt;sdX&lt;&#x2f;code&gt; by the device name of your USB stick. But &lt;strong&gt;be careful&lt;&#x2f;strong&gt;! The command will erase everything on that device.&lt;&#x2f;p&gt;
&lt;p&gt;Now we should be able to boot from this USB stick. When we do it, we see that it works fine on real hardware, too. Great!&lt;&#x2f;p&gt;
&lt;p&gt;However, this section wouldn&#x27;t exist if there weren&#x27;t a problem. To trigger this problem, we add some example code to the start of our &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_handler(...) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; y &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(x);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).map(|z| (z, z &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)) {}

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This is just some garbage code that doesn&#x27;t do anything useful. When we try it in QEMU using &lt;code&gt;make run&lt;&#x2f;code&gt;, it still works fine. However, when we burn it to an USB stick again and boot from it on real hardware, we see that our computer reboots just before printing the exception message.&lt;&#x2f;p&gt;
&lt;p&gt;So our code, which worked well in QEMU, &lt;em&gt;causes a triple fault&lt;&#x2f;em&gt; on real hardware. What&#x27;s happening?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;reproducing-the-bug-in-qemu&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reproducing-the-bug-in-qemu&quot; aria-label=&quot;Anchor link for: reproducing-the-bug-in-qemu&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Reproducing the Bug in QEMU&lt;&#x2f;h3&gt;
&lt;p&gt;Debugging on a real machine is difficult. Fortunately there is a way to reproduce this bug in QEMU: We use Linux&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Kernel-based_Virtual_Machine&quot;&gt;Kernel-based Virtual Machine&lt;&#x2f;a&gt; (KVM) by passing the &lt;code&gt;â€‘enable-kvm&lt;&#x2f;code&gt; flag:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 -cdrom build&#x2f;os-x86_64.iso -enable-kvm
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now QEMU triple faults as well. This should make debugging much easier.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;debugging-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging-1&quot; aria-label=&quot;Anchor link for: debugging-1&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Debugging&lt;&#x2f;h3&gt;
&lt;p&gt;QEMU&#x27;s &lt;code&gt;-d int&lt;&#x2f;code&gt;, which prints every exception, doesn&#x27;t seem to work in KVM mode. However &lt;code&gt;-d cpu_reset&lt;&#x2f;code&gt; still works. It prints the complete CPU state whenever the CPU resets. Let&#x27;s try it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 -cdrom build&#x2f;os-x86_64.iso -enable-kvm -d cpu_reset
CPU Reset (CPU 0)
EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
ESI=00000000 EDI=00000000 EBP=00000000 ESP=00000000
EIP=00000000 EFL=00000000 [-------] CPL=0 II=0 A20=0 SMM=0 HLT=0
[...]
CPU Reset (CPU 0)
EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000663
ESI=00000000 EDI=00000000 EBP=00000000 ESP=00000000
EIP=0000fff0 EFL=00000002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
[...]
CPU Reset (CPU 0)
RAX=0000000000118cb8 RBX=0000000000000800 RCX=1d1d1d1d1d1d1d1d RDX=0..0000000
RSI=0000000000112cd0 RDI=0000000000118d38 RBP=0000000000118d28 RSP=0..0118c68
R8 =0000000000000000 R9 =0000000000000100 R10=0000000000118700 R11=0..0118a00
R12=0000000000000000 R13=0000000000000000 R14=0000000000000000 R15=0..0000000
RIP=000000000010cf08 RFL=00210002 [-------] CPL=0 II=0 A20=1 SMM=0 HLT=0
[...]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The first two resets occur while the CPU is still in 32-bit mode (&lt;code&gt;EAX&lt;&#x2f;code&gt; instead of &lt;code&gt;RAX&lt;&#x2f;code&gt;), so we ignore them. The third reset is the interesting one, because it occurs in 64-bit mode. The register dump tells us that the instruction pointer (&lt;code&gt;rip&lt;&#x2f;code&gt;) was &lt;code&gt;0x10cf08&lt;&#x2f;code&gt; just before the reset. This might be the address of the instruction that caused the triple fault.&lt;&#x2f;p&gt;
&lt;p&gt;We can find the corresponding instruction by disassembling our kernel:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;objdump -d build&#x2f;kernel-x86_64.bin | grep &amp;quot;10cf08:&amp;quot;
  10cf08:	0f 29 45 b0          	movaps %xmm0,-0x50(%rbp)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;movaps&quot;&gt;movaps&lt;&#x2f;a&gt; instruction is an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2f;a&gt; instruction that moves aligned 128bit values. It can fail for a number of reasons:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;For an illegal memory operand effective address in the CS, DS, ES, FS or GS segments.&lt;&#x2f;li&gt;
&lt;li&gt;For an illegal address in the SS segment.&lt;&#x2f;li&gt;
&lt;li&gt;If a memory operand is not aligned on a 16-byte boundary.&lt;&#x2f;li&gt;
&lt;li&gt;For a page fault.&lt;&#x2f;li&gt;
&lt;li&gt;If TS in CR0 is set.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The segment registers contain no meaningful values in long mode, so they can&#x27;t contain illegal addresses. We did not change the TS bit in &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Control_register#CR0&quot;&gt;CR0&lt;&#x2f;a&gt; and there is no reason for a page fault either. So it has to be option 3.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;16-byte-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#16-byte-alignment&quot; aria-label=&quot;Anchor link for: 16-byte-alignment&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
16-byte Alignment&lt;&#x2f;h3&gt;
&lt;p&gt;Some SSE instructions such as &lt;code&gt;movaps&lt;&#x2f;code&gt; require that memory operands are 16-byte aligned. In our case, the instruction is &lt;code&gt;movaps %xmm0,-0x50(%rbp)&lt;&#x2f;code&gt;, which writes to address &lt;code&gt;rbp - 0x50&lt;&#x2f;code&gt;. Therefore &lt;code&gt;rbp&lt;&#x2f;code&gt; needs to be 16-byte aligned.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s look at the above &lt;code&gt;-d cpu_reset&lt;&#x2f;code&gt; dump again and check the value of &lt;code&gt;rbp&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;CPU Reset (CPU 0)
RAX=[...] RBX=[...] RCX=[...] RDX=[...]
RSI=[...] RDI=[...] RBP=0000000000118d28 RSP=[...]
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;code&gt;RBP&lt;&#x2f;code&gt; is &lt;code&gt;0x118d28&lt;&#x2f;code&gt;, which is &lt;em&gt;not&lt;&#x2f;em&gt; 16-byte aligned. So this is the reason for the triple fault. (It seems like QEMU doesn&#x27;t check the alignment for &lt;code&gt;movaps&lt;&#x2f;code&gt;, but real hardware of course does.)&lt;&#x2f;p&gt;
&lt;p&gt;But how did we end up with a misaligned &lt;code&gt;rbp&lt;&#x2f;code&gt; register?&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-base-pointer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-base-pointer&quot; aria-label=&quot;Anchor link for: the-base-pointer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Base Pointer&lt;&#x2f;h3&gt;
&lt;p&gt;In order to solve this mystery, we need to look at the disassembly of the preceding code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -d build&#x2f;kernel-x86_64.bin | grep -B10 &amp;quot;10cf08:&amp;quot;
000000000010cee0 &amp;lt;_ZN7blog_os10interrupts22divide_by_zero_handler17hE&amp;gt;:
  10cee0:	55                   	push   %rbp
  10cee1:	48 89 e5             	mov    %rsp,%rbp
  10cee4:	48 81 ec c0 00 00 00 	sub    $0xc0,%rsp
  10ceeb:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  10ceef:	48 b9 1d 1d 1d 1d 1d 	movabs $0x1d1d1d1d1d1d1d1d,%rcx
  10cef6:	1d 1d 1d
  10cef9:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  10cefd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  10cf01:	0f 10 05 a8 51 00 00 	movups 0x51a8(%rip),%xmm0
  10cf08:	0f 29 45 b0          	movaps %xmm0,-0x50(%rbp)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;At the last line we have the &lt;code&gt;movaps&lt;&#x2f;code&gt; instruction, which caused the triple fault. The exception occurs inside our &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; function. We see that &lt;code&gt;rbp&lt;&#x2f;code&gt; is loaded with the value of &lt;code&gt;rsp&lt;&#x2f;code&gt; at the beginning (at &lt;code&gt;0x10cee1&lt;&#x2f;code&gt;). The &lt;code&gt;rbp&lt;&#x2f;code&gt; register holds the so-called &lt;em&gt;base pointer&lt;&#x2f;em&gt;, which points to the beginning of the stack frame. It is used in the rest of the function to address variables and other values on the stack.&lt;&#x2f;p&gt;
&lt;p&gt;The base pointer is initialized directly from the stack pointer (&lt;code&gt;rsp&lt;&#x2f;code&gt;) after pushing the old base pointer. There is no special alignment code, so the compiler blindly assumes that &lt;code&gt;(rsp - 8)&lt;&#x2f;code&gt;&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-rsp-8&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; is always 16-byte aligned. This seems to be wrong in our case. But why does the compiler assume this?&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-rsp-8&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;By pushing the old base pointer, &lt;code&gt;rsp&lt;&#x2f;code&gt; is updated to &lt;code&gt;rsp-8&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;h3 id=&quot;calling-conventions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-conventions&quot; aria-label=&quot;Anchor link for: calling-conventions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Calling Conventions&lt;&#x2f;h3&gt;
&lt;p&gt;The reason is that our exception handler is defined as &lt;code&gt;extern &amp;quot;C&amp;quot; function&lt;&#x2f;code&gt;, which specifies that it&#x27;s using the C &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_calling_conventions&quot;&gt;calling convention&lt;&#x2f;a&gt;. On x86_64 Linux, the C calling convention is specified by the System V AMD64 ABI (&lt;a href=&quot;http:&#x2f;&#x2f;web.archive.org&#x2f;web&#x2f;20160801075139&#x2f;http:&#x2f;&#x2f;www.x86-64.org&#x2f;documentation&#x2f;abi.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;). Section 3.2.2 defines the following:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The end of the input argument area shall be aligned on a 16 byte boundary. In other words, the value (%rsp + 8) is always a multiple of 16 when control is transferred to the function entry point.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;The â€œend of the input argument areaâ€ refers to the last stack-passed argument (in our case there aren&#x27;t any). So the stack pointer must be 16 byte aligned whenever we &lt;code&gt;call&lt;&#x2f;code&gt; a C-compatible function. The &lt;code&gt;call&lt;&#x2f;code&gt; instruction then pushes the return value on the stack so that â€œthe value (%rsp + 8) is a multiple of 16 when control is transferred to the function entry pointâ€.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;em&gt;Summary&lt;&#x2f;em&gt;: The calling convention requires a 16 byte aligned stack pointer before &lt;code&gt;call&lt;&#x2f;code&gt; instructions. The compiler relies on this requirement, but we broke it somehow. Thus the generated code triple faults due to a misaligned memory address in the &lt;code&gt;movaps&lt;&#x2f;code&gt; instruction.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-the-alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-alignment&quot; aria-label=&quot;Anchor link for: fixing-the-alignment&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing the Alignment&lt;&#x2f;h3&gt;
&lt;p&gt;In order to fix this bug, we need to make sure that the stack pointer is correctly aligned before calling &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;&#x2f;code&gt; functions. Let&#x27;s summarize the stack pointer modifications that occur before the exception handler is called:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;The CPU aligns the stack pointer to a 16 byte boundary.&lt;&#x2f;li&gt;
&lt;li&gt;The CPU pushes &lt;code&gt;ss&lt;&#x2f;code&gt;, &lt;code&gt;rsp&lt;&#x2f;code&gt;, &lt;code&gt;rflags&lt;&#x2f;code&gt;, &lt;code&gt;cs&lt;&#x2f;code&gt;, and &lt;code&gt;rip&lt;&#x2f;code&gt;. So it pushes five 8 byte registers, which makes &lt;code&gt;rsp&lt;&#x2f;code&gt; misaligned.&lt;&#x2f;li&gt;
&lt;li&gt;The wrapper function calls &lt;code&gt;divide_by_zero_handler&lt;&#x2f;code&gt; with a misaligned stack pointer.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The problem is that we&#x27;re pushing an uneven number of 8 byte registers. Thus we need to align the stack pointer again before the &lt;code&gt;call&lt;&#x2f;code&gt; instruction:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[naked]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
              sub rsp, 8 &#x2f;&#x2f; align the stack pointer
              call $0&amp;quot;
              &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(divide_by_zero_handler &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;_&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
              : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        ::core::intrinsics::unreachable();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The additional &lt;code&gt;sub rsp, 8&lt;&#x2f;code&gt; instruction aligns the stack pointer to a 16 byte boundary. Now it should work on real hardware (and in QEMU KVM mode) again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-handler-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-handler-macro&quot; aria-label=&quot;Anchor link for: a-handler-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Handler Macro&lt;&#x2f;h2&gt;
&lt;p&gt;The next step is to add handlers for other exceptions. However, we would need wrapper functions for them too. To avoid this code duplication, we create a &lt;code&gt;handler&lt;&#x2f;code&gt; macro that creates the wrapper functions for us:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov rdi, rsp
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The macro takes a single Rust identifier (&lt;code&gt;ident&lt;&#x2f;code&gt;) as argument and expands to a &lt;code&gt;{}&lt;&#x2f;code&gt; block (hence the double braces). The block defines a new wrapper function that calls the function &lt;code&gt;$name&lt;&#x2f;code&gt; and passes a pointer to the exception stack frame. Note that we&#x27;re fixing the argument type to &lt;code&gt;&amp;amp;ExceptionStackFrame&lt;&#x2f;code&gt;. If we used a &lt;code&gt;_&lt;&#x2f;code&gt; like before, the passed function could accept an arbitrary argument, which would lead to ugly bugs at runtime.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can remove the &lt;code&gt;divide_by_zero_wrapper&lt;&#x2f;code&gt; and use our new &lt;code&gt;handler!&lt;&#x2f;code&gt; macro instead:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(divide_by_zero_handler)); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the &lt;code&gt;handler!&lt;&#x2f;code&gt; macro needs to be defined above the static &lt;code&gt;IDT&lt;&#x2f;code&gt;, because macros are only available after their definition.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;invalid-opcode-exception&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#invalid-opcode-exception&quot; aria-label=&quot;Anchor link for: invalid-opcode-exception&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Invalid Opcode Exception&lt;&#x2f;h3&gt;
&lt;p&gt;With the &lt;code&gt;handler!&lt;&#x2f;code&gt; macro we can create new handler functions easily. For example, we can add a handler for the invalid opcode exception as follows:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(divide_by_zero_handler));
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(invalid_opcode_handler)); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt
    };
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid_opcode_handler(stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame)
    -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_frame };
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: INVALID OPCODE at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        stack_frame.instruction_pointer, stack_frame);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Invalid opcode faults have the vector number 6, so we set the 6th IDT entry. This time we additionally print the address of the invalid instruction.&lt;&#x2f;p&gt;
&lt;p&gt;We can test our new handler with the special &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;ud&quot;&gt;ud2&lt;&#x2f;a&gt; instruction, which generates a invalid opcode:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; provoke a invalid opcode exception
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ud2&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;exceptions-with-error-codes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions-with-error-codes&quot; aria-label=&quot;Anchor link for: exceptions-with-error-codes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exceptions with Error Codes&lt;&#x2f;h2&gt;
&lt;p&gt;When a divide-by-zero exception occurs, we immediately know the reason: Someone tried to divide by zero. In contrast, there are faults with many possible causes. For example, a page fault occurs in many occasions: When accessing a non-present page, when writing to a read-only page, when the page table is malformed, etc. In order to differentiate these causes, the CPU pushes an additional error code onto the stack for such exceptions, which gives additional information.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-new-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-new-macro&quot; aria-label=&quot;Anchor link for: a-new-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A new Macro&lt;&#x2f;h3&gt;
&lt;p&gt;Since the CPU pushes an additional error code, the stack frame is different and our &lt;code&gt;handler!&lt;&#x2f;code&gt; macro is not applicable. Therefore we create a new &lt;code&gt;handler_with_error_code!&lt;&#x2f;code&gt; macro for them:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! handler_with_error_code {
    ($name: ident) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{{
        #[naked]
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;wrapper() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;pop rsi &#x2f;&#x2f; pop error code into rsi
                      mov rdi, rsp
                      sub rsp, 8 &#x2f;&#x2f; align the stack pointer
                      call $0&amp;quot;
                      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;:: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;i&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
                      : &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rdi&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;rsi&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                ::core::intrinsics::unreachable();
            }
        }
        wrapper
    }}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The difference to the &lt;code&gt;handler!&lt;&#x2f;code&gt; macro is the additional error code argument. The CPU pushes the error code last, so we pop it right at the beginning of the wrapper function. We pop it into &lt;code&gt;rsi&lt;&#x2f;code&gt; because the C calling convention expects the second argument in it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-page-fault-handler&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-page-fault-handler&quot; aria-label=&quot;Anchor link for: a-page-fault-handler&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Page Fault Handler&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s write a page fault handler which analyzes and prints the error code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_fault_handler(stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame,
                                 error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: PAGE FAULT with error code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        error_code, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_frame });
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need to register our new handler function in the static interrupt descriptor table (IDT):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();

        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(divide_by_zero_handler));
        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler!(invalid_opcode_handler));
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler_with_error_code!(page_fault_handler));

        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Page faults have the vector number 14, so we set the 14th IDT entry.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;testing-it-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it-1&quot; aria-label=&quot;Anchor link for: testing-it-1&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h4&gt;
&lt;p&gt;Let&#x27;s test our new page fault handler by provoking a page fault in our main function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; provoke a page fault
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We get the following output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;qemu-page-fault-handler.png&quot; alt=&quot;QEMU: page fault with error code 2 and stack frame dump&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-page-fault-error-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-page-fault-error-code&quot; aria-label=&quot;Anchor link for: the-page-fault-error-code&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Page Fault Error Code&lt;&#x2f;h3&gt;
&lt;p&gt;â€œError code 2â€ is not really an useful error message. Let&#x27;s improve this by creating a &lt;code&gt;PageFaultErrorCode&lt;&#x2f;code&gt; type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bitflags! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageFaultErrorCode: u64 {
        const PROTECTION_VIOLATION = 1 &amp;lt;&amp;lt; 0;
        const CAUSED_BY_WRITE = 1 &amp;lt;&amp;lt; 1;
        const USER_MODE = 1 &amp;lt;&amp;lt; 2;
        const MALFORMED_TABLE = 1 &amp;lt;&amp;lt; 3;
        const INSTRUCTION_FETCH = 1 &amp;lt;&amp;lt; 4;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;ul&gt;
&lt;li&gt;When the &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2f;code&gt; flag is set, the page fault was caused e.g. by a write to a read-only page. If it&#x27;s not set, it was caused by accessing a non-present page.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;CAUSED_BY_WRITE&lt;&#x2f;code&gt; flag specifies if the fault was caused by a write (if set) or a read (if not set).&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;USER_MODE&lt;&#x2f;code&gt; flag is set when the fault occurred in non-priviledged mode.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;MALFORMED_TABLE&lt;&#x2f;code&gt; flag is set when the page table entry has a 1 in a reserved field.&lt;&#x2f;li&gt;
&lt;li&gt;When the &lt;code&gt;INSTRUCTION_FETCH&lt;&#x2f;code&gt; flag is set, the page fault occurred while fetching the next instruction.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Now we can improve our page fault error message by using the new &lt;code&gt;PageFaultErrorCode&lt;&#x2f;code&gt;. We also print the accessed memory address:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_fault_handler(stack_frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ExceptionStackFrame,
                                 error_code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control_regs;
    println!(
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;EXCEPTION: PAGE FAULT while accessing &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;\
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;error code: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ control_regs::cr2() },
        PageFaultErrorCode::from_bits(error_code).unwrap(),
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_frame });
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;from_bits&lt;&#x2f;code&gt; function tries to convert the &lt;code&gt;u64&lt;&#x2f;code&gt; into a &lt;code&gt;PageFaultErrorCode&lt;&#x2f;code&gt;. We use &lt;code&gt;unwrap&lt;&#x2f;code&gt; to panic if the error code has invalid bits set, since this indicates an error in our &lt;code&gt;PageFaultErrorCode&lt;&#x2f;code&gt; definition or a stack corruption. We also print the contents of the &lt;code&gt;cr2&lt;&#x2f;code&gt; register. It contains the accessed memory address, which was the cause of the page fault.&lt;&#x2f;p&gt;
&lt;p&gt;Now we get a useful error message when a page fault occurs, which allows us to debug it more easily:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;better-exception-messages&#x2f;qemu-page-fault-error-code.png&quot; alt=&quot;QEMU: output is now PAGE FAULT with error code CAUSED_BY_WRITE&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As expected, the page fault was caused by write to &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt;. The &lt;code&gt;PROTECTION_VIOLATION&lt;&#x2f;code&gt; flag is not set, so the accessed page was not present.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;Now we&#x27;re able to catch and analyze various exceptions. The next step is to &lt;em&gt;resolve&lt;&#x2f;em&gt; exceptions, if possible. An example is &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Demand_paging&quot;&gt;demand paging&lt;&#x2f;a&gt;: The OS swaps out memory pages to disk so that a page fault occurs when the page is accessed the next time. In that case, the OS can resolve the exception by bringing the page back into memory. Afterwards, the OS resumes the interrupted program as if nothing had happened.&lt;&#x2f;p&gt;
&lt;p&gt;The next post will implement the first portion of demand paging: saving and restoring the complete state of an program. This will allow us to transparently interrupt and resume programs in the future.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Catching Exceptions</title>
                <pubDate>Sat, 28 May 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/catching-exceptions/</link>
                <guid>https://os.phil-opp.com/catching-exceptions/</guid>
                <description>&lt;p&gt;In this post, we start exploring exceptions. We set up an interrupt descriptor table and add handler functions. At the end of this post, our kernel will be able to catch divide-by-zero faults.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, the complete source code is on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;catching_exceptions&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;&#x2f;strong&gt;: This post describes how to handle exceptions using naked functions (see &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;first-edition&#x2f;extra&#x2f;naked-exceptions&#x2f;&quot;&gt;â€œHandling Exceptions with Naked Functionsâ€&lt;&#x2f;a&gt; for an overview). Our new way of handling exceptions can be found in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;â€œHandling Exceptionsâ€&lt;&#x2f;a&gt; post.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;h2 id=&quot;exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#exceptions&quot; aria-label=&quot;Anchor link for: exceptions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Exceptions&lt;&#x2f;h2&gt;
&lt;p&gt;An exception signals that something is wrong with the current instruction. For example, the CPU issues an exception if the current instruction tries to divide by 0. When an exception occurs, the CPU interrupts its current work and immediately calls a specific exception handler function, depending on the exception type.&lt;&#x2f;p&gt;
&lt;p&gt;We&#x27;ve already seen several types of exceptions in our kernel:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Invalid Opcode&lt;&#x2f;strong&gt;: This exception occurs when the current instruction is invalid. For example, this exception occurred when we tried to use SSE instructions before enabling SSE. Without SSE, the CPU didn&#x27;t know the &lt;code&gt;movups&lt;&#x2f;code&gt; and &lt;code&gt;movaps&lt;&#x2f;code&gt; instructions, so it throws an exception when it stumbles over them.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Page Fault&lt;&#x2f;strong&gt;: A page fault occurs on illegal memory accesses. For example, if the current instruction tries to read from an unmapped page or tries to write to a read-only page.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Double Fault&lt;&#x2f;strong&gt;: When an exception occurs, the CPU tries to call the corresponding handler function. If another exception exception occurs &lt;em&gt;while calling the exception handler&lt;&#x2f;em&gt;, the CPU raises a double fault exception. This exception also occurs when there is no handler function registered for an exception.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Triple Fault&lt;&#x2f;strong&gt;: If an exception occurs while the CPU tries to call the double fault handler function, it issues a fatal &lt;em&gt;triple fault&lt;&#x2f;em&gt;. We can&#x27;t catch or handle a triple fault. Most processors react by resetting themselves and rebooting the operating system. This causes the bootloops we experienced in the previous posts.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;For the full list of exceptions check out the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;OSDev wiki&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-interrupt-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-interrupt-descriptor-table&quot; aria-label=&quot;Anchor link for: the-interrupt-descriptor-table&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Interrupt Descriptor Table&lt;&#x2f;h3&gt;
&lt;p&gt;In order to catch and handle exceptions, we have to set up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2f;em&gt; (IDT). In this table we can specify a handler function for each CPU exception. The hardware uses this table directly, so we need to follow a predefined format. Each entry must have the following 16-byte structure:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2f;th&gt;&lt;th&gt;Name                     &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [0:15]  &lt;&#x2f;td&gt;&lt;td&gt;The lower bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;GDT selector             &lt;&#x2f;td&gt;&lt;td&gt;Selector of a code segment in the GDT.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Options                  &lt;&#x2f;td&gt;&lt;td&gt;(see below)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u16 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [16:31] &lt;&#x2f;td&gt;&lt;td&gt;The middle bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Function Pointer [32:63] &lt;&#x2f;td&gt;&lt;td&gt;The remaining bits of the pointer to the handler function.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u32 &lt;&#x2f;td&gt;&lt;td&gt;Reserved                 &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The options field has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bits  &lt;&#x2f;th&gt;&lt;th&gt;Name                              &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-2   &lt;&#x2f;td&gt;&lt;td&gt;Interrupt Stack Table Index       &lt;&#x2f;td&gt;&lt;td&gt;0: Don&#x27;t switch stacks, 1-7: Switch to the n-th stack in the Interrupt Stack Table when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3-7   &lt;&#x2f;td&gt;&lt;td&gt;Reserved              &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8     &lt;&#x2f;td&gt;&lt;td&gt;0: Interrupt Gate, 1: Trap Gate   &lt;&#x2f;td&gt;&lt;td&gt;If this bit is 0, interrupts are disabled when this handler is called.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11  &lt;&#x2f;td&gt;&lt;td&gt;must be one                       &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12    &lt;&#x2f;td&gt;&lt;td&gt;must be zero                      &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;13â€‘14 &lt;&#x2f;td&gt;&lt;td&gt;Descriptor Privilege Level (DPL)  &lt;&#x2f;td&gt;&lt;td&gt;The minimal privilege level required for calling this handler.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;15    &lt;&#x2f;td&gt;&lt;td&gt;Present                           &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Each exception has a predefined IDT index. For example the invalid opcode exception has table index 6 and the page fault exception has table index 14. Thus, the hardware can automatically load the corresponding IDT entry for each exception. The &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;Exception Table&lt;&#x2f;a&gt; in the OSDev wiki shows the IDT indexes of all exceptions in the â€œVector nr.â€ column.&lt;&#x2f;p&gt;
&lt;p&gt;When an exception occurs, the CPU roughly does the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;Read the corresponding entry from the Interrupt Descriptor Table (IDT). For example, the CPU reads the 14-th entry when a page fault occurs.&lt;&#x2f;li&gt;
&lt;li&gt;Check if the entry is present. Raise a double fault if not.&lt;&#x2f;li&gt;
&lt;li&gt;Push some registers on the stack, including the instruction pointer and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;EFLAGS&lt;&#x2f;a&gt; register. (We will use these values in a future post.)&lt;&#x2f;li&gt;
&lt;li&gt;Disable interrupts if the entry is an interrupt gate (bit 40 not set).&lt;&#x2f;li&gt;
&lt;li&gt;Load the specified GDT selector into the CS segment.&lt;&#x2f;li&gt;
&lt;li&gt;Jump to the specified handler function.&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;h2 id=&quot;handling-exceptions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-exceptions&quot; aria-label=&quot;Anchor link for: handling-exceptions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Handling Exceptions&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s try to catch and handle CPU exceptions. We start by creating a new &lt;code&gt;interrupts&lt;&#x2f;code&gt; module with an &lt;code&gt;idt&lt;&#x2f;code&gt; submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we create types for the IDT and its entries:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;interrupts&#x2f;idt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::segmentation;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::structures::gdt::SegmentSelector;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::PrivilegeLevel;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt([Entry; 16]);

#[derive(Debug, Clone, Copy)]
#[repr(C, packed)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry {
    pointer_low: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    gdt_selector: SegmentSelector,
    options: EntryOptions,
    pointer_middle: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    pointer_high: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    reserved: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The IDT is variable sized and can have up to 256 entries. We only need the first 16 entries in this post, so we define the table as &lt;code&gt;[Entry; 16]&lt;&#x2f;code&gt;. The remaining 240 handlers are treated as non-present by the CPU.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Entry&lt;&#x2f;code&gt; type is the translation of the above table to Rust. The &lt;code&gt;repr(C, packed)&lt;&#x2f;code&gt; attribute ensures that the compiler keeps the field ordering and does not add any padding between them. Instead of describing the &lt;code&gt;gdt_selector&lt;&#x2f;code&gt; as a plain &lt;code&gt;u16&lt;&#x2f;code&gt;, we use the &lt;code&gt;SegmentSelector&lt;&#x2f;code&gt; type of the &lt;code&gt;x86&lt;&#x2f;code&gt; crate. We also merge bits 32 to 47 into an &lt;code&gt;option&lt;&#x2f;code&gt; field, because Rust has no &lt;code&gt;u3&lt;&#x2f;code&gt; or &lt;code&gt;u1&lt;&#x2f;code&gt; type. The &lt;code&gt;EntryOptions&lt;&#x2f;code&gt; type is described below:&lt;&#x2f;p&gt;
&lt;h3 id=&quot;entry-options&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#entry-options&quot; aria-label=&quot;Anchor link for: entry-options&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Entry Options&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;EntryOptions&lt;&#x2f;code&gt; type has the following skeleton:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryOptions(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryOptions {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_present(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, present: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;disable_interrupts(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, disable: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_privilege_level(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, dpl: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_stack_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The implementations of these methods need to modify the correct bits of the &lt;code&gt;u16&lt;&#x2f;code&gt; without touching the other bits. For example, we would need the following bit-fiddling to set the stack index:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xfff8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_index;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Or alternatively:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b111&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_index;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Or:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;((self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; stack_index;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Well, none of these variants is really &lt;em&gt;readable&lt;&#x2f;em&gt; and it&#x27;s very easy to make mistakes somewhere. Therefore I created a &lt;code&gt;BitField&lt;&#x2f;code&gt; trait that provides the following &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ops&#x2f;struct.Range.html&quot;&gt;Range&lt;&#x2f;a&gt;-based API:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, stack_index);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I think it is much more readable, since we abstracted away all bit-masking details. The &lt;code&gt;BitField&lt;&#x2f;code&gt; trait is contained in the &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;bit_field&quot;&gt;bit_field&lt;&#x2f;a&gt; crate. (It&#x27;s pretty new, so it might still contain bugs.) To add it as dependency, we run &lt;code&gt;cargo add bit_field&lt;&#x2f;code&gt; and add &lt;code&gt;extern crate bit_field;&lt;&#x2f;code&gt; to our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use the trait to implement the methods of &lt;code&gt;EntryOptions&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;idt.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bit_field::BitField;

#[derive(Debug, Clone, Copy)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryOptions(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryOptions {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;minimal() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; options &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        options.set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0b111&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; &amp;#39;must-be-one&amp;#39; bits
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        EntryOptions(options)
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; options &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= Self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::minimal();
        options.set_present(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).disable_interrupts(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        options
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_present(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, present: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_bit(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, present);
        self
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;disable_interrupts(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, disable: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_bit(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;disable);
        self
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_privilege_level(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, dpl: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, dpl);
        self
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_stack_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_bits(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, index);
        self
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that the ranges are &lt;em&gt;exclusive&lt;&#x2f;em&gt; the upper bound. The &lt;code&gt;minimal&lt;&#x2f;code&gt; function creates an &lt;code&gt;EntryOptions&lt;&#x2f;code&gt; type with only the â€œmust-be-oneâ€ bits set. The &lt;code&gt;new&lt;&#x2f;code&gt; function, on the other hand, chooses reasonable defaults: It sets the present bit (why would you want to create a non-present entry?) and disables interrupts (normally we don&#x27;t want that our exception handlers can be interrupted). By returning the self pointer from the &lt;code&gt;set_*&lt;&#x2f;code&gt; methods, we allow easy method chaining such as &lt;code&gt;options.set_present(true).disable_interrupts(true)&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-idt-entries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-idt-entries&quot; aria-label=&quot;Anchor link for: creating-idt-entries&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating IDT Entries&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can add a function to create new IDT entries:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(gdt_selector: SegmentSelector, handler: HandlerFunc) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; pointer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; handler &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        Entry {
            gdt_selector: gdt_selector,
            pointer_low: pointer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            pointer_middle: (pointer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            pointer_high: (pointer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            options: EntryOptions::new(),
            reserved: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We take a GDT selector and a handler function as arguments and create a new IDT entry for it. The &lt;code&gt;HandlerFunc&lt;&#x2f;code&gt; type is described below. It is a function pointer that can be converted to an &lt;code&gt;u64&lt;&#x2f;code&gt;. We choose the lower 16 bits for &lt;code&gt;pointer_low&lt;&#x2f;code&gt;, the next 16 bits for &lt;code&gt;pointer_middle&lt;&#x2f;code&gt; and the remaining 32 bits for &lt;code&gt;pointer_high&lt;&#x2f;code&gt;. For the options field we choose our default options, i.e. present and disabled interrupts.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-handler-function-type&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-handler-function-type&quot; aria-label=&quot;Anchor link for: the-handler-function-type&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Handler Function Type&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;HandlerFunc&lt;&#x2f;code&gt; type is a type alias for a function type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;HandlerFunc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It needs to be a function with a defined &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;calling convention&lt;&#x2f;a&gt;, as it called directly by the hardware. The C calling convention is the de facto standard in OS development, so we&#x27;re using it, too. The function takes no arguments, since the hardware doesn&#x27;t supply any arguments when jumping to the handler function.&lt;&#x2f;p&gt;
&lt;p&gt;It is important that the function is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;functions.html#diverging-functions&quot;&gt;diverging&lt;&#x2f;a&gt;, i.e. it must never return. The reason is that the hardware doesn&#x27;t &lt;em&gt;call&lt;&#x2f;em&gt; the handler functions, it just &lt;em&gt;jumps&lt;&#x2f;em&gt; to them after pushing some values to the stack. So our stack might look different:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;catching-exceptions&#x2f;normal-vs-interrupt-function-return.svg&quot; alt=&quot;normal function return vs interrupt function return&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;If our handler function returned normally, it would try to pop the return address from the stack. But it might get some completely different value then. For example, the CPU pushes an error code for some exceptions. Bad things would happen if we interpreted this error code as return address and jumped to it. Therefore interrupt handler functions must diverge&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-must-diverge&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;.&lt;&#x2f;p&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-must-diverge&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;Another reason is that we overwrite the current register values by executing the handler function. Thus, the interrupted function looses its state and can&#x27;t proceed anyway.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;h3 id=&quot;idt-methods&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#idt-methods&quot; aria-label=&quot;Anchor link for: idt-methods&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
IDT methods&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s add a function to create new interrupt descriptor tables:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; Idt {
        Idt([Entry::missing(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;])
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;missing() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        Entry {
            gdt_selector: SegmentSelector::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, PrivilegeLevel::Ring0),
            pointer_low: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            pointer_middle: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            pointer_high: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            options: EntryOptions::minimal(),
            reserved: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;missing&lt;&#x2f;code&gt; function creates a non-present Entry. We could choose any values for the pointer and GDT selector fields as long as the present bit is not set.&lt;&#x2f;p&gt;
&lt;p&gt;However, a table with non-present entries is not very useful. So we create a &lt;code&gt;set_handler&lt;&#x2f;code&gt; method to add new handler functions:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, entry: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, handler: HandlerFunc)
        -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; EntryOptions
    {
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry::new(segmentation::cs(), handler);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;].options
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The method overwrites the specified entry with the given handler function. We use the &lt;code&gt;segmentation::cs&lt;&#x2f;code&gt; function of the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&quot;&gt;x86_64 crate&lt;&#x2f;a&gt; to get the current code segment descriptor. There&#x27;s no need for different kernel code segments in long mode, so the current &lt;code&gt;cs&lt;&#x2f;code&gt; value should be always the right choice.&lt;&#x2f;p&gt;
&lt;p&gt;By returning a mutual reference to the entry&#x27;s options, we allow the caller to override the default settings. For example, the caller could add a non-present entry by executing: &lt;code&gt;idt.set_handler(11, handler_fn).set_present(false)&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;loading-the-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-idt&quot; aria-label=&quot;Anchor link for: loading-the-idt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the IDT&lt;&#x2f;h3&gt;
&lt;p&gt;Now we&#x27;re able to create new interrupt descriptor tables with registered handler functions. We just need a way to load an IDT, so that the CPU uses it. The x86 architecture uses a special register to store the active IDT and its length. In order to load a new IDT we need to update this register through the &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;lgdt:lidt&quot;&gt;lidt&lt;&#x2f;a&gt; instruction.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;lidt&lt;&#x2f;code&gt; instruction expects a pointer to a special data structure, which specifies the start address of the IDT and its length:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type    &lt;&#x2f;th&gt;&lt;th&gt;Name    &lt;&#x2f;th&gt;&lt;th&gt;Description&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;u16     &lt;&#x2f;td&gt;&lt;td&gt;Limit   &lt;&#x2f;td&gt;&lt;td&gt;The maximum addressable byte in the table. Equal to the table size in bytes minus 1.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;u64     &lt;&#x2f;td&gt;&lt;td&gt;Offset  &lt;&#x2f;td&gt;&lt;td&gt;Virtual start address of the table.&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;This structure is already contained &lt;a href=&quot;http:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.0&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;struct.DescriptorTablePointer.html&quot;&gt;in the x86_64 crate&lt;&#x2f;a&gt;, so we don&#x27;t need to create it ourselves. The same is true for the &lt;a href=&quot;http:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.0&#x2f;x86_64&#x2f;instructions&#x2f;tables&#x2f;fn.lidt.html&quot;&gt;lidt function&lt;&#x2f;a&gt;. So we just need to put the pieces together to create a &lt;code&gt;load&lt;&#x2f;code&gt;  method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Idt {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tables::{DescriptorTablePointer, lidt};
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::mem::size_of;

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; DescriptorTablePointer {
            base: self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            limit: (size_of::&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u16&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        };

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ lidt(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ptr) };
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The method does not need to modify the IDT, so it takes &lt;code&gt;self&lt;&#x2f;code&gt; by immutable reference. First, we create a &lt;code&gt;DescriptorTablePointer&lt;&#x2f;code&gt; and then we pass it to &lt;code&gt;lidt&lt;&#x2f;code&gt;. The &lt;code&gt;lidt&lt;&#x2f;code&gt; function expects that the &lt;code&gt;base&lt;&#x2f;code&gt; field has the type &lt;code&gt;u64&lt;&#x2f;code&gt;, therefore we need to cast the &lt;code&gt;self&lt;&#x2f;code&gt; pointer. For calculating the &lt;code&gt;limit&lt;&#x2f;code&gt; we use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;mem&#x2f;fn.size_of.html&quot;&gt;mem::size_of&lt;&#x2f;a&gt;. The additional &lt;code&gt;-1&lt;&#x2f;code&gt; is needed because the limit field has to be the maximum addressable byte (inclusive bound). We need an unsafe block around &lt;code&gt;lidt&lt;&#x2f;code&gt;, because the function assumes that the specified handler addresses are valid.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h4&gt;
&lt;p&gt;But can we really guarantee that handler addresses are always valid? Let&#x27;s see:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Idt::new&lt;&#x2f;code&gt; function creates a new table populated with non-present entries. There&#x27;s no way to set these entries to present from outside of this module, so this function is fine.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;set_handler&lt;&#x2f;code&gt; method allows us to overwrite a specified entry and point it to some handler function. Rust&#x27;s type system guarantees that function pointers are always valid (as long as no &lt;code&gt;unsafe&lt;&#x2f;code&gt; is involved), so this function is fine, too.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;There are no other public functions in the &lt;code&gt;idt&lt;&#x2f;code&gt; module (except &lt;code&gt;load&lt;&#x2f;code&gt;), so it should be safeâ€¦ right?&lt;&#x2f;p&gt;
&lt;p&gt;Wrong! Imagine the following scenario:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    load_idt();
    cause_page_fault();
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load_idt() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();
    idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, page_fault_handler);
    idt.load();
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cause_page_fault() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This won&#x27;t work. If we&#x27;re lucky, we get a triple fault and a boot loop. If we&#x27;re unlucky, our kernel does strange things and fails at some completely unrelated place. So what&#x27;s the problem here?&lt;&#x2f;p&gt;
&lt;p&gt;Well, we construct an IDT &lt;em&gt;on the stack&lt;&#x2f;em&gt; and load it. It is perfectly valid until the end of the &lt;code&gt;load_idt&lt;&#x2f;code&gt; function. But as soon as the function returns, its stack frame can be reused by other functions. Thus, the IDT gets overwritten by the stack frame of the &lt;code&gt;cause_page_fault&lt;&#x2f;code&gt; function. So when the page fault occurs and the CPU tries to read the entry, it only sees some garbage values and issues a double fault, which escalates to a triple fault and a CPU reset.&lt;&#x2f;p&gt;
&lt;p&gt;Now imagine that the &lt;code&gt;cause_page_fault&lt;&#x2f;code&gt; function declared an array of pointers instead. If the present was coincidentally set, the CPU would jump to some random pointer and interpret random memory as code. This would be a clear violation of memory safety.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;fixing-the-load-method&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-load-method&quot; aria-label=&quot;Anchor link for: fixing-the-load-method&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing the load method&lt;&#x2f;h4&gt;
&lt;p&gt;So how do we fix it? We could make the load function itself &lt;code&gt;unsafe&lt;&#x2f;code&gt; and push the unsafety to the caller. However, there is a much better solution in this case. In order to see it, we formulate the requirement for the &lt;code&gt;load&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The referenced IDT must be valid until a new IDT is loaded.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;We can&#x27;t know when the next IDT will be loaded. Maybe never. So in the worst case:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The referenced IDT must be valid as long as our kernel runs.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;This is exactly the definition of a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;scope&#x2f;lifetime&#x2f;static_lifetime.html&quot;&gt;static lifetime&lt;&#x2f;a&gt;. So we can easily ensure that the IDT lives long enough by adding a &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; requirement to the signature of the &lt;code&gt;load&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;load(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;           ^^^^^^^ ensure that the IDT reference has the &amp;#39;static lifetime
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;That&#x27;s it! Now the Rust compiler ensures that the above error can&#x27;t happen anymore:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: `idt` does not live long enough
  --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:78:5
78 |&amp;gt;     idt.load();
   |&amp;gt;     ^^^
note: reference must be valid for the static lifetime...
note: ...but borrowed value is only valid for the block suffix following
          statement 0 at 75:34
  --&amp;gt; src&#x2f;interrupts&#x2f;mod.rs:75:35
75 |&amp;gt;     let mut idt = idt::Idt::new();
   |&amp;gt;                                   ^
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;a-static-idt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-static-idt&quot; aria-label=&quot;Anchor link for: a-static-idt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A static IDT&lt;&#x2f;h3&gt;
&lt;p&gt;So a valid IDT needs to have the &lt;code&gt;&#x27;static&lt;&#x2f;code&gt; lifetime. We can either create a &lt;code&gt;static&lt;&#x2f;code&gt; IDT or &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html#method.into_raw&quot;&gt;deliberately leak a Box&lt;&#x2f;a&gt;. We will most likely only need a single IDT for the foreseeable future, so let&#x27;s try the &lt;code&gt;static&lt;&#x2f;code&gt; approach:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();

    idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, divide_by_zero_handler);

    idt
};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero_handler() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;EXCEPTION: DIVIDE BY ZERO&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We register a single handler function for a &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Divide-by-zero_Error&quot;&gt;divide by zero error&lt;&#x2f;a&gt; (index 0). Like the name says, this exception occurs when dividing a number by 0. Thus we have an easy way to test our new exception handler.&lt;&#x2f;p&gt;
&lt;p&gt;However, it doesn&#x27;t work this way:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: calls in statics are limited to constant functions, struct and enum
       constructors [E0015]
...
error: blocks in statics are limited to items and tail expressions [E0016]
...
error: references in statics may only refer to immutable values [E0017]
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason is that the Rust compiler is not able to evaluate the value of the &lt;code&gt;static&lt;&#x2f;code&gt; at compile time. Maybe it will work someday when &lt;code&gt;const&lt;&#x2f;code&gt; functions become more powerful. But until then, we have to find another solution.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;lazy-statics-to-the-rescue&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#lazy-statics-to-the-rescue&quot; aria-label=&quot;Anchor link for: lazy-statics-to-the-rescue&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Lazy Statics to the Rescue&lt;&#x2f;h4&gt;
&lt;p&gt;Fortunately the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; macro exists. Instead of evaluating a &lt;code&gt;static&lt;&#x2f;code&gt; at compile time, the macro performs the initialization when the &lt;code&gt;static&lt;&#x2f;code&gt; is referenced the first time. Thus, we can do almost everything in the initialization block and are even able to read runtime values.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add the &lt;code&gt;lazy_static&lt;&#x2f;code&gt; crate to our project:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; lazy_static;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies.lazy_static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.2.1&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;features &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;spin_no_std&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need the &lt;code&gt;spin_no_std&lt;&#x2f;code&gt; feature, since we don&#x27;t link the standard library.&lt;&#x2f;p&gt;
&lt;p&gt;With &lt;code&gt;lazy_static&lt;&#x2f;code&gt;, we can define our IDT without problems:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lazy_static! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static ref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: idt::Idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; idt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;idt::Idt::new();

        idt.set_handler(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, divide_by_zero_handler);

        idt
    };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we&#x27;re ready to load our IDT! Therefore we add a &lt;code&gt;interrupts::init&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;interrupts&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IDT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.load();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We don&#x27;t need our &lt;code&gt;assert_has_not_been_called&lt;&#x2f;code&gt; macro here, since nothing bad happens when &lt;code&gt;init&lt;&#x2f;code&gt; is called twice. It just reloads the same IDT again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h2&gt;
&lt;p&gt;Now we should be able to catch page faults! Let&#x27;s try it in our &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(...) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init(boot_info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize our IDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;interrupts::init();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; provoke a divide-by-zero fault
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, we get a runtime panic:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PANIC in src&#x2f;lib.rs at line 57:
    attempted to divide by zero
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;That&#x27;s a not our exception handler. The reason is that Rust itself checks for a possible division by zero and panics in that case. So in order to raise a divide-by-zero error in the CPU, we need to bypass the Rust compiler somehow.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;inline-assembly&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#inline-assembly&quot; aria-label=&quot;Anchor link for: inline-assembly&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Inline Assembly&lt;&#x2f;h3&gt;
&lt;p&gt;In order to cause a divide-by-zero exception, we need to execute a &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;div&quot;&gt;div&lt;&#x2f;a&gt; or &lt;a href=&quot;https:&#x2f;&#x2f;www.felixcloutier.com&#x2f;x86&#x2f;idiv&quot;&gt;idiv&lt;&#x2f;a&gt; assembly instruction with operand 0. We could write a small assembly function and call it from our Rust code. An easier way is to use Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;book&#x2f;inline-assembly.html&quot;&gt;inline assembly&lt;&#x2f;a&gt; macro.&lt;&#x2f;p&gt;
&lt;p&gt;Inline assembly allows us to write raw x86 assembly within a Rust function. The feature is unstable, so we need to add &lt;code&gt;#![feature(asm)]&lt;&#x2f;code&gt; to our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;. Then we&#x27;re able to write a &lt;code&gt;divide_by_zero&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        asm!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mov dx, 0; div dx&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ax&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;dx&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;volatile&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;intel&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s try to decode it:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;asm!&lt;&#x2f;code&gt; macro emits raw assembly instructions, so it&#x27;s &lt;code&gt;unsafe&lt;&#x2f;code&gt; to use it.&lt;&#x2f;li&gt;
&lt;li&gt;We insert two assembly instructions here: &lt;code&gt;mov dx, 0&lt;&#x2f;code&gt; and &lt;code&gt;div dx&lt;&#x2f;code&gt;. The former loads a 0 into the &lt;code&gt;dx&lt;&#x2f;code&gt; register (a subset of &lt;code&gt;rdx&lt;&#x2f;code&gt;) and the latter divides the &lt;code&gt;ax&lt;&#x2f;code&gt; register by &lt;code&gt;dx&lt;&#x2f;code&gt;. (The &lt;code&gt;div&lt;&#x2f;code&gt; instruction always implicitly operates on the &lt;code&gt;ax&lt;&#x2f;code&gt; register).&lt;&#x2f;li&gt;
&lt;li&gt;The colons are separators. After the first &lt;code&gt;:&lt;&#x2f;code&gt; we could specify output operands and after the second &lt;code&gt;:&lt;&#x2f;code&gt; we could specify input operands. We need neither, so we leave these areas empty.&lt;&#x2f;li&gt;
&lt;li&gt;After the third colon, we specify the so-called &lt;em&gt;clobbers&lt;&#x2f;em&gt;. These tell the compiler that our assembly modifies the values of some registers. Otherwise, the compiler assumes that the registers preserve their value. In our case, we clobber &lt;code&gt;dx&lt;&#x2f;code&gt; (we load 0 to it) and &lt;code&gt;ax&lt;&#x2f;code&gt; (the &lt;code&gt;div&lt;&#x2f;code&gt; instruction places the result in it).&lt;&#x2f;li&gt;
&lt;li&gt;The last block (after the 4th colon) specifies some options. The &lt;code&gt;volatile&lt;&#x2f;code&gt; option tells the compiler: â€œThis code has side effects. Do not delete it and do not move it elsewhereâ€. In our case, the â€œside effectâ€ is the divide-by-zero exception. Finally, the &lt;code&gt;intel&lt;&#x2f;code&gt; option allows us to use the Intel assembly syntax instead of the default AT&amp;amp;T syntax.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Let&#x27;s use our new &lt;code&gt;divide_by_zero&lt;&#x2f;code&gt; function to raise a CPU exception:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(...) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; provoke a divide-by-zero fault
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;divide_by_zero();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It works! We see a &lt;code&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2f;code&gt; message at the bottom of our screen:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;catching-exceptions&#x2f;qemu-divide-error-println.png&quot; alt=&quot;QEMU screenshot with EXCEPTION: DIVIDE BY ZERO message&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;We&#x27;ve successfully caught our first exception! However, our &lt;code&gt;EXCEPTION: DIVIDE BY ZERO&lt;&#x2f;code&gt; message doesn&#x27;t contain much information about the cause of the exception. The next post improves the situation by printing i.a. the current stack pointer and address of the causing instruction. We will also explore other exceptions such as page faults, for which the CPU pushes an &lt;em&gt;error code&lt;&#x2f;em&gt; on the stack.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Kernel Heap</title>
                <pubDate>Mon, 11 Apr 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/kernel-heap/</link>
                <guid>https://os.phil-opp.com/kernel-heap/</guid>
                <description>&lt;p&gt;In the previous posts we created a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;&quot;&gt;frame allocator&lt;&#x2f;a&gt; and a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;page table module&lt;&#x2f;a&gt;. Now we are ready to create a kernel heap and a memory allocator. Thus, we will unlock &lt;code&gt;Box&lt;&#x2f;code&gt;, &lt;code&gt;Vec&lt;&#x2f;code&gt;, &lt;code&gt;BTreeMap&lt;&#x2f;code&gt;, and the rest of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;alloc&#x2f;index.html&quot;&gt;alloc&lt;&#x2f;a&gt; crate.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, you can find the complete source code on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_8&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;issues&lt;&#x2f;a&gt; for any problems, questions, or improvement suggestions. There is also a comment section at the end of this page.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;introduction&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#introduction&quot; aria-label=&quot;Anchor link for: introduction&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Introduction&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;em&gt;heap&lt;&#x2f;em&gt; is the memory area for long-lived allocations. The programmer can access it by using types like &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;std&#x2f;box.html&quot;&gt;Box&lt;&#x2f;a&gt; or &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;vectors.html&quot;&gt;Vec&lt;&#x2f;a&gt;. Behind the scenes, the compiler manages that memory by inserting calls to some memory allocator. By default, Rust links to the &lt;a href=&quot;http:&#x2f;&#x2f;jemalloc.net&#x2f;&quot;&gt;jemalloc&lt;&#x2f;a&gt; allocator (for binaries) or the system allocator (for libraries). However, both rely on &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;System_call&quot;&gt;system calls&lt;&#x2f;a&gt; such as &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Sbrk&quot;&gt;sbrk&lt;&#x2f;a&gt; and are thus unusable in our kernel. So we need to create and link our own allocator.&lt;&#x2f;p&gt;
&lt;p&gt;A good allocator is fast and reliable. It also effectively utilizes the available memory and keeps &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Fragmentation_(computing)&quot;&gt;fragmentation&lt;&#x2f;a&gt; low. Furthermore, it works well for concurrent applications and scales to any number of processors. It even optimizes the memory layout with respect to the CPU caches to improve &lt;a href=&quot;http:&#x2f;&#x2f;docs.cray.com&#x2f;books&#x2f;S-2315-50&#x2f;html-S-2315-50&#x2f;qmeblljm.html&quot;&gt;cache locality&lt;&#x2f;a&gt; and avoid &lt;a href=&quot;http:&#x2f;&#x2f;mechanical-sympathy.blogspot.de&#x2f;2011&#x2f;07&#x2f;false-sharing.html&quot;&gt;false sharing&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;These requirements make good allocators pretty complex. For example, &lt;a href=&quot;http:&#x2f;&#x2f;jemalloc.net&#x2f;&quot;&gt;jemalloc&lt;&#x2f;a&gt; has over 30.000 lines of code. This complexity is out of scope for our kernel, so we will create a much simpler allocator. Nevertheless, it should suffice for the foreseeable future, since we&#x27;ll allocate only when it&#x27;s absolutely necessary.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-allocator-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator-interface&quot; aria-label=&quot;Anchor link for: the-allocator-interface&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Allocator Interface&lt;&#x2f;h2&gt;
&lt;p&gt;The allocator interface in Rust is defined through the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.20.0&#x2f;alloc&#x2f;allocator&#x2f;trait.Alloc.html&quot;&gt;&lt;code&gt;Alloc&lt;&#x2f;code&gt; trait&lt;&#x2f;a&gt;, which looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Alloc {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, AllocErr&amp;gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout);
    [â€¦] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; about 13 methods with default implementations
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;alloc&lt;&#x2f;code&gt; method should allocate a memory block with the size and alignment given through &lt;code&gt;Layout&lt;&#x2f;code&gt; parameter. The &lt;code&gt;deallocate&lt;&#x2f;code&gt; method should free such memory blocks again. Both methods are &lt;code&gt;unsafe&lt;&#x2f;code&gt;, as is the trait itself. This has different reasons:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the &lt;code&gt;Alloc&lt;&#x2f;code&gt; trait is unsafe, because the implementation must satisfy a set of contracts. Among other things, pointers returned by &lt;code&gt;alloc&lt;&#x2f;code&gt; must point to valid memory and adhere to the &lt;code&gt;Layout&lt;&#x2f;code&gt; requirements.&lt;&#x2f;li&gt;
&lt;li&gt;Calling &lt;code&gt;alloc&lt;&#x2f;code&gt; is unsafe because the caller must ensure that the passed layout does not have size zero. I think this is because of compatibility reasons with existing C-allocators, where zero-sized allocations are undefined behavior.&lt;&#x2f;li&gt;
&lt;li&gt;Calling &lt;code&gt;dealloc&lt;&#x2f;code&gt; is unsafe because the caller must guarantee that the passed parameters adhere to the contract. For example, &lt;code&gt;ptr&lt;&#x2f;code&gt; must denote a valid memory block allocated via this allocator.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;To set the system allocator, the &lt;code&gt;global_allocator&lt;&#x2f;code&gt; attribute can be added to a &lt;code&gt;static&lt;&#x2f;code&gt; that implements &lt;code&gt;Alloc&lt;&#x2f;code&gt; for a shared reference of itself. For example:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;MY_ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: MyAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MyAllocator {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; Alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;MyAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, AllocErr&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that &lt;code&gt;Alloc&lt;&#x2f;code&gt; needs to be implemented for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2f;code&gt;, not for &lt;code&gt;MyAllocator&lt;&#x2f;code&gt;. The reason is that the &lt;code&gt;alloc&lt;&#x2f;code&gt; and &lt;code&gt;dealloc&lt;&#x2f;code&gt; methods require mutable &lt;code&gt;self&lt;&#x2f;code&gt; references, but there&#x27;s no way to get such a reference safely from a &lt;code&gt;static&lt;&#x2f;code&gt;. By requiring implementations for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2f;code&gt;, the global allocator interface avoids this problem and pushes the burden of synchronization onto the user.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;including-the-alloc-crate&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#including-the-alloc-crate&quot; aria-label=&quot;Anchor link for: including-the-alloc-crate&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Including the alloc crate&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;code&gt;Alloc&lt;&#x2f;code&gt; trait is part of the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate, which like &lt;code&gt;core&lt;&#x2f;code&gt; is a subset of Rust&#x27;s standard library. Apart from the trait, the crate also contains the standard types that require allocations such as &lt;code&gt;Box&lt;&#x2f;code&gt;, &lt;code&gt;Vec&lt;&#x2f;code&gt; and &lt;code&gt;Arc&lt;&#x2f;code&gt;. We can include it through a simple &lt;code&gt;extern crate&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(alloc)] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the alloc crate is still unstable

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We don&#x27;t need to add anything to our Cargo.toml, since the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate is part of the standard library and shipped with the Rust compiler. The &lt;code&gt;alloc&lt;&#x2f;code&gt; crate provides the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;macro.format!.html&quot;&gt;format!&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;macro.vec!.html&quot;&gt;vec!&lt;&#x2f;a&gt; macros, so we use &lt;code&gt;#[macro_use]&lt;&#x2f;code&gt; to import them.&lt;&#x2f;p&gt;
&lt;p&gt;When we try to compile our crate now, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0463]: can&amp;#39;t find crate for `alloc`
  --&amp;gt; src&#x2f;lib.rs:10:1
   |
16 | extern crate alloc;
   | ^^^^^^^^^^^^^^^^^^^ can&amp;#39;t find crate
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The problem is that &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;japaric&#x2f;xargo&quot;&gt;&lt;code&gt;xargo&lt;&#x2f;code&gt;&lt;&#x2f;a&gt; only cross compiles &lt;code&gt;libcore&lt;&#x2f;code&gt; by default. To also cross compile the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate, we need to create a file named &lt;code&gt;Xargo.toml&lt;&#x2f;code&gt; in our project root (right next to the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;) with the following content:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;target.x86_64-blog_os.dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= {}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This instructs &lt;code&gt;xargo&lt;&#x2f;code&gt; that we also need &lt;code&gt;alloc&lt;&#x2f;code&gt;. It still doesn&#x27;t compile, since we need to define a global allocator in order to use the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: no #[default_lib_allocator] found but one is required; is libstd not linked?
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;a-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-bump-allocator&quot; aria-label=&quot;Anchor link for: a-bump-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Bump Allocator&lt;&#x2f;h2&gt;
&lt;p&gt;For our first allocator, we start simple. We create a &lt;code&gt;memory::heap_allocator&lt;&#x2f;code&gt; module containing a so-called &lt;em&gt;bump allocator&lt;&#x2f;em&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;heap_allocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;heap_allocator.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::heap::{Alloc, AllocErr, Layout};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; A simple allocator that allocates memory linearly and ignores freed memory.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    heap_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    heap_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    next: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(heap_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, heap_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ heap_start, heap_end, next: heap_start }
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, AllocErr&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;align_up(self.next, layout.align());
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_start.saturating_add(layout.size());

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.heap_end {
            self.next &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_end;
            Ok(alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
        } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            Err(AllocErr::Exhausted{ request: layout })
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; do nothing, leak memory
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We also need to add &lt;code&gt;#![feature(allocator_api)]&lt;&#x2f;code&gt; to our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, since the allocator API is still unstable.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;heap_start&lt;&#x2f;code&gt; and &lt;code&gt;heap_end&lt;&#x2f;code&gt; fields contain the start and end address of our kernel heap. The &lt;code&gt;next&lt;&#x2f;code&gt; field contains the next free address and is increased after every allocation. To &lt;code&gt;allocate&lt;&#x2f;code&gt; a memory block we align the &lt;code&gt;next&lt;&#x2f;code&gt; address using the &lt;code&gt;align_up&lt;&#x2f;code&gt; function (described below). Then we add up the desired &lt;code&gt;size&lt;&#x2f;code&gt; and make sure that we don&#x27;t exceed the end of the heap. We use a saturating add so that the &lt;code&gt;alloc_end&lt;&#x2f;code&gt; cannot overflow, which could lead to an invalid allocation. If everything goes well, we update the &lt;code&gt;next&lt;&#x2f;code&gt; address and return a pointer to the start address of the allocation. Else, we return &lt;code&gt;None&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;alignment&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#alignment&quot; aria-label=&quot;Anchor link for: alignment&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Alignment&lt;&#x2f;h3&gt;
&lt;p&gt;In order to simplify alignment, we add &lt;code&gt;align_down&lt;&#x2f;code&gt; and &lt;code&gt;align_up&lt;&#x2f;code&gt; functions:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Align downwards. Returns the greatest x with alignment `align`
&#x2f;&#x2f;&#x2f; so that x &amp;lt;= addr. The alignment must be a power of 2.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;align_down(addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, align: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; align.is_power_of_two() {
        addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(align &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; align &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        addr
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;`align` must be a power of 2&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Align upwards. Returns the smallest x with alignment `align`
&#x2f;&#x2f;&#x2f; so that x &amp;gt;= addr. The alignment must be a power of 2.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;align_up(addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, align: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    align_down(addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; align &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, align)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s start with &lt;code&gt;align_down&lt;&#x2f;code&gt;: If the alignment is a valid power of two (i.e. in &lt;code&gt;{1,2,4,8,â€¦}&lt;&#x2f;code&gt;), we use some bitwise operations to return the aligned address. It works because every power of two has exactly one bit set in its binary representation. For example, the numbers &lt;code&gt;{1,2,4,8,â€¦}&lt;&#x2f;code&gt; are &lt;code&gt;{1,10,100,1000,â€¦}&lt;&#x2f;code&gt; in binary. By subtracting 1 we get &lt;code&gt;{0,01,011,0111,â€¦}&lt;&#x2f;code&gt;. These binary numbers have a &lt;code&gt;1&lt;&#x2f;code&gt; at exactly the positions that need to be zeroed in &lt;code&gt;addr&lt;&#x2f;code&gt;. For example, the last 3 bits need to be zeroed for a alignment of 8.&lt;&#x2f;p&gt;
&lt;p&gt;To align &lt;code&gt;addr&lt;&#x2f;code&gt;, we create a &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Mask_(computing)&quot;&gt;bitmask&lt;&#x2f;a&gt; from &lt;code&gt;align-1&lt;&#x2f;code&gt;. We want a &lt;code&gt;0&lt;&#x2f;code&gt; at the position of each &lt;code&gt;1&lt;&#x2f;code&gt;, so we invert it using &lt;code&gt;!&lt;&#x2f;code&gt;. After that, the binary numbers look like this: &lt;code&gt;{â€¦11111,â€¦11110,â€¦11100,â€¦11000,â€¦}&lt;&#x2f;code&gt;. Finally, we zero the correct bits using a binary &lt;code&gt;AND&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Aligning upwards is simple now. We just increase &lt;code&gt;addr&lt;&#x2f;code&gt; by &lt;code&gt;align-1&lt;&#x2f;code&gt; and call &lt;code&gt;align_down&lt;&#x2f;code&gt;. We add &lt;code&gt;align-1&lt;&#x2f;code&gt; instead of &lt;code&gt;align&lt;&#x2f;code&gt; because we would otherwise waste &lt;code&gt;align&lt;&#x2f;code&gt; bytes for already aligned addresses.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;reusing-freed-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#reusing-freed-memory&quot; aria-label=&quot;Anchor link for: reusing-freed-memory&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Reusing Freed Memory&lt;&#x2f;h3&gt;
&lt;p&gt;The heap memory is limited, so we should reuse freed memory for new allocations. This sounds simple, but is not so easy in practice since allocations can live arbitrarily long (and can be freed in an arbitrary order). This means that we need some kind of data structure to keep track of which memory areas are free and which are in use. This data structure should be very optimized since it causes overheads in both space (i.e. it needs backing memory) and time (i.e. accessing and organizing it needs CPU cycles).&lt;&#x2f;p&gt;
&lt;p&gt;Our bump allocator only keeps track of the next free memory address, which doesn&#x27;t suffice to keep track of freed memory areas. So our only choice is to ignore deallocations and leak the corresponding memory. Thus our allocator quickly runs out of memory in a real system, but it suffices for simple testing. Later in this post, we will introduce a better allocator that does not leak freed memory.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;using-it-as-system-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-it-as-system-allocator&quot; aria-label=&quot;Anchor link for: using-it-as-system-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using it as System Allocator&lt;&#x2f;h3&gt;
&lt;p&gt;Above we saw that we can use a static allocator as system allocator through the &lt;code&gt;global_allocator&lt;&#x2f;code&gt; attribute:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: MyAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MyAllocator {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This requires an implementation of &lt;code&gt;Alloc&lt;&#x2f;code&gt; for &lt;code&gt;&amp;amp;MyAllocator&lt;&#x2f;code&gt;, i.e. a shared reference. If we try to add such an implementation for our bump allocator (&lt;code&gt;unsafe impl&amp;lt;&#x27;a&amp;gt; Alloc for &amp;amp;&#x27;a BumpAllocator&lt;&#x2f;code&gt;), we have a problem: Our &lt;code&gt;alloc&lt;&#x2f;code&gt; method requires updating the &lt;code&gt;next&lt;&#x2f;code&gt; field, which is not possible for a shared reference.&lt;&#x2f;p&gt;
&lt;p&gt;One solution could be to put the bump allocator behind a Mutex and wrap it into a new type, for which we can implement &lt;code&gt;Alloc&lt;&#x2f;code&gt; for a shared reference:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;LockedBumpAllocator(Mutex&amp;lt;BumpAllocator&amp;gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; Alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;LockedBumpAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, AllocErr&amp;gt; {
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lock().alloc(layout)
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout) {
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;lock().dealloc(ptr, layout)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, there is a more interesting solution for our bump allocator that avoids locking altogether. The idea is to exploit that we only need to update a single &lt;code&gt;usize&lt;&#x2f;code&gt; field byusing an &lt;code&gt;AtomicUsize&lt;&#x2f;code&gt; type. This type uses special synchronized hardware instructions to ensure data race freedom without requiring locks.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;a-lock-free-bump-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-lock-free-bump-allocator&quot; aria-label=&quot;Anchor link for: a-lock-free-bump-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A lock-free Bump Allocator&lt;&#x2f;h4&gt;
&lt;p&gt;A lock-free implementation looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::sync::atomic::{AtomicUsize, Ordering};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; A simple allocator that allocates memory linearly and ignores freed memory.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    heap_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    heap_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    next: AtomicUsize,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(heap_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, heap_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; NOTE: requires adding #![feature(const_atomic_usize_new)] to lib.rs
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;Self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ heap_start, heap_end, next: AtomicUsize::new(heap_start) }
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; Alloc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &amp;amp;&amp;#39;a &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, layout: Layout) -&amp;gt; Result&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, AllocErr&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; load current state of the `next` field
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; current_next &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next.load(Ordering::Relaxed);
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;align_up(current_next, layout.align());
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_start.saturating_add(layout.size());

            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; alloc_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.heap_end {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; update the `next` pointer if it still has the value `current_next`
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; next_now &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next.compare_and_swap(current_next, alloc_end,
                    Ordering::Relaxed);
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; next_now &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;==&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; current_next {
                    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; next address was successfully updated, allocation succeeded
                    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Ok(alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                }
            } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Err(AllocErr::Exhausted{ request: layout })
            }
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dealloc(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, ptr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, layout: Layout) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; do nothing, leak memory
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The implementation is a bit more complicated now. First, there is now a &lt;code&gt;loop&lt;&#x2f;code&gt; around the whole method body, since we might need multiple tries until we succeed (e.g. if multiple threads try to allocate at the same time). Also, the loads operation is an explicit method call now, i.e. &lt;code&gt;self.next.load(Ordering::Relaxed)&lt;&#x2f;code&gt; instead of just &lt;code&gt;self.next&lt;&#x2f;code&gt;. The ordering parameter makes it possible to restrict the automatic instruction reordering performed by both the compiler and the CPU itself. For example, it is used when implementing locks to ensure that no write to the locked variable happens before the lock is acquired. We don&#x27;t have such requirements, so we use the less restrictive &lt;code&gt;Relaxed&lt;&#x2f;code&gt; ordering.&lt;&#x2f;p&gt;
&lt;p&gt;The heart of this lock-free method is the &lt;code&gt;compare_and_swap&lt;&#x2f;code&gt; call that updates the &lt;code&gt;next&lt;&#x2f;code&gt; address:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;...
let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; next_now &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next.compare_and_swap(current_next, alloc_end,
    Ordering::Relaxed);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; next_now &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;==&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; current_next {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; next address was successfully updated, allocation succeeded
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Ok(alloc_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Compare-and-swap is a special CPU instruction that updates a variable with a given value if it still contains the value we expect. If it doesn&#x27;t, it means that another thread updated the value simultaneously, so we need to try again. The important feature is that this happens in a single uninteruptible operation (thus the name &lt;code&gt;atomic&lt;&#x2f;code&gt;), so no partial updates or intermediate states are possible.&lt;&#x2f;p&gt;
&lt;p&gt;In detail, &lt;code&gt;compare_and_swap&lt;&#x2f;code&gt; works by comparing &lt;code&gt;next&lt;&#x2f;code&gt; with the first argument and, in case they&#x27;re equal, updates &lt;code&gt;next&lt;&#x2f;code&gt; with the second parameter (the previous value is returned). To find out whether a switch happened, we check the returned previous value of &lt;code&gt;next&lt;&#x2f;code&gt;. If it is equal to the first parameter, the values were swapped. Otherwise, we try again in the next loop iteration.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;setting-the-global-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#setting-the-global-allocator&quot; aria-label=&quot;Anchor link for: setting-the-global-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Setting the Global Allocator&lt;&#x2f;h4&gt;
&lt;p&gt;Now we can define a static bump allocator, that we can set as system allocator:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o_000_001_000_000_0000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;100 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1024&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; 100 KiB

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: BumpAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BumpAllocator::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use &lt;code&gt;0o_000_001_000_000_0000&lt;&#x2f;code&gt; as heap start address, which is the address starting at the second &lt;code&gt;P3&lt;&#x2f;code&gt; entry. It doesn&#x27;t really matter which address we choose here as long as it&#x27;s unused. We use a heap size of 100 KiB, which should be large enough for the near future.&lt;&#x2f;p&gt;
&lt;p&gt;Putting the above in the &lt;code&gt;memory::heap_allocator&lt;&#x2f;code&gt; module would make most sense, but unfortunately there is currently a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;44113&quot;&gt;weird bug&lt;&#x2f;a&gt; in the global allocator implementation that requires putting the global allocator in the root module. I hope it&#x27;s fixed soon, but until then we need to put the above lines in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;. For that, we need to make the &lt;code&gt;memory::heap_allocator&lt;&#x2f;code&gt; module public and add an import for &lt;code&gt;BumpAllocator&lt;&#x2f;code&gt;. We also need to add the &lt;code&gt;#![feature(global_allocator)]&lt;&#x2f;code&gt; at the top of our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, since the &lt;code&gt;global_allocator&lt;&#x2f;code&gt; attribute is still unstable.&lt;&#x2f;p&gt;
&lt;p&gt;That&#x27;s it! We have successfully created and linked a custom system allocator. Now we&#x27;re ready to test it.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing&quot; aria-label=&quot;Anchor link for: testing&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing&lt;&#x2f;h3&gt;
&lt;p&gt;We should be able to allocate memory on the heap now. Let&#x27;s try it in our &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we run it, a triple fault occurs and causes permanent rebooting. Let&#x27;s try debug it using QEMU and objdump as described &lt;a href=&quot;http:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel.html#debugging&quot;&gt;in the previous post&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 -d int -no-reboot -cdrom build&#x2f;os-x86_64.iso
â€¦
check_exception old: 0xffffffff new 0xe
     0: v=0e e=0002 i=0 cpl=0 IP=0008:0000000000102860 pc=0000000000102860
        SP=0010:0000000000116af0 CR2=0000000040000000
â€¦
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Aha! It&#x27;s a &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Page_Fault&quot;&gt;page fault&lt;&#x2f;a&gt; (&lt;code&gt;v=0e&lt;&#x2f;code&gt;) and was caused by the code at &lt;code&gt;0x102860&lt;&#x2f;code&gt;. The code tried to write (&lt;code&gt;e=0002&lt;&#x2f;code&gt;) to address &lt;code&gt;0x40000000&lt;&#x2f;code&gt;. This address is &lt;code&gt;0o_000_001_000_000_0000&lt;&#x2f;code&gt; in octal, which is the &lt;code&gt;HEAP_START&lt;&#x2f;code&gt; address defined above. Of course it page-faults: We have forgotten to map the heap memory to some physical memory.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;some-refactoring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-refactoring&quot; aria-label=&quot;Anchor link for: some-refactoring&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Some Refactoring&lt;&#x2f;h3&gt;
&lt;p&gt;In order to map the heap cleanly, we do a bit of refactoring first. We move all memory initialization from our &lt;code&gt;rust_main&lt;&#x2f;code&gt; to a new &lt;code&gt;memory::init&lt;&#x2f;code&gt; function. Now our &lt;code&gt;rust_main&lt;&#x2f;code&gt; looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; ATTENTION: we have a very small stack and no guard page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer::clear_screen();
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        multiboot2::load(multiboot_information_address)
    };
    enable_nxe_bit();
    enable_write_protect_bit();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; set up guard page and map the heap pages
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init(boot_info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;memory::init&lt;&#x2f;code&gt; function looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;multiboot2::BootInformation;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.memory_map_tag().expect(
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.elf_sections_tag().expect(
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf sections tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections()
        .filter(|s| s.is_allocated()).map(|s| s.addr).min().unwrap();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections()
        .filter(|s| s.is_allocated()).map(|s| s.addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.size).max()
        .unwrap();

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, kernel end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
             kernel_start,
             kernel_end);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;multiboot start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, multiboot end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
             boot_info.start_address(),
             boot_info.end_address());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;AreaFrameAllocator::new(
        kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        boot_info.start_address(), boot_info.end_address(),
        memory_map_tag.memory_areas());

    paging::remap_the_kernel(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator, boot_info);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We&#x27;ve just moved the code to a new function. However, we&#x27;ve sneaked some improvements in:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;An additional &lt;code&gt;.filter(|s| s.is_allocated())&lt;&#x2f;code&gt; in the calculation of &lt;code&gt;kernel_start&lt;&#x2f;code&gt; and &lt;code&gt;kernel_end&lt;&#x2f;code&gt;. This ignores all sections that aren&#x27;t loaded to memory (such as debug sections). Thus, the kernel end address is no longer artificially increased by such sections.&lt;&#x2f;li&gt;
&lt;li&gt;We use the &lt;code&gt;start_address()&lt;&#x2f;code&gt; and &lt;code&gt;end_address()&lt;&#x2f;code&gt; methods of &lt;code&gt;boot_info&lt;&#x2f;code&gt; instead of calculating the adresses manually.&lt;&#x2f;li&gt;
&lt;li&gt;We use the alternate &lt;code&gt;{:#x}&lt;&#x2f;code&gt; form when printing kernel&#x2f;multiboot addresses. Before, we used &lt;code&gt;0x{:x}&lt;&#x2f;code&gt;, which leads to the same result. For a complete list of these â€œalternateâ€ formatting forms, check out the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;fmt&#x2f;index.html#sign0&quot;&gt;std::fmt documentation&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h3&gt;
&lt;p&gt;It is important that the &lt;code&gt;memory::init&lt;&#x2f;code&gt; function is called only once, because it creates a new frame allocator based on kernel and multiboot start&#x2f;end. When we call it a second time, a new frame allocator is created that reassigns the same frames, even if they are already in use.&lt;&#x2f;p&gt;
&lt;p&gt;In the second call it would use an identical frame allocator to remap the kernel. The &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; function would request a frame from the frame allocator to create a new page table. But the returned frame is already in use, since we used it to create our current page table in the first call. In order to initialize the new table, the function zeroes it. This is the point where everything breaks, since we zero our current page table. The CPU is unable to read the next instruction  and throws a page fault.&lt;&#x2f;p&gt;
&lt;p&gt;So we need to ensure that &lt;code&gt;memory::init&lt;&#x2f;code&gt; can be only called once. We could mark it as &lt;code&gt;unsafe&lt;&#x2f;code&gt;, which would bring it in line with Rust&#x27;s memory safety rules. However, that would just push the unsafety to the caller. The caller can still accidentally call the function twice, the only difference is that the mistake needs to happen inside &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks.&lt;&#x2f;p&gt;
&lt;p&gt;A better solution is to insert a check at the function&#x27;s beginning, that panics if the function is called a second time. This approach has a small runtime cost, but we only call it once, so it&#x27;s negligible. And we avoid two &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks (one at the calling site and one at the function itself), which is always good.&lt;&#x2f;p&gt;
&lt;p&gt;In order to make such checks easy, I created a small crate named &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;once&quot;&gt;once&lt;&#x2f;a&gt;. To add it, we run &lt;code&gt;cargo add once&lt;&#x2f;code&gt; and add the following to our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; once;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The crate provides an &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;once&#x2f;0.3.2&#x2f;once&#x2f;macro.assert_has_not_been_called!.html&quot;&gt;assert_has_not_been_called!&lt;&#x2f;a&gt; macro (sorry for the long name :D). We can use it to fix the safety problem easily:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation) {
    assert_has_not_been_called!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;memory::init must be called only once&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= ...
    ...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;That&#x27;s it. Now our &lt;code&gt;memory::init&lt;&#x2f;code&gt; function can only be called once. The macro works by creating a static &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;sync&#x2f;atomic&#x2f;struct.AtomicBool.html&quot;&gt;AtomicBool&lt;&#x2f;a&gt; named &lt;code&gt;CALLED&lt;&#x2f;code&gt;, which is initialized to &lt;code&gt;false&lt;&#x2f;code&gt;. When the macro is invoked, it checks the value of &lt;code&gt;CALLED&lt;&#x2f;code&gt; and sets it to &lt;code&gt;true&lt;&#x2f;code&gt;. If the value was already &lt;code&gt;true&lt;&#x2f;code&gt; before, the macro panics.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;mapping-the-heap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-the-heap&quot; aria-label=&quot;Anchor link for: mapping-the-heap&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Mapping the Heap&lt;&#x2f;h3&gt;
&lt;p&gt;Now we&#x27;re ready to map the heap pages. In order to do it, we need access to the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; or &lt;code&gt;Mapper&lt;&#x2f;code&gt; instance (see the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;page table&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;&quot;&gt;kernel remapping&lt;&#x2f;a&gt; posts). For that we return it from the &lt;code&gt;paging::remap_the_kernel&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A, boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation)
    -&amp;gt; ActivePageTable &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;guard page at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, old_p4_page.start_address());

    active_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we have full page table access in the &lt;code&gt;memory::init&lt;&#x2f;code&gt; function. This allows us to map the heap pages to physical frames:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;init(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

    let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= ...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; below is the new part

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;paging::remap_the_kernel(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator,
        boot_info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::paging::Page;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_start_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_end_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;-&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::range_inclusive(heap_start_page, heap_end_page) {
        active_table.map(page, paging::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Page::range_inclusive&lt;&#x2f;code&gt; function is just a copy of the &lt;code&gt;Frame::range_inclusive&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(â€¦, PartialEq, Eq, PartialOrd, Ord)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page {...}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;range_inclusive(start: Page, end: Page) -&amp;gt; PageIter {
        PageIter {
            start: start,
            end: end,
        }
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageIter {
    start: Page,
    end: Page,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Iterator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;PageIter {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Page;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Page&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.end {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.start;
            self.start.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            Some(page)
        } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            None
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we map the whole heap to physical pages. This needs some time and might introduce a noticeable delay when we increase the heap size in the future. Another drawback is that we consume a large amount of physical frames even though we might not need the whole heap space. We will fix these problems in a future post by mapping the pages lazily.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;it-works&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#it-works&quot; aria-label=&quot;Anchor link for: it-works&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
It works!&lt;&#x2f;h3&gt;
&lt;p&gt;Now &lt;code&gt;Box&lt;&#x2f;code&gt; and &lt;code&gt;Vec&lt;&#x2f;code&gt; should work. For example:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;alloc::boxed::Box;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;heap_test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;-= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; heap_test2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Box::new(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?} {:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, heap_test, heap_test2);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vec_test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vec![&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
vec_test[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vec_test {
    print!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, i);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can also use all other types of the &lt;code&gt;alloc&lt;&#x2f;code&gt; crate, including:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the reference counted pointers &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;alloc&#x2f;rc&#x2f;&quot;&gt;Rc&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;alloc&#x2f;arc&#x2f;&quot;&gt;Arc&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the owned string type &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;string&#x2f;struct.String.html&quot;&gt;String&lt;&#x2f;a&gt; and the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;macro.format!.html&quot;&gt;format!&lt;&#x2f;a&gt; macro&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;linked_list&#x2f;struct.LinkedList.html&quot;&gt;Linked List&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the growable ring buffer &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;vec_deque&#x2f;struct.VecDeque.html&quot;&gt;VecDeque&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;binary_heap&#x2f;struct.BinaryHeap.html&quot;&gt;BinaryHeap&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;btree_map&#x2f;struct.BTreeMap.html&quot;&gt;BTreeMap&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;btree_set&#x2f;struct.BTreeSet.html&quot;&gt;BTreeSet&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;a-better-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-better-allocator&quot; aria-label=&quot;Anchor link for: a-better-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A better Allocator&lt;&#x2f;h2&gt;
&lt;p&gt;Right now, we leak every freed memory block. Thus, we run out of memory quickly, for example, by creating a new &lt;code&gt;String&lt;&#x2f;code&gt; in each iteration of a loop:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    format!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some String&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To fix this, we need to create an allocator that keeps track of freed memory blocks and reuses them if possible. This introduces some challenges:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;We need to keep track of a possibly unlimited number of freed blocks. For example, an application could allocate &lt;code&gt;n&lt;&#x2f;code&gt; one-byte sized blocks and free every second block, which creates &lt;code&gt;n&#x2f;2&lt;&#x2f;code&gt; freed blocks. We can&#x27;t rely on any upper bound of freed block since &lt;code&gt;n&lt;&#x2f;code&gt; could be arbitrarily large.&lt;&#x2f;li&gt;
&lt;li&gt;We can&#x27;t use any of the collections from above, since they rely on allocations themselves. (It might be possible as soon as &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1398-kinds-of-allocators.md&quot;&gt;RFC #1398&lt;&#x2f;a&gt; is &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;32838&quot;&gt;implemented&lt;&#x2f;a&gt;, which allows user-defined allocators for specific collection instances.)&lt;&#x2f;li&gt;
&lt;li&gt;We need to merge adjacent freed blocks if possible. Otherwise, the freed memory is no longer usable for large allocations. We will discuss this point in more detail below.&lt;&#x2f;li&gt;
&lt;li&gt;Our allocator should search the set of freed blocks quickly and keep fragmentation low.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;creating-a-list-of-freed-blocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-list-of-freed-blocks&quot; aria-label=&quot;Anchor link for: creating-a-list-of-freed-blocks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a List of freed Blocks&lt;&#x2f;h3&gt;
&lt;p&gt;Where do we store the information about an unlimited number of freed blocks? We can&#x27;t use any fixed size data structure since it could always be too small for some allocation sequences. So we need some kind of dynamically growing set.&lt;&#x2f;p&gt;
&lt;p&gt;One possible solution could be to use an array-like data structure that starts at some unused virtual address. If the array becomes full, we increase its size and map new physical frames as backing storage. This approach would require a large part of the virtual address space since the array could grow significantly. We would need to create a custom implementation of a growable array and manipulate the page tables when deallocating. It would also consume a possibly large number of physical frames as backing storage.&lt;&#x2f;p&gt;
&lt;p&gt;We will choose another solution with different tradoffs. It&#x27;s not clearly â€œbetterâ€ than the approach above and has significant disadvantages itself. However, it has one big advantage: It does not need any additional physical or virtual memory at all. This makes it less complex since we don&#x27;t need to manipulate any page tables. The idea is the following:&lt;&#x2f;p&gt;
&lt;p&gt;A freed memory block is not used anymore and no one needs the stored information. It is still mapped to a virtual address and backed by a physical page. So we just store the information about the freed block &lt;em&gt;in the block itself&lt;&#x2f;em&gt;.  We keep a pointer to the first block and store a pointer to the next block in each block. Thus, we create a single linked list:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;overview.svg&quot; alt=&quot;Linked List Allocator&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In the following, we call a freed block a &lt;em&gt;hole&lt;&#x2f;em&gt;. Each hole stores its size and a pointer to the next hole. If a hole is larger than needed, we leave the remaining memory unused. By storing a pointer to the first hole, we are able to traverse the complete list.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;initialization&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#initialization&quot; aria-label=&quot;Anchor link for: initialization&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Initialization&lt;&#x2f;h4&gt;
&lt;p&gt;When the heap is created, all of its memory is unused. Thus, it forms a single large hole:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;initialization.svg&quot; alt=&quot;Heap Initialization&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The optional pointer to the next hole is set to &lt;code&gt;None&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;allocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#allocation&quot; aria-label=&quot;Anchor link for: allocation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Allocation&lt;&#x2f;h4&gt;
&lt;p&gt;In order to allocate a block of memory, we need to find a hole that satisfies the size and alignment requirements. If the found hole is larger than required, we split it into two smaller holes. For example, when we allocate a 24 byte block right after initialization, we split the single hole into a hole of size 24 and a hole with the remaining size:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;split-hole.svg&quot; alt=&quot;split hole&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Then we use the new 24 byte hole to perform the allocation:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;allocate.svg&quot; alt=&quot;24 bytes allocated&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;To find a suitable hole, we can use several search strategies:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;best fit&lt;&#x2f;strong&gt;: Search the whole list and choose the &lt;em&gt;smallest&lt;&#x2f;em&gt; hole that satisfies the requirements.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;worst fit&lt;&#x2f;strong&gt;: Search the whole list and choose the &lt;em&gt;largest&lt;&#x2f;em&gt; hole that satisfies the requirements.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;first fit&lt;&#x2f;strong&gt;: Search the list from the beginning and choose the &lt;em&gt;first&lt;&#x2f;em&gt; hole that satisfies the requirements.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Each strategy has its advantages and disadvantages. Best fit uses the smallest hole possible and leaves larger holes for large allocations. But splitting the smallest hole might create a tiny hole, which is too small for most allocations. In contrast, the worst fit strategy always chooses the largest hole. Thus, it does not create tiny holes, but it consumes the large block, which might be required for large allocations.&lt;&#x2f;p&gt;
&lt;p&gt;For our use case, the best fit strategy is better than worst fit. The reason is that we have a minimal hole size of 16 bytes, since each hole needs to be able to store a size (8 bytes) and a pointer to the next hole (8 bytes). Thus, even the best fit strategy leads to holes of usable size. Furthermore, we will need to allocate very large blocks occasionally (e.g. for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Direct_memory_access&quot;&gt;DMA&lt;&#x2f;a&gt; buffers).&lt;&#x2f;p&gt;
&lt;p&gt;However, both best fit and worst fit have a significant problem: They need to scan the whole list for each allocation in order to find the optimal block. This leads to long allocation times if the list is long. The first fit strategy does not have this problem, as it returns as soon as it finds a suitable hole. It is fairly fast for small allocations and might only need to scan the whole list for large allocations.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;deallocation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deallocation&quot; aria-label=&quot;Anchor link for: deallocation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Deallocation&lt;&#x2f;h4&gt;
&lt;p&gt;To deallocate a block of memory, we can just insert its corresponding hole somewhere into the list. However, we need to merge adjacent holes. Otherwise, we are unable to reuse the freed memory for larger allocations. For example:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;deallocate.svg&quot; alt=&quot;deallocate memory, which leads to adjacent holes&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;In order to use these adjacent holes for a large allocation, we need to merge them to a single large hole first:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;merge-holes-and-allocate.svg&quot; alt=&quot;merge adjacent holes and allocate large block&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The easiest way to ensure that adjacent holes are always merged, is to keep the hole list sorted by address. Thus, we only need to check the predecessor and the successor in the list when we free a memory block. If they are adjacent to the freed block, we merge the corresponding holes. Else, we insert the freed block as a new hole at the correct position.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;The detailed implementation would go beyond the scope of this post, since it contains several hidden difficulties. For example:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;Several merge cases: Merge with the previous hole, merge with the next hole, merge with both holes.&lt;&#x2f;li&gt;
&lt;li&gt;We need to satisfy the alignment requirements, which requires additional splitting logic.&lt;&#x2f;li&gt;
&lt;li&gt;The minimal hole size of 16 bytes: We must not create smaller holes when splitting a hole.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;I created the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;crate&#x2f;linked_list_allocator&#x2f;0.4.1&quot;&gt;linked_list_allocator&lt;&#x2f;a&gt; crate to handle all of these cases. It consists of a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.4.1&#x2f;linked_list_allocator&#x2f;struct.Heap.html&quot;&gt;Heap struct&lt;&#x2f;a&gt; that provides an &lt;code&gt;allocate_first_fit&lt;&#x2f;code&gt; and a &lt;code&gt;deallocate&lt;&#x2f;code&gt; method. It also contains a &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;linked_list_allocator&#x2f;0.4.1&#x2f;linked_list_allocator&#x2f;struct.LockedHeap.html&quot;&gt;LockedHeap&lt;&#x2f;a&gt; type that wraps &lt;code&gt;Heap&lt;&#x2f;code&gt; into spinlock so that it&#x27;s usable as a static system allocator. If you are interested in the implementation details, check out the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;linked-list-allocator&quot;&gt;source code&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We need to add the extern crate to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt; and our &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo add linked_list_allocator
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; linked_list_allocator;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can change our global allocator:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linked_list_allocator::LockedHeap;

#[global_allocator]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: LockedHeap &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;LockedHeap::empty();
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can&#x27;t initialize the linked list allocator statically, since it needs to initialize the first hole (like described &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;#initialization&quot;&gt;above&lt;&#x2f;a&gt;). This can&#x27;t be done at compile time, so the function can&#x27;t be a &lt;code&gt;const&lt;&#x2f;code&gt; function. Therefore we can only create an empty heap and initialize it later at runtime. For that, we add the following lines to our &lt;code&gt;rust_main&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    [â€¦]

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; set up guard page and map the heap pages
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::init(boot_info);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; initialize the heap allocator
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_ALLOCATOR&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().init(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_START &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HEAP_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
    [â€¦]
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It is important that we initialize the heap &lt;em&gt;after&lt;&#x2f;em&gt; mapping the heap pages, since the init function writes to the heap memory (the first hole).&lt;&#x2f;p&gt;
&lt;p&gt;Our kernel uses the new allocator now, so we can deallocate memory without leaking it. The example from above should work now without causing an OOM situation:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    format!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some String&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;performance&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#performance&quot; aria-label=&quot;Anchor link for: performance&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Performance&lt;&#x2f;h3&gt;
&lt;p&gt;The linked list based approach has some performance problems. Each allocation or deallocation might need to scan the complete list of holes in the worst case. However, I think it&#x27;s good enough for now, since our heap will stay relatively small for the near future. When our allocator becomes a performance problem eventually, we can just replace it with a faster alternative.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Summary&lt;&#x2f;h2&gt;
&lt;p&gt;Now we&#x27;re able to use heap storage in our kernel without leaking memory. This allows us to effectively process dynamic data such as user supplied strings in the future. We can also use &lt;code&gt;Rc&lt;&#x2f;code&gt; and &lt;code&gt;Arc&lt;&#x2f;code&gt; to create types with shared ownership. And we have access to various data structures such as &lt;code&gt;Vec&lt;&#x2f;code&gt; or &lt;code&gt;Linked List&lt;&#x2f;code&gt;, which will make our lives much easier. We even have some well tested and optimized &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Binary_heap&quot;&gt;binary heap&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;B-tree&quot;&gt;B-tree&lt;&#x2f;a&gt; implementations!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;This post concludes the section about memory management for now. We will revisit this topic eventually, but now it&#x27;s time to explore other topics. The upcoming posts will be about CPU exceptions and interrupts. We will catch all page, double, and triple faults and create a driver to read keyboard input. The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; starts by setting up a so-called &lt;em&gt;Interrupt Descriptor Table&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Remap the Kernel</title>
                <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/remap-the-kernel/</link>
                <guid>https://os.phil-opp.com/remap-the-kernel/</guid>
                <description>&lt;p&gt;In this post we will create a new page table to map the kernel sections correctly. Therefore we will extend the paging module to support modifications of &lt;em&gt;inactive&lt;&#x2f;em&gt; page tables as well. Then we will switch to the new table and secure our kernel stack by creating a guard page.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;As always, you can find the source code on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_7&quot;&gt;GitHub&lt;&#x2f;a&gt;. Don&#x27;t hesitate to file issues there if you have any problems or improvement suggestions. There is also a comment section at the end of this page. Note that this post requires a current Rust nightly.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;motivation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation&quot; aria-label=&quot;Anchor link for: motivation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Motivation&lt;&#x2f;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt;, we had a strange bug in the &lt;code&gt;unmap&lt;&#x2f;code&gt; function. Its reason was a silent stack overflow, which corrupted the page tables. Fortunately, our kernel stack is right above the page tables so that we noticed the overflow relatively quickly. This won&#x27;t be the case when we add threads with new stacks in the future. Then a silent stack overflow could overwrite some data without us noticing. But eventually some completely unrelated function fails because a variable changed its value.&lt;&#x2f;p&gt;
&lt;p&gt;As you can imagine, these kinds of bugs are horrendous to debug. For that reason we will create a new hierarchical page table in this post, which has &lt;em&gt;guard page&lt;&#x2f;em&gt; below the stack. A guard page is basically an unmapped page that causes a page fault when accessed. Thus we can catch stack overflows right when they happen.&lt;&#x2f;p&gt;
&lt;p&gt;Also, we will use the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;#kernel-elf-sections&quot;&gt;information about kernel sections&lt;&#x2f;a&gt; to map the various sections individually instead of blindly mapping the first gigabyte. To improve safety even further, we will set the correct page table flags for the various sections. Thus it won&#x27;t be possible to modify the contents of &lt;code&gt;.text&lt;&#x2f;code&gt; or to execute code from &lt;code&gt;.data&lt;&#x2f;code&gt; anymore.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;preparation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preparation&quot; aria-label=&quot;Anchor link for: preparation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preparation&lt;&#x2f;h2&gt;
&lt;p&gt;There are many things that can go wrong when we switch to a new table. Therefore it&#x27;s a good idea to &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-gdb&#x2f;&quot;&gt;set up a debugger&lt;&#x2f;a&gt;. You should not need it when you follow this post, but it&#x27;s good to know how to debug a problem when it occurs&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-debug-notes&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We also update the &lt;code&gt;Page&lt;&#x2f;code&gt; and &lt;code&gt;Frame&lt;&#x2f;code&gt; types to make our lives easier. The &lt;code&gt;Page&lt;&#x2f;code&gt; struct gets some derived traits:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page {
    number: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By making it &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;Copy&lt;&#x2f;a&gt;, we can still use it after passing it to functions such as &lt;code&gt;map_to&lt;&#x2f;code&gt;. We also make the &lt;code&gt;Page::containing_address&lt;&#x2f;code&gt; public (if it isn&#x27;t already).&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Frame&lt;&#x2f;code&gt; type gets a &lt;code&gt;clone&lt;&#x2f;code&gt; method too, but it does not implement the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;clone&#x2f;trait.Clone.html&quot;&gt;Clone trait&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clone(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Frame {
        Frame { number: self.number }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The big difference is that this &lt;code&gt;clone&lt;&#x2f;code&gt; method is private. If we implemented the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;clone&#x2f;trait.Clone.html&quot;&gt;Clone trait&lt;&#x2f;a&gt;, it would be public and usable from other modules. For example they could abuse it to free the same frame twice in the frame allocator.&lt;&#x2f;p&gt;
&lt;p&gt;So why do we implement &lt;code&gt;Copy&lt;&#x2f;code&gt; for &lt;code&gt;Page&lt;&#x2f;code&gt; and make even its constructor public, but keep &lt;code&gt;Frame&lt;&#x2f;code&gt; as private as possible? The reason is that we can easily check the status of a &lt;code&gt;Page&lt;&#x2f;code&gt; by looking at the page tables. For example, the &lt;code&gt;map_to&lt;&#x2f;code&gt; function can easily check that the given page is unused.&lt;&#x2f;p&gt;
&lt;p&gt;We can&#x27;t do that for a &lt;code&gt;Frame&lt;&#x2f;code&gt;. If we wanted to be sure that a given frame is unused, we would need to look at all mapped &lt;em&gt;pages&lt;&#x2f;em&gt; and verify that none of them is mapped to the given frame. Since this is impractical, we need to rely on the fact that a passed &lt;code&gt;Frame&lt;&#x2f;code&gt; is always unused. For that reason it must not be possible to create a new &lt;code&gt;Frame&lt;&#x2f;code&gt; or to clone one from other modules. The only valid way to get a frame is to allocate it from a &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;recap-the-paging-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recap-the-paging-module&quot; aria-label=&quot;Anchor link for: recap-the-paging-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Recap: The Paging Module&lt;&#x2f;h2&gt;
&lt;p&gt;This post builds upon the post about &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;page tables&lt;&#x2f;a&gt;, so let&#x27;s start by quickly recapitulating what we&#x27;ve done there.&lt;&#x2f;p&gt;
&lt;p&gt;We created a &lt;code&gt;memory::paging&lt;&#x2f;code&gt; module, which reads and modifies the hierarchical page table through recursive mapping. The owner of the active P4 table and thus all subtables is an &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; struct, which must be instantiated only once.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; struct provides the following interface:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Translates a virtual to the corresponding physical address.
&#x2f;&#x2f;&#x2f; Returns `None` if the address is not mapped.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, virtual_address: VirtualAddress) -&amp;gt;
    Option&amp;lt;PhysicalAddress&amp;gt;
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Maps the page to the frame with the provided flags.
&#x2f;&#x2f;&#x2f; The `PRESENT` flag is added by default. Needs a
&#x2f;&#x2f;&#x2f; `FrameAllocator` as it might need to create new page tables.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map_to&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                 page: Page,
                 frame: Frame,
                 flags: EntryFlags,
                 allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Maps the page to some free frame with the provided flags.
&#x2f;&#x2f;&#x2f; The free frame is allocated from the given `FrameAllocator`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, page: Page, flags: EntryFlags, allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Identity map the the given frame with the provided flags.
&#x2f;&#x2f;&#x2f; The `FrameAllocator` is used to create new page tables if needed.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;identity_map&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                       frame: Frame,
                       flags: EntryFlags,
                       allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}


&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Unmaps the given page and adds all freed frames to the given
&#x2f;&#x2f;&#x2f; `FrameAllocator`.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;unmap&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, page: Page, allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overview&lt;&#x2f;h2&gt;
&lt;p&gt;Our goal is to use the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; functions to map the kernel sections correctly in a new page table. In pseudo code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel(boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;create_new_table();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.elf_sections {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section {
            new_table.identity_map(frame, section.flags);
        }
    }

    new_table.activate();
    create_guard_page_for_stack();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;But the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; methods â€“ as the name suggests â€“ only work for the &lt;em&gt;active table&lt;&#x2f;em&gt;. So we would need to activate &lt;code&gt;new_table&lt;&#x2f;code&gt; &lt;em&gt;before&lt;&#x2f;em&gt; we use &lt;code&gt;identity_map&lt;&#x2f;code&gt;. But this is not possible since it would cause an immediate page fault when the CPU tries to read the next instruction.&lt;&#x2f;p&gt;
&lt;p&gt;So we need a way to use the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; methods on &lt;em&gt;inactive&lt;&#x2f;em&gt; page tables as well.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;inactive-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#inactive-tables&quot; aria-label=&quot;Anchor link for: inactive-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Inactive Tables&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s start by creating a type for inactive page tables. Like an &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt;, an &lt;code&gt;InactivePageTable&lt;&#x2f;code&gt; owns a P4 table. The difference is that the inactive P4 table is not used by the CPU.&lt;&#x2f;p&gt;
&lt;p&gt;We create the struct in &lt;code&gt;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InactivePageTable {
    p4_frame: Frame,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InactivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(frame: Frame) -&amp;gt; InactivePageTable {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO zero and recursive map the frame
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        InactivePageTable { p4_frame: frame }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Without zeroing, the P4 table contains complete garbage and maps random memory. But we can&#x27;t zero it right now because the &lt;code&gt;p4_frame&lt;&#x2f;code&gt; is not mapped to a virtual address.&lt;&#x2f;p&gt;
&lt;p&gt;Well, maybe it&#x27;s still part of the identity mapped first gigabyte. Then we could zero it without problems since the physical address would be a valid virtual address, too. But this â€œsolutionâ€ is hacky and won&#x27;t work after this post anymore (since we will remove all needless identity mapping).&lt;&#x2f;p&gt;
&lt;p&gt;Instead, we will try to temporary map the frame to some virtual address.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;temporary-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#temporary-mapping&quot; aria-label=&quot;Anchor link for: temporary-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Temporary Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;Therefor we add a &lt;code&gt;TemporaryPage&lt;&#x2f;code&gt; struct. We create it in a new &lt;code&gt;temporary_page&lt;&#x2f;code&gt; submodule to keep the paging module clean. It looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;memory&#x2f;paging&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;temporary_page;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; src&#x2f;memory&#x2f;paging&#x2f;temporary_page.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::Page;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TemporaryPage {
    page: Page,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add methods to temporary map and unmap the page:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::{ActivePageTable, VirtualAddress};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::Frame;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TemporaryPage {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Maps the temporary page to the given frame in the active table.
    &#x2f;&#x2f;&#x2f; Returns the start address of the temporary page.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, frame: Frame, active_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable)
        -&amp;gt; VirtualAddress
    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

        assert!(active_table.translate_page(self.page).is_none(),
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;temporary page is already mapped&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        active_table.map_to(self.page, frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;???&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        self.page.start_address()
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Unmaps the temporary page in the active table.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;unmap(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, active_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable) {
        active_table.unmap(self.page, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;???&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;???&lt;&#x2f;code&gt; needs to be some &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt;. We could just add an additional &lt;code&gt;allocator&lt;&#x2f;code&gt; argument but there is a better solution.&lt;&#x2f;p&gt;
&lt;p&gt;It takes advantage of the fact that we always map the same page. So the allocator only needs to hold 3 frames: one P3, one P2, and one P1 table (the P4 table is always mapped). This allows us to create a tiny allocator and add it as field to the &lt;code&gt;TemporaryPage&lt;&#x2f;code&gt; struct itself:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TemporaryPage {
    page: Page,
    allocator: TinyAllocator,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TemporaryPage {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; as above, but with `&amp;amp;mut self.allocator` instead of `???`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TinyAllocator([Option&amp;lt;Frame&amp;gt;; 3]);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Our tiny allocator just consists of 3 slots to store frames. It will be empty when the temporary page is mapped and full when all corresponding page tables are unmapped.&lt;&#x2f;p&gt;
&lt;p&gt;To turn &lt;code&gt;TinyAllocator&lt;&#x2f;code&gt; into a frame allocator, we need to add the trait implementation:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::FrameAllocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TinyAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_option &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_option.is_some() {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_option.take();
            }
        }
        None
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deallocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, frame: Frame) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_option &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_option.is_none() {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;frame_option &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(frame);
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            }
        }
        panic!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Tiny allocator can hold only 3 frames.&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;On allocation, we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;option&#x2f;enum.Option.html#method.take&quot;&gt;Option::take&lt;&#x2f;a&gt; function to take an available frame from the first filled slot and on deallocation, we put the frame back into the first free slot.&lt;&#x2f;p&gt;
&lt;p&gt;To finish the &lt;code&gt;TinyAllocator&lt;&#x2f;code&gt;, we add a constructor that fills it from some other allocator:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TinyAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A) -&amp;gt; TinyAllocator
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;f &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;|| allocator.allocate_frame();
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frames &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[f(), f(), f()];
        TinyAllocator(frames)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use a little closure here that saves us some typing.&lt;&#x2f;p&gt;
&lt;p&gt;Now our &lt;code&gt;TemporaryPage&lt;&#x2f;code&gt; type is nearly complete. We only add one more method for convenience:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::table::{Table, Level1};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;&#x2f; Maps the temporary page to the given page table frame in the active
&#x2f;&#x2f;&#x2f; table. Returns a reference to the now mapped table.
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map_table_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                       frame: Frame,
                       active_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable)
                       -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level1&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(self.map(frame, active_table) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level1&amp;gt;) }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function interprets the given frame as a page table frame and returns a &lt;code&gt;Table&lt;&#x2f;code&gt; reference. We return a table of level 1 because it &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;#some-clever-solution&quot;&gt;forbids calling the &lt;code&gt;next_table&lt;&#x2f;code&gt; methods&lt;&#x2f;a&gt;. Calling &lt;code&gt;next_table&lt;&#x2f;code&gt; must not be possible since it&#x27;s not a page of the recursive mapping. To be able to return a &lt;code&gt;Table&amp;lt;Level1&amp;gt;&lt;&#x2f;code&gt;, we need to make the &lt;code&gt;Level1&lt;&#x2f;code&gt; enum in &lt;code&gt;memory&#x2f;paging&#x2f;table.rs&lt;&#x2f;code&gt; public.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;unsafe&lt;&#x2f;code&gt; block is safe since the &lt;code&gt;VirtualAddress&lt;&#x2f;code&gt; returned by the &lt;code&gt;map&lt;&#x2f;code&gt; function is always valid and the type cast just reinterprets the frame&#x27;s content.&lt;&#x2f;p&gt;
&lt;p&gt;To complete the &lt;code&gt;temporary_page&lt;&#x2f;code&gt; module, we add a &lt;code&gt;TemporaryPage::new&lt;&#x2f;code&gt; constructor:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new&amp;lt;A&amp;gt;(page: Page, allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A) -&amp;gt; TemporaryPage
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    TemporaryPage {
        page: page,
        allocator: TinyAllocator::new(allocator),
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;zeroing-the-inactivepagetable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#zeroing-the-inactivepagetable&quot; aria-label=&quot;Anchor link for: zeroing-the-inactivepagetable&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Zeroing the InactivePageTable&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can use &lt;code&gt;TemporaryPage&lt;&#x2f;code&gt; to fix our &lt;code&gt;InactivePageTable::new&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::temporary_page::TemporaryPage;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;InactivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(frame: Frame,
               active_table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable,
               temporary_page: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; TemporaryPage)
               -&amp;gt; InactivePageTable {
        {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page.map_table_frame(frame.clone(),
                active_table);
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; now we are able to zero the table
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;            table.zero();
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; set up recursive mapping for the table
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;            table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;].set(frame.clone(), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        }
        temporary_page.unmap(active_table);

        InactivePageTable { p4_frame: frame }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We added two new arguments, &lt;code&gt;active_table&lt;&#x2f;code&gt; and &lt;code&gt;temporary_page&lt;&#x2f;code&gt;. We need an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;variable_bindings&#x2f;scope.html&quot;&gt;inner scope&lt;&#x2f;a&gt; to ensure that the &lt;code&gt;table&lt;&#x2f;code&gt; variable is dropped before we try to unmap the temporary page again. This is required since the &lt;code&gt;table&lt;&#x2f;code&gt; variable exclusively borrows &lt;code&gt;temporary_page&lt;&#x2f;code&gt; as long as it&#x27;s alive.&lt;&#x2f;p&gt;
&lt;p&gt;Now we are able to create valid inactive page tables, which are zeroed and recursively mapped. But we still can&#x27;t modify them. To resolve this problem, we need to look at recursive mapping again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;revisiting-recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#revisiting-recursive-mapping&quot; aria-label=&quot;Anchor link for: revisiting-recursive-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Revisiting Recursive Mapping&lt;&#x2f;h2&gt;
&lt;p&gt;Recursive mapping works by mapping the last P4 entry to the P4 table itself. Thus we can access the page tables by looping one or more times.&lt;&#x2f;p&gt;
&lt;p&gt;For example, accessing a P3 table requires lopping three times:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;recursive_mapping_access_p3.svg&quot; alt=&quot;access active P3 table through recursive mapping&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We can use the same mechanism to access inactive tables. The trick is to change the recursive mapping of the active P4 table to point to the inactive P4 table:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;recursive_mapping_access_p3_inactive_table.svg&quot; alt=&quot;access inactive P3 table through recursive mapping&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Now the inactive table can be accessed exactly as the active table, even the magic addresses are the same. This allows us to use the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; interface and the existing mapping methods for inactive tables, too. Note that everything besides the recursive mapping continues to work exactly as before since we&#x27;ve never changed the active table in the CPU.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation-draft&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation-draft&quot; aria-label=&quot;Anchor link for: implementation-draft&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation Draft&lt;&#x2f;h3&gt;
&lt;p&gt;We add a method to &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; that temporary changes the recursive mapping and executes a given closure in the new context:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;with&amp;lt;F&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
               table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InactivePageTable,
               f: F)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; F: FnOnce(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ActivePageTable)
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tlb;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; overwrite recursive mapping
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.p4_mut()[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;].set(table.p4_frame.clone(), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    tlb::flush_all();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; execute f in the new context
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;f(self);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO restore recursive mapping to original p4 table
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It overwrites the 511th P4 entry and points it to the inactive table frame. Then it flushes the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;TLB&quot;&gt;translation lookaside buffer (TLB)&lt;&#x2f;a&gt;, which still contains some old translations. We need to flush all pages that are part of the recursive mapping, so the easiest way is to flush the TLB completely.&lt;&#x2f;p&gt;
&lt;p&gt;Now that the recursive mapping points to the given inactive table, we execute the closure in the new context. The closure can call all active table methods such as &lt;code&gt;translate&lt;&#x2f;code&gt; or &lt;code&gt;map_to&lt;&#x2f;code&gt;. It could even call &lt;code&gt;with&lt;&#x2f;code&gt; again and chain another inactive table! Waitâ€¦ that would not work:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;recursive_mapping_access_p1_invalid_chaining.svg&quot; alt=&quot;access inactive P3 table through recursive mapping&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Here the closure called &lt;code&gt;with&lt;&#x2f;code&gt; again and thus changed the recursive mapping of the inactive table to point to a second inactive table. Now we want to modify the P1 of the &lt;em&gt;second&lt;&#x2f;em&gt; inactive table, but instead we land on the P1 of the &lt;em&gt;first&lt;&#x2f;em&gt; inactive table since we never follow the pointer to the second table. Only when modifying the P2, P3, or P4 table we really access the second inactive table. This inconsistency would break our mapping functions completely.&lt;&#x2f;p&gt;
&lt;p&gt;So we should really prohibit the closure from calling &lt;code&gt;with&lt;&#x2f;code&gt; again. We could add some runtime assertion that panics when the active table is not recursive mapped anymore. But a cleaner solution is to split off the mapping code from &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; into a new &lt;code&gt;Mapper&lt;&#x2f;code&gt; type.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;refactoring&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#refactoring&quot; aria-label=&quot;Anchor link for: refactoring&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Refactoring&lt;&#x2f;h3&gt;
&lt;p&gt;We start by creating a new &lt;code&gt;memory&#x2f;paging&#x2f;mapper.rs&lt;&#x2f;code&gt; submodule and moving the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; struct and its &lt;code&gt;impl&lt;&#x2f;code&gt; block to it. Then we rename it to &lt;code&gt;Mapper&lt;&#x2f;code&gt; and make all methods public (so we can still use them from the paging module). The &lt;code&gt;with&lt;&#x2f;code&gt; method is removed.&lt;&#x2f;p&gt;
&lt;p&gt;After adjusting the imports, the module should look like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in memory&#x2f;paging&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;mapper;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; memory&#x2f;paging&#x2f;mapper.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::{VirtualAddress, PhysicalAddress, Page, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use super&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;::table::{self, Table, Level4, Level1};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Frame, FrameAllocator};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ptr::Unique;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mapper {
    p4: Unique&amp;lt;Table&amp;lt;Level4&amp;gt;&amp;gt;,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mapper {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; Mapper {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the remaining mapping methods, all public
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we create a new &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; struct in &lt;code&gt;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::mapper::Mapper;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ops::{Deref, DerefMut};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    mapper: Mapper,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Deref &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Target &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Mapper;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deref(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mapper {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.mapper
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;DerefMut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deref_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Mapper {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.mapper
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; ActivePageTable {
        ActivePageTable {
            mapper: Mapper::new(),
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;with&amp;lt;F&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                   table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InactivePageTable,
                   f: F)
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; F: FnOnce(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Mapper) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; `Mapper` instead of `ActivePageTable`
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ops&#x2f;trait.Deref.html&quot;&gt;Deref&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ops&#x2f;trait.DerefMut.html&quot;&gt;DerefMut&lt;&#x2f;a&gt; implementations allow us to use the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; exactly as before, for example we still can call &lt;code&gt;map_to&lt;&#x2f;code&gt; on it (because of &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;book&#x2f;deref-coercions.html&quot;&gt;deref coercions&lt;&#x2f;a&gt;). But the closure called in the &lt;code&gt;with&lt;&#x2f;code&gt; function can no longer invoke &lt;code&gt;with&lt;&#x2f;code&gt; again. The reason is that we changed the type of the generic &lt;code&gt;F&lt;&#x2f;code&gt; parameter a bit: Instead of an &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt;, the closure just gets a &lt;code&gt;Mapper&lt;&#x2f;code&gt; as argument.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;restoring-the-recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#restoring-the-recursive-mapping&quot; aria-label=&quot;Anchor link for: restoring-the-recursive-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Restoring the Recursive Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;Right now, the &lt;code&gt;with&lt;&#x2f;code&gt; function overwrites the recursive mapping and calls the closure. But it does not restore the previous recursive mapping yet. So let&#x27;s fix that!&lt;&#x2f;p&gt;
&lt;p&gt;To backup the physical P4 frame of the active table, we can either read it from the 511th P4 entry (before we change it) or from the CR3 control register directly. We will do the latter as it should be faster and we already have a external crate that makes it easy:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control_regs;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; backup &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ control_regs::cr3() } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Why is it unsafe? Because reading the CR3 register leads to a CPU exception if the processor is not running in kernel mode (&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Security#Low-level_Protection_Mechanisms&quot;&gt;Ring 0&lt;&#x2f;a&gt;). But this code will always run in kernel mode, so the &lt;code&gt;unsafe&lt;&#x2f;code&gt; block is completely safe here.&lt;&#x2f;p&gt;
&lt;p&gt;Now that we have a backup of the original P4 frame, we need a way to restore it after the closure has run. So we need to somehow modify the 511th entry of the original P4 frame, which is still the active table in the CPU. But we can&#x27;t access it because the recursive mapping now points to the inactive table:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;recursive_mapping_inactive_table_scheme.svg&quot; alt=&quot;it&#x27;s not possible to access the original P4 through recursive mapping anymore&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;It&#x27;s just not possible to access the active P4 entry in 4 steps, so we can&#x27;t reach it through the 4-level page table.&lt;&#x2f;p&gt;
&lt;p&gt;We could try to overwrite the recursive mapping of the &lt;em&gt;inactive&lt;&#x2f;em&gt; P4 table and point it back to the original P4 frame:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;cyclic_mapping_inactive_tables.svg&quot; alt=&quot;cyclic map active and inactive P4 tables&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Now we can reach the active P4 entry in 4 steps and could restore the original mapping in the active table. But this hack has a drawback: The inactive table is now invalid since it is no longer recursive mapped. We would need to fix it by using a temporary page again (as above).&lt;&#x2f;p&gt;
&lt;p&gt;But if we need a temporary page anyway, we can just use it to map the original P4 frame directly. Thus we avoid the above hack and make the code simpler. So let&#x27;s do it that way.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;completing-the-implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#completing-the-implementation&quot; aria-label=&quot;Anchor link for: completing-the-implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Completing the Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;with&lt;&#x2f;code&gt; method gets an additional &lt;code&gt;TemporaryPage&lt;&#x2f;code&gt; argument, which we use to backup and restore the original recursive mapping:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;with&amp;lt;F&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                   table: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InactivePageTable,
                   temporary_page: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;temporary_page::TemporaryPage, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
                   &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;f: F)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; F: FnOnce(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Mapper)
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tlb;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control_regs;

    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; backup &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(
            control_regs::cr3().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; map temporary_page to current p4 table
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p4_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page.map_table_frame(backup.clone(), self);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; overwrite recursive mapping
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.p4_mut()[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;].set(table.p4_frame.clone(), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        tlb::flush_all();

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; execute f in the new context
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;f(self);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; restore recursive mapping to original p4 table
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        p4_table[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;511&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;].set(backup, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        tlb::flush_all();
    }

    temporary_page.unmap(self);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Again, the inner scope is needed to end the borrow of &lt;code&gt;temporary_page&lt;&#x2f;code&gt; so that we can unmap it again. Note that we need to flush the TLB another time after we restored the original recursive mapping.&lt;&#x2f;p&gt;
&lt;p&gt;Now the &lt;code&gt;with&lt;&#x2f;code&gt; function is ready to be used!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;remapping-the-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#remapping-the-kernel&quot; aria-label=&quot;Anchor link for: remapping-the-kernel&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Remapping the Kernel&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s tackle the main task of this post: remapping the kernel sections. Therefor we create a &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; function in &lt;code&gt;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;multiboot2::BootInformation;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, Frame, FrameAllocator};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A, boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TemporaryPage::new(Page { number: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xcafebabe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;},
        allocator);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ ActivePageTable::new() };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; allocator.allocate_frame().expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no more frames&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        InactivePageTable::new(frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page)
    };

    active_table.with(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page, |mapper| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.elf_sections_tag()
            .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO mapper.identity_map() all pages of `section`
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;First, we create a temporary page at page number &lt;code&gt;0xcafebabe&lt;&#x2f;code&gt;. We could use &lt;code&gt;0xdeadbeaf&lt;&#x2f;code&gt; or &lt;code&gt;0x123456789&lt;&#x2f;code&gt; as well, as long as the page is unused. The &lt;code&gt;active_table&lt;&#x2f;code&gt; and the &lt;code&gt;new_table&lt;&#x2f;code&gt; are created using their constructor functions.&lt;&#x2f;p&gt;
&lt;p&gt;Then we use the &lt;code&gt;with&lt;&#x2f;code&gt; function to temporary change the recursive mapping and execute the closure as if the &lt;code&gt;new_table&lt;&#x2f;code&gt; were active. This allows us to map the sections in the new table without changing the active mapping. To get the kernel sections, we use the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;#the-multiboot-information-structure&quot;&gt;Multiboot information structure&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s resolve the above &lt;code&gt;TODO&lt;&#x2f;code&gt; by identity mapping the sections:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section.is_allocated() {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; section is not loaded to memory
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;continue&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    }
    assert!(section.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;% &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;sections need to be page aligned&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping section at addr: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, size: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        section.addr, section.size);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO use real section flags

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; start_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(section.start_address());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; end_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(section.end_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::range_inclusive(start_frame, end_frame) {
        mapper.identity_map(frame, flags, allocator);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We skip all sections that were not loaded into memory (e.g. debug sections). We require that all sections are page aligned because a page must not contain sections with different flags. For example, we would need to set the &lt;code&gt;EXECUTABLE&lt;&#x2f;code&gt; and &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flags for a page that contains parts of the &lt;code&gt;.code&lt;&#x2f;code&gt; and &lt;code&gt;.data&lt;&#x2f;code&gt; section. Thus we could modify the running code or execute bytes from the &lt;code&gt;.data&lt;&#x2f;code&gt; section as code.&lt;&#x2f;p&gt;
&lt;p&gt;To map a section, we iterate over all of its frames of a section by using a new &lt;code&gt;Frame::range_inclusive&lt;&#x2f;code&gt; function (shown below). Note that the end address is exclusive, so that it&#x27;s not part of the section anymore (it&#x27;s the first byte of the next section). Thus we need to subtract 1 to get the &lt;code&gt;end_frame&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Frame::range_inclusive&lt;&#x2f;code&gt; function looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;range_inclusive(start: Frame, end: Frame) -&amp;gt; FrameIter {
        FrameIter {
            start: start,
            end: end,
        }
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameIter {
    start: Frame,
    end: Frame,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Iterator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameIter {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Item &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Frame;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.end {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.start.clone();
            self.start.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            Some(frame)
        } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            None
        }
    }
 }
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of creating a custom iterator, we could have used the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ops&#x2f;struct.Range.html&quot;&gt;Range&lt;&#x2f;a&gt; struct of the standard library. But it requires that we implement the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;core&#x2f;num&#x2f;trait.One.html&quot;&gt;One&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ops&#x2f;trait.Add.html&quot;&gt;Add&lt;&#x2f;a&gt; traits for &lt;code&gt;Frame&lt;&#x2f;code&gt;. Then every module could perform arithmetic operations on frames, for example &lt;code&gt;let frame3 = frame1 + frame2&lt;&#x2f;code&gt;. This would violate our safety invariants because &lt;code&gt;frame3&lt;&#x2f;code&gt; could be already in use. The &lt;code&gt;range_inclusive&lt;&#x2f;code&gt; function does not have these problems because it is only available inside the &lt;code&gt;memory&lt;&#x2f;code&gt; module.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-align-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-align-sections&quot; aria-label=&quot;Anchor link for: page-align-sections&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Align Sections&lt;&#x2f;h3&gt;
&lt;p&gt;Right now our sections aren&#x27;t page aligned, so the assertion in &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; would fail. We can fix this by making the section size a multiple of the page size. To do this, we add an &lt;code&gt;ALIGN&lt;&#x2f;code&gt; statement to all sections in the linker file. For example:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;SECTIONS {
  . = 1M;

  .text :
  {
    *(.text .text.*)
    . = ALIGN(4K);
  }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;.&lt;&#x2f;code&gt; is the â€œcurrent location counterâ€ and represents the current virtual address. At the beginning of the &lt;code&gt;SECTIONS&lt;&#x2f;code&gt; tag we set it to &lt;code&gt;1M&lt;&#x2f;code&gt;, so our kernel starts at 1MiB. We use the &lt;a href=&quot;http:&#x2f;&#x2f;www.math.utah.edu&#x2f;docs&#x2f;info&#x2f;ld_3.html#SEC12&quot;&gt;ALIGN&lt;&#x2f;a&gt; function to align the current location counter to the next &lt;code&gt;4K&lt;&#x2f;code&gt; boundary (&lt;code&gt;4K&lt;&#x2f;code&gt; is the page size). Thus the end of the &lt;code&gt;.text&lt;&#x2f;code&gt; section â€“ and the beginning of the next section â€“ are page aligned.&lt;&#x2f;p&gt;
&lt;p&gt;To put all sections on their own page, we add the &lt;code&gt;ALIGN&lt;&#x2f;code&gt; statement to all of them:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&#x2f;* src&#x2f;arch&#x2f;x86_64&#x2f;linker.ld *&#x2f;

ENTRY(start)

SECTIONS {
  . = 1M;

  .rodata :
  {
    &#x2f;* ensure that the multiboot header is at the beginning *&#x2f;
    KEEP(*(.multiboot_header))
    *(.rodata .rodata.*)
    . = ALIGN(4K);
  }

  .text :
  {
    *(.text .text.*)
    . = ALIGN(4K);
  }

  .data :
  {
    *(.data .data.*)
    . = ALIGN(4K);
  }

  .bss :
  {
    *(.bss .bss.*)
    . = ALIGN(4K);
  }

  .got :
  {
    *(.got)
    . = ALIGN(4K);
  }

  .got.plt :
  {
    *(.got.plt)
    . = ALIGN(4K);
  }

  .data.rel.ro : ALIGN(4K) {
    *(.data.rel.ro.local*) *(.data.rel.ro .data.rel.ro.*)
    . = ALIGN(4K);
  }

  .gcc_except_table : ALIGN(4K) {
    *(.gcc_except_table)
    . = ALIGN(4K);
  }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of page aligning the &lt;code&gt;.multiboot_header&lt;&#x2f;code&gt; section, we merge it into the &lt;code&gt;.rodata&lt;&#x2f;code&gt; section. That way, we don&#x27;t waste a whole page for the few bytes of the Multiboot header. We could merge it into any section, but &lt;code&gt;.rodata&lt;&#x2f;code&gt; fits best because it has the same flags (neither writable nor executable). The Multiboot header still needs to be at the beginning of the file, so &lt;code&gt;.rodata&lt;&#x2f;code&gt; must be our first section now.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h3&gt;
&lt;p&gt;Time to test it! We re-export the &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; function from the memory module and call it from &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::paging::remap_the_kernel;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; ATTENTION: we have a very small stack and no guard page

    &#x2f;&#x2f; the same as before
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer::clear_screen();
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        multiboot2::load(multiboot_information_address)
    };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.memory_map_tag()
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.elf_sections_tag()
        .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf sections tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections().map(|s| s.addr)
        .min().unwrap();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections().map(|s| s.addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.size)
        .max().unwrap();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_information_address;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(boot_info.total_size &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel start: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, kernel end: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        kernel_start, kernel_end);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;multiboot start: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, multiboot end: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        multiboot_start, multiboot_end);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::AreaFrameAllocator::new(
        kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, multiboot_start,
        multiboot_end, memory_map_tag.memory_areas());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; this is the new part
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::remap_the_kernel(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator, boot_info);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If you see the &lt;code&gt;It did not crash&lt;&#x2f;code&gt; message, the kernel survived our page table modifications without causing a CPU exception. But did we map the kernel sections correctly?&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s try it out by switching to the new table! We identity map all kernel sections, so it should work without problems.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;switching-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#switching-tables&quot; aria-label=&quot;Anchor link for: switching-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Switching Tables&lt;&#x2f;h2&gt;
&lt;p&gt;Switching tables is easy. We just need to reload the &lt;code&gt;CR3&lt;&#x2f;code&gt; register with the physical address of the new P4 frame.&lt;&#x2f;p&gt;
&lt;p&gt;We do this in a new &lt;code&gt;ActivePageTable::switch&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `impl ActivePageTable` in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;switch(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, new_table: InactivePageTable) -&amp;gt; InactivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::PhysicalAddress;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control_regs;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; old_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; InactivePageTable {
        p4_frame: Frame::containing_address(
            control_regs::cr3().&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
    };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        control_regs::cr3_write(PhysicalAddress(
            new_table.p4_frame.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    }
    old_table
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function activates the given inactive table and returns the previous active table as a &lt;code&gt;InactivePageTable&lt;&#x2f;code&gt;. We don&#x27;t need to flush the TLB here, as the CPU does it automatically when the P4 table is switched. In fact, the &lt;code&gt;tlb::flush_all&lt;&#x2f;code&gt; function, which we used above, does nothing more than &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&#x2f;0.1.2&#x2f;src&#x2f;x86_64&#x2f;instructions&#x2f;tlb.rs.html#11-14&quot;&gt;reloading the CR3 register&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now we are finally able to switch to the new table. We do it by adding the following lines to our &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in remap_the_kernel in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
active_table.with(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page, |mapper| {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;});

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; old_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table.switch(new_table);
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s cross our fingers and run itâ€¦&lt;&#x2f;p&gt;
&lt;p&gt;â€¦ and it fails with a boot loop.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;debugging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#debugging&quot; aria-label=&quot;Anchor link for: debugging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Debugging&lt;&#x2f;h3&gt;
&lt;p&gt;A QEMU boot loop indicates that some CPU exception occurred. We can see all thrown CPU exception by starting QEMU with &lt;code&gt;-d int&lt;&#x2f;code&gt; (as described &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;#debugging&quot;&gt;here&lt;&#x2f;a&gt;):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; qemu-system-x86_64 -d int -no-reboot -cdrom build&#x2f;os-x86_64.iso
...
check_exception old: 0xffffffff new 0xe
     0: v=0e e=0002 i=0 cpl=0 IP=0008:000000000010ab97 pc=000000000010ab97
        SP=&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;0010:00000000001182d0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; CR2=&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;00000000000b8f00&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;These lines are the important ones. We can read many useful information from them:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;v=0e&lt;&#x2f;code&gt;: An exception with number &lt;code&gt;0xe&lt;&#x2f;code&gt; occurred, which is a page fault according to the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions&quot;&gt;OSDev Wiki&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;e=0002&lt;&#x2f;code&gt;: The CPU set an &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Error_code&quot;&gt;error code&lt;&#x2f;a&gt;, which tells us why the exception occurred. The &lt;code&gt;0x2&lt;&#x2f;code&gt; bit tells us that it was caused by a write operation. And since the &lt;code&gt;0x1&lt;&#x2f;code&gt; bit is not set, the target page was not present.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IP=0008:000000000010ab97&lt;&#x2f;code&gt; or &lt;code&gt;pc=000000000010ab97&lt;&#x2f;code&gt;: The program counter register tells us that the exception occurred when the CPU tried to execute the instruction at &lt;code&gt;0x10ab97&lt;&#x2f;code&gt;. We can disassemble this address to see the corresponding function. The &lt;code&gt;0008:&lt;&#x2f;code&gt; prefix in &lt;code&gt;IP&lt;&#x2f;code&gt; indicates the code &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;#loading-the-gdt&quot;&gt;GDT segment&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SP=0010:00000000001182d0&lt;&#x2f;code&gt;: The stack pointer was &lt;code&gt;0x1182d0&lt;&#x2f;code&gt; (the &lt;code&gt;0010:&lt;&#x2f;code&gt; prefix indicates the data &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;#loading-the-gdt&quot;&gt;GDT segment&lt;&#x2f;a&gt;). This tells us if it the stack overflowed.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CR2=00000000000b8f00&lt;&#x2f;code&gt;: Finally the most useful register. It tells us which virtual address caused the page fault. In our case it&#x27;s &lt;code&gt;0xb8f00&lt;&#x2f;code&gt;, which is part of the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;#the-vga-text-buffer&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;So let&#x27;s find out which function caused the exception:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;objdump -d build&#x2f;kernel-x86_64.bin | grep -B100 &amp;quot;10ab97&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We disassemble our kernel and search for &lt;code&gt;10ab97&lt;&#x2f;code&gt;. The &lt;code&gt;-B100&lt;&#x2f;code&gt; option prints the 100 preceding lines too. The output tells us the responsible function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
000000000010aa80 &amp;lt;_ZN10vga_buffer6Writer10write_byte20h4601f5e405b6e89facaE&amp;gt;:
  10aa80:	55                   	push   %rbp
  ...
  10ab93:	66 8b 55 aa          	mov    -0x56(%rbp),%dx
  10ab97:	66 89 14 48          	mov    %dx,(%rax,%rcx,2)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason for the cryptical function name is Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Name_mangling&quot;&gt;name mangling&lt;&#x2f;a&gt;. But we can identity the &lt;code&gt;vga_buffer::Writer::write_byte&lt;&#x2f;code&gt; function nonetheless.&lt;&#x2f;p&gt;
&lt;p&gt;So the reason for the page fault is that the &lt;code&gt;write_byte&lt;&#x2f;code&gt; function tried to write to the VGA text buffer at &lt;code&gt;0xb8f00&lt;&#x2f;code&gt;. Of course this provokes a page fault: We forgot to identity map the VGA buffer in the new page table.&lt;&#x2f;p&gt;
&lt;p&gt;The fix is pretty simple:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A, boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    active_table.with(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page, |mapper| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
        for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; identity map the VGA text buffer
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; vga_buffer_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;        mapper.identity_map(vga_buffer_frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, allocator); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;});

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; old_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table.switch(new_table);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we should see the &lt;code&gt;NEW TABLE!!!&lt;&#x2f;code&gt; message (and also the &lt;code&gt;It did not crash!&lt;&#x2f;code&gt; line again). Congratulations! We successfully switched our kernel to a new page table!&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-the-frame-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-frame-allocator&quot; aria-label=&quot;Anchor link for: fixing-the-frame-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing the Frame Allocator&lt;&#x2f;h3&gt;
&lt;p&gt;The same problem as above occurs when we try to use our &lt;a href=&quot;http:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames.html#the-allocator&quot;&gt;AreaFrameAllocator&lt;&#x2f;a&gt; again. Try to add the following to &lt;code&gt;rust_main&lt;&#x2f;code&gt; after switching to the new table:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::remap_the_kernel(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator, boot_info);
    frame_allocator.allocate_frame(); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; new: try to allocate a frame
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;It did not crash!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This causes the same bootloop as above. The reason is that the &lt;code&gt;AreaFrameAllocator&lt;&#x2f;code&gt; uses the memory map of the Multiboot information structure. But we did not map the Multiboot structure, so it causes a page fault. To fix it, we identity map it as well:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `remap_the_kernel` in src&#x2f;memory&#x2f;paging&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;active_table.with(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page, |mapper| {

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; â€¦ identity map the allocated kernel sections
    &#x2f;&#x2f; â€¦ identity map the VGA text buffer

    &#x2f;&#x2f; new:
    &#x2f;&#x2f; identity map the multiboot info structure
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(boot_info.start_address());
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(boot_info.end_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::range_inclusive(multiboot_start, multiboot_end) {
        mapper.identity_map(frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, allocator);
    }
});
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Normally the multiboot struct fits on one page. But GRUB can place it anywhere, so it could randomly cross a page boundary. Therefore we use &lt;code&gt;range_inclusive&lt;&#x2f;code&gt; to be on the safe side. Note that we need to subtract 1 to get the address of the last byte because the end address is exclusive.&lt;&#x2f;p&gt;
&lt;p&gt;Now we should be able to allocate frames again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;using-the-correct-flags&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#using-the-correct-flags&quot; aria-label=&quot;Anchor link for: using-the-correct-flags&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Using the Correct Flags&lt;&#x2f;h2&gt;
&lt;p&gt;Right now, our new table maps all kernel sections as writable and executable. To fix this, we add a &lt;code&gt;EntryFlags::from_elf_section_flags&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;entry.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;multiboot2::ElfSection;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryFlags {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;from_elf_section_flags(section: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ElfSection) -&amp;gt; EntryFlags {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;multiboot2::{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_ALLOCATED&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_EXECUTABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryFlags::empty();

        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_ALLOCATED&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; section is loaded to memory
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;            flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        }
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
            flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        }
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ELF_SECTION_EXECUTABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
            flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;NO_EXECUTE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        }

        flags
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It just converts the ELF section flags to page table flags.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use it to fix the &lt;code&gt;TODO&lt;&#x2f;code&gt; in our &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A, boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    active_table.with(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; new_table, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; temporary_page, |mapper| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
        for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections() {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
            if !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section.is_allocated() {
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; section is not loaded to memory
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;continue&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            }
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; this is the new part
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryFlags::from_elf_section_flags(section);
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
            for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::range_inclusive(start_frame, end_frame) {
                mapper.identity_map(frame, flags, allocator);
            }
        }
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;});
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;But when we test it now, we get a page fault again. We can use the same technique as above to get the responsible function. I won&#x27;t bother you with the QEMU output and just tell you the results:&lt;&#x2f;p&gt;
&lt;p&gt;This time the responsible function is &lt;code&gt;control_regs::cr3_write()&lt;&#x2f;code&gt; itself. From the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Exceptions#Error_code&quot;&gt;error code&lt;&#x2f;a&gt; we learn that it was a page protection violation and caused by â€œreading a 1 in a reserved fieldâ€. So the page table had some reserved bit set that should be always 0. It must be the &lt;code&gt;NO_EXECUTE&lt;&#x2f;code&gt; flag, since it&#x27;s the only new bit that we set in the page table.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-nxe-bit&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-nxe-bit&quot; aria-label=&quot;Anchor link for: the-nxe-bit&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The NXE Bit&lt;&#x2f;h3&gt;
&lt;p&gt;The reason is that the &lt;code&gt;NO_EXECUTE&lt;&#x2f;code&gt; bit must only be used when the &lt;code&gt;NXE&lt;&#x2f;code&gt; bit in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Control_register#EFER&quot;&gt;Extended Feature Enable Register&lt;&#x2f;a&gt; (EFER) is set. That register is similar to Rust&#x27;s feature gating and can be used to enable all sorts of advanced CPU features. Since the &lt;code&gt;NXE&lt;&#x2f;code&gt; bit is off by default, we caused a page fault when we added the &lt;code&gt;NO_EXECUTE&lt;&#x2f;code&gt; bit to the page table.&lt;&#x2f;p&gt;
&lt;p&gt;So we need to enable the &lt;code&gt;NXE&lt;&#x2f;code&gt; bit. For that we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&quot;&gt;x86_64 crate&lt;&#x2f;a&gt; again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;enable_nxe_bit() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::msr::{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, rdmsr, wrmsr};

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; nxe_bit &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; efer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rdmsr(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        wrmsr(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;IA32_EFER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, efer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; nxe_bit);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The unsafe block is needed since accessing the &lt;code&gt;EFER&lt;&#x2f;code&gt; register is only allowed in kernel mode. But we are in kernel mode, so everything is fine.&lt;&#x2f;p&gt;
&lt;p&gt;When we call this function before calling &lt;code&gt;remap_the_kernel&lt;&#x2f;code&gt;, everything should work again.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-write-protect-bit&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-write-protect-bit&quot; aria-label=&quot;Anchor link for: the-write-protect-bit&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Write Protect Bit&lt;&#x2f;h3&gt;
&lt;p&gt;Right now, we are still able to modify the &lt;code&gt;.code&lt;&#x2f;code&gt; and &lt;code&gt;.rodata&lt;&#x2f;code&gt; sections, even though we did not set the &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flag for them. The reason is that the CPU ignores this bit in kernel mode by default. To enable write protection for the kernel as well, we need to set the &lt;em&gt;Write Protect&lt;&#x2f;em&gt; bit in the &lt;code&gt;CR0&lt;&#x2f;code&gt; register:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;enable_write_protect_bit() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::registers::control_regs::{cr0, cr0_write, Cr0};

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ cr0_write(cr0() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Cr0::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITE_PROTECT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) };
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;cr0&lt;&#x2f;code&gt; functions are unsafe because accessing the &lt;code&gt;CR0&lt;&#x2f;code&gt; register is only allowed in kernel mode.&lt;&#x2f;p&gt;
&lt;p&gt;If we haven&#x27;t forgotten to set the &lt;code&gt;WRITABLE&lt;&#x2f;code&gt; flag somewhere, it should still work without crashing.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;creating-a-guard-page&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-guard-page&quot; aria-label=&quot;Anchor link for: creating-a-guard-page&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a Guard Page&lt;&#x2f;h2&gt;
&lt;p&gt;The final step is to create a guard page for our kernel stack.&lt;&#x2f;p&gt;
&lt;p&gt;The decision to place the kernel stack right above the page tables was already useful to detect a silent stack overflow in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;#translate&quot;&gt;previous post&lt;&#x2f;a&gt;. Now we profit from it again. Let&#x27;s look at our assembly &lt;code&gt;.bss&lt;&#x2f;code&gt; section again to understand why:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;; in src&#x2f;arch&#x2f;x86_64&#x2f;boot.asm

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section .bss
align &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p3_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p2_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_bottom:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_top:
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The old page tables are right below the stack. They are still identity mapped since they are part of the kernel&#x27;s &lt;code&gt;.bss&lt;&#x2f;code&gt; section. We just need to turn the old &lt;code&gt;p4_table&lt;&#x2f;code&gt; into a guard page to secure the kernel stack. That way we even reuse the memory of the old P3 and P2 tables to increase the stack size.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s implement it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;memory&#x2f;paging&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;remap_the_kernel&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A, boot_info: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;BootInformation)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; old_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; active_table.switch(new_table);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;NEW TABLE!!!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; below is the new part

    &#x2f;&#x2f; turn the old p4 page into a guard page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; old_p4_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(
      old_table.p4_frame.start_address()
    );
    active_table.unmap(old_p4_page, allocator);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;guard page at &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, old_p4_page.start_address());
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we have a very basic guard page: The page below the stack is unmapped, so a stack overflow causes an immediate page fault. Thus, silent stack overflows are no longer possible.&lt;&#x2f;p&gt;
&lt;p&gt;Or to be precise, they are improbable. If we have a function with many big stack variables, it&#x27;s possible that the guard page is missed. For example, the following function could still corrupt memory below the stack:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_overflow() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;99999&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This creates a very big array on the stack, which is currently filled from bottom to top. Therefore it misses the guard page and overwrites some memory below the stack. Eventually it hits the bottom of the guard page and causes a page fault. But before, it messes up memory, which is bad.&lt;&#x2f;p&gt;
&lt;p&gt;Fortunately, there exists a solution called &lt;em&gt;stack probes&lt;&#x2f;em&gt;. The basic idea is to check all required stack pages at the beginning of each function. For example, a function that needs 9000 bytes on the stack would try to access &lt;code&gt;SP + 0&lt;&#x2f;code&gt;, &lt;code&gt;SP + 4096&lt;&#x2f;code&gt;, and &lt;code&gt;SP + 2 * 4096&lt;&#x2f;code&gt; (&lt;code&gt;SP&lt;&#x2f;code&gt; is the stack pointer). If the stack is not big enough, the guard page is hit and a page fault occurs. The function can&#x27;t mess up memory anymore since the stack check occurs right at its start.&lt;&#x2f;p&gt;
&lt;p&gt;Unfortunately stack probes require compiler support. They already work on Windows but they don&#x27;t exist on Linux yet. The problem seems to be in LLVM, which Rust uses as backend. Hopefully it gets resolved soon so that our kernel stack becomes safe. For the current status and more information about stack probes check out the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;issues&#x2f;16012#issuecomment-160380183&quot;&gt;tracking issue&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we have a (mostly) safe kernel stack and a working page table module, we can add a virtual memory allocator. The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;kernel-heap&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; will explore Rust&#x27;s allocator API and create a very basic allocator. At the end of that post, we will be able to use Rust&#x27;s allocation and collections types such as &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;alloc&#x2f;boxed&#x2f;struct.Box.html&quot;&gt;Box&lt;&#x2f;a&gt;, &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;vec&#x2f;struct.Vec.html&quot;&gt;Vec&lt;&#x2f;a&gt;, or even &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;collections&#x2f;btree_map&#x2f;struct.BTreeMap.html&quot;&gt;BTreeMap&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-debug-notes&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;For this post the most useful GDB command is probably &lt;code&gt;p&#x2f;x *((long int*)0xfffffffffffff000)@512&lt;&#x2f;code&gt;. It prints all entries of the recursively mapped P4 table by interpreting it as an array of 512 long ints (the &lt;code&gt;@512&lt;&#x2f;code&gt; is GDB&#x27;s array syntax). Of course you can also print other tables by adjusting the address.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Page Tables</title>
                <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/page-tables/</link>
                <guid>https://os.phil-opp.com/page-tables/</guid>
                <description>&lt;p&gt;In this post we will create a paging module, which allows us to access and modify the 4-level page table. We will explore recursive page table mapping and use some Rust features to make it safe. Finally we will create functions to translate virtual addresses and to map and unmap pages.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;You can find the source code and this post itself on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_6&quot;&gt;GitHub&lt;&#x2f;a&gt;. Please file an issue there if you have any problems or improvement suggestions. There is also a comment section at the end of this page. Note that this post requires a current Rust nightly.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Paging&lt;&#x2f;h2&gt;
&lt;p&gt;&lt;em&gt;Paging&lt;&#x2f;em&gt; is a memory management scheme that separates virtual and physical memory. The address space is split into equal sized &lt;em&gt;pages&lt;&#x2f;em&gt; and &lt;em&gt;page tables&lt;&#x2f;em&gt; specify which virtual page points to which physical frame. For an extensive paging introduction take a look at the paging chapter (&lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;vm-paging.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) of the &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;&quot;&gt;Three Easy Pieces&lt;&#x2f;a&gt; OS book.&lt;&#x2f;p&gt;
&lt;p&gt;The x86 architecture uses a 4-level page table in 64-bit mode. A virtual address has the following structure:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;x86_address_structure.svg&quot; alt=&quot;structure of a virtual address on x86&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The bits 48â€“63 are so-called &lt;em&gt;sign extension&lt;&#x2f;em&gt; bits and must be copies of bit 47. The following 36 bits define the page table indexes (9 bits per table) and the last 12 bits specify the offset in the 4KiB page.&lt;&#x2f;p&gt;
&lt;p&gt;Each table has 2^9 = 512 entries and each entry is 8 byte. Thus a page table fits exactly in one page (4 KiB).&lt;&#x2f;p&gt;
&lt;p&gt;To translate an address, the CPU reads the P4 address from the CR3 register. Then it uses the indexes to walk the tables:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;X86_Paging_64bit.svg&quot; alt=&quot;translation of virtual to physical addresses in 64 bit mode&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The P4 entry points to a P3 table, where the next 9 bits of the address are used to select an entry. The P3 entry then points to a P2 table and the P2 entry points to a P1 table. The P1 entry, which is specified through bits 12â€“20, finally points to the physical frame.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-basic-paging-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-basic-paging-module&quot; aria-label=&quot;Anchor link for: a-basic-paging-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Basic Paging Module&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s create a basic paging module in &lt;code&gt;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; needed later

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;PhysicalAddress &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;VirtualAddress &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page {
   number: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We import the &lt;code&gt;PAGE_SIZE&lt;&#x2f;code&gt; and define a constant for the number of entries per table. To make future function signatures more expressive, we can use the type aliases &lt;code&gt;PhysicalAddress&lt;&#x2f;code&gt; and &lt;code&gt;VirtualAddress&lt;&#x2f;code&gt;. The &lt;code&gt;Page&lt;&#x2f;code&gt; struct is similar to the &lt;code&gt;Frame&lt;&#x2f;code&gt; struct in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;#a-memory-module&quot;&gt;previous post&lt;&#x2f;a&gt;, but represents a virtual page instead of a physical frame.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-table-entries&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-entries&quot; aria-label=&quot;Anchor link for: page-table-entries&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Table Entries&lt;&#x2f;h3&gt;
&lt;p&gt;To model page table entries, we create a new &lt;code&gt;entry&lt;&#x2f;code&gt; submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::Frame; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; needed later

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;is_unused(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bool &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_unused(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
        self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We define that an unused entry is completely 0. That allows us to distinguish unused entries from other non-present entries in the future. For example, we could define one of the available bits as the &lt;code&gt;swapped_out&lt;&#x2f;code&gt; bit for pages that are swapped to disk.&lt;&#x2f;p&gt;
&lt;p&gt;Next we will model the contained physical address and the various flags. Remember, entries have the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)                &lt;&#x2f;th&gt;&lt;th&gt;Name &lt;&#x2f;th&gt;&lt;th&gt;Meaning&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0 &lt;&#x2f;td&gt;&lt;td&gt;present &lt;&#x2f;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;1 &lt;&#x2f;td&gt;&lt;td&gt;writable &lt;&#x2f;td&gt;&lt;td&gt;it&#x27;s allowed to write to this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;2 &lt;&#x2f;td&gt;&lt;td&gt;user accessible &lt;&#x2f;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3 &lt;&#x2f;td&gt;&lt;td&gt;write through caching &lt;&#x2f;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;4 &lt;&#x2f;td&gt;&lt;td&gt;disable cache &lt;&#x2f;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;5 &lt;&#x2f;td&gt;&lt;td&gt;accessed &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;6 &lt;&#x2f;td&gt;&lt;td&gt;dirty &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;7 &lt;&#x2f;td&gt;&lt;td&gt;huge page&#x2f;null &lt;&#x2f;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1GiB page in P3, creates a 2MiB page in P2&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8 &lt;&#x2f;td&gt;&lt;td&gt;global &lt;&#x2f;td&gt;&lt;td&gt;page isn&#x27;t flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12-51 &lt;&#x2f;td&gt;&lt;td&gt;physical address &lt;&#x2f;td&gt;&lt;td&gt;the page aligned 52bit physical address of the frame or the next page table&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;63 &lt;&#x2f;td&gt;&lt;td&gt;no execute &lt;&#x2f;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;To model the various flags, we will use the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang-nursery&#x2f;bitflags&quot;&gt;bitflags&lt;&#x2f;a&gt; crate. To add it as a dependency, add the following to your &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;bitflags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.9.1&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To import the macro, we need to use &lt;code&gt;#[macro_use]&lt;&#x2f;code&gt; above the &lt;code&gt;extern crate&lt;&#x2f;code&gt; definition:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; bitflags;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can model the various flags:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bitflags! {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;EntryFlags: u64 {
        const PRESENT =         1 &amp;lt;&amp;lt; 0;
        const WRITABLE =        1 &amp;lt;&amp;lt; 1;
        const USER_ACCESSIBLE = 1 &amp;lt;&amp;lt; 2;
        const WRITE_THROUGH =   1 &amp;lt;&amp;lt; 3;
        const NO_CACHE =        1 &amp;lt;&amp;lt; 4;
        const ACCESSED =        1 &amp;lt;&amp;lt; 5;
        const DIRTY =           1 &amp;lt;&amp;lt; 6;
        const HUGE_PAGE =       1 &amp;lt;&amp;lt; 7;
        const GLOBAL =          1 &amp;lt;&amp;lt; 8;
        const NO_EXECUTE =      1 &amp;lt;&amp;lt; 63;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To extract the flags from the entry we create an &lt;code&gt;Entry::flags&lt;&#x2f;code&gt; method that uses &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;bitflags&#x2f;0.9.1&#x2f;bitflags&#x2f;example_generated&#x2f;struct.Flags.html#method.from_bits_truncate&quot;&gt;from_bits_truncate&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;flags(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; EntryFlags {
    EntryFlags::from_bits_truncate(self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This allows us to check for flags through the &lt;code&gt;contains()&lt;&#x2f;code&gt; function. For example, &lt;code&gt;flags().contains(PRESENT | WRITABLE)&lt;&#x2f;code&gt; returns true if the entry contains &lt;em&gt;both&lt;&#x2f;em&gt; flags.&lt;&#x2f;p&gt;
&lt;p&gt;To extract the physical address, we add a &lt;code&gt;pointed_frame&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;pointed_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        Some(Frame::containing_address(
            self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize &amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x000fffff_fffff000
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        None
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If the entry is present, we mask bits 12â€“51 and return the corresponding frame. If the entry is not present, it does not point to a valid frame so we return &lt;code&gt;None&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To modify entries, we add a &lt;code&gt;set&lt;&#x2f;code&gt; method that updates the flags and the pointed frame:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, frame: Frame, flags: EntryFlags) {
    assert!(frame.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x000fffff_fffff000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    self.&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(frame.start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;|&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; flags.bits();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The start address of a frame should be page aligned and smaller than 2^52 (since x86 uses 52bit physical addresses). Since an invalid address could mess up the entry, we add an assertion. To actually set the entry, we just need to &lt;code&gt;or&lt;&#x2f;code&gt; the start address and the flag bits.&lt;&#x2f;p&gt;
&lt;p&gt;The missing &lt;code&gt;Frame::start_address&lt;&#x2f;code&gt; method is pretty simple:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::paging::PhysicalAddress;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;start_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; PhysicalAddress {
    self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add it to the &lt;code&gt;impl Frame&lt;&#x2f;code&gt; block in &lt;code&gt;memory&#x2f;mod.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-tables&quot; aria-label=&quot;Anchor link for: page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Tables&lt;&#x2f;h3&gt;
&lt;p&gt;To model page tables, we create a basic &lt;code&gt;Table&lt;&#x2f;code&gt; struct in a new &lt;code&gt;table&lt;&#x2f;code&gt; submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::paging::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::paging::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table {
    entries: [Entry; ENTRY_COUNT],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s just an array of 512 page table entries.&lt;&#x2f;p&gt;
&lt;p&gt;To make the &lt;code&gt;Table&lt;&#x2f;code&gt; indexable itself, we can implement the &lt;code&gt;Index&lt;&#x2f;code&gt; and &lt;code&gt;IndexMut&lt;&#x2f;code&gt; traits:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ops::{Index, IndexMut};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Index&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;Output &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Entry;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Entry {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.entries[index]
    }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;IndexMut&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;index_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Entry {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.entries[index]
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now it&#x27;s possible to get the 42th entry through &lt;code&gt;some_table[42]&lt;&#x2f;code&gt;. Of course we could replace &lt;code&gt;usize&lt;&#x2f;code&gt; with &lt;code&gt;u32&lt;&#x2f;code&gt; or even &lt;code&gt;u16&lt;&#x2f;code&gt; here but it would cause more numerical conversions (&lt;code&gt;x as u16&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s add a method that sets all entries to unused. We will need it when we create new page tables in the future. The method looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;zero(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.entries.iter_mut() {
        entry.set_unused();
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can read page tables and retrieve the mapping information. We can also update them through the &lt;code&gt;IndexMut&lt;&#x2f;code&gt; trait and the &lt;code&gt;Entry::set&lt;&#x2f;code&gt; method. But how do we get references to the various page tables?&lt;&#x2f;p&gt;
&lt;p&gt;We could read the &lt;code&gt;CR3&lt;&#x2f;code&gt; register to get the physical address of the P4 table and read its entries to get the P3 addresses. The P3 entries then point to the P2 tables and so on. But this method only works for identity-mapped pages. In the future we will create new page tables, which aren&#x27;t in the identity-mapped area anymore. Since we can&#x27;t access them through their physical address, we need a way to map them to virtual addresses.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;mapping-page-tables&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-page-tables&quot; aria-label=&quot;Anchor link for: mapping-page-tables&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Mapping Page Tables&lt;&#x2f;h2&gt;
&lt;p&gt;So how do we map the page tables itself? We don&#x27;t have that problem for the current P4, P3, and P2 table since they are part of the identity-mapped area, but we need a way to access future tables, too.&lt;&#x2f;p&gt;
&lt;p&gt;One solution is to identity map all page tables. That way we would not need to differentiate virtual and physical addresses and could easily access the tables. But it clutters the virtual address space and increases fragmentation. And it makes creating page tables much more complicated since we need a physical frame whose corresponding page isn&#x27;t already used for something else.&lt;&#x2f;p&gt;
&lt;p&gt;An alternative solution is to map the page tables only temporary. To read&#x2f;write a page table, we would map it to some free virtual address until we&#x27;re done. We could use a small pool of such virtual addresses and reuse them for various tables. This method occupies only few virtual addresses and thus is a good solution for 32-bit systems, which have small address spaces. But it makes things much more complicated since we need to temporary map up to 4 tables to access a single page. And the temporary mapping requires modification of other page tables, which need to be mapped, too.&lt;&#x2f;p&gt;
&lt;p&gt;We will solve the problem in another way using a trick called &lt;em&gt;recursive mapping&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;recursive-mapping&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recursive-mapping&quot; aria-label=&quot;Anchor link for: recursive-mapping&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Recursive Mapping&lt;&#x2f;h3&gt;
&lt;p&gt;The trick is to map the P4 table recursively: The last entry doesn&#x27;t point to a P3 table, but to the P4 table itself. We can use this entry to remove a translation level so that we land on a page table instead. For example, we can â€œloopâ€ once to access a P1 table:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;recursive_mapping_access_p1.svg&quot; alt=&quot;access P1 table through recursive paging&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;By selecting the 511th P4 entry, which points points to the P4 table itself, the P4 table is used as the P3 table. Similarly, the P3 table is used as a P2 table and the P2 table is treated like a P1 table. Thus the P1 table becomes the target page and can be accessed through the offset.&lt;&#x2f;p&gt;
&lt;p&gt;It&#x27;s also possible to access P2 tables by looping twice. And if we select the 511th entry three times, we can access and modify P3 tables:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;recursive_mapping_access_p3.svg&quot; alt=&quot;access P3 table through recursive paging&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;So we just need to specify the desired P3 table in the address through the P1 index. By choosing the 511th entry multiple times, we stay on the P4 table until the address&#x27;s P1 index becomes the actual P4 index.&lt;&#x2f;p&gt;
&lt;p&gt;To access the P4 table itself, we loop once more and thus never leave the frame:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;recursive_mapping_access_p4.svg&quot; alt=&quot;access P4 table through recursive paging&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;So we can access and modify page tables of all levels by just setting one P4 entry once. Most work is done by the CPU, we just the recursive entry to remove one or more translation levels. It may seem a bit strange at first, but it&#x27;s a clean and simple solution once you wrapped your head around it.&lt;&#x2f;p&gt;
&lt;p&gt;By using recursive mapping, each page table is accessible through an unique virtual address. The math checks out, too: If all page tables are used, there is 1 P4 table, 511 P3 tables (the last entry is used for the recursive mapping), &lt;code&gt;511*512&lt;&#x2f;code&gt; P2 tables, and &lt;code&gt;511*512*512&lt;&#x2f;code&gt; P1 tables. So there are &lt;code&gt;134217728&lt;&#x2f;code&gt; page tables altogether. Each page table occupies 4KiB, so we need &lt;code&gt;134217728 * 4KiB = 512GiB&lt;&#x2f;code&gt; to store them. That&#x27;s exactly the amount of memory that can be accessed through one P4 entry since &lt;code&gt;4KiB per page * 512 P1 entries * 512 P2 entries * 512 P3 entries = 512GiB&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Of course recursive mapping has some disadvantages, too. It occupies a P4 entry and thus 512GiB of the virtual address space. But since we&#x27;re in long mode and have a 48-bit address space, there are still 225.5TiB left. The bigger problem is that only the active table can be modified by default. To access another table, the recursive entry needs to be replaced temporary. We will tackle this problem in the next post when we switch to a new page table.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#implementation&quot; aria-label=&quot;Anchor link for: implementation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Implementation&lt;&#x2f;h3&gt;
&lt;p&gt;To map the P4 table recursively, we just need to point the 511th entry to the table itself. Of course we could do it in Rust, but it would require some fiddling with unsafe pointers. It&#x27;s easier to just add some lines to our boot assembly:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, p4_table
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, 0b11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[p4_table + &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;511 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], eax
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;I put it right after the &lt;code&gt;set_up_page_tables&lt;&#x2f;code&gt; label, but you can add it wherever you like.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use special virtual addresses to access the page tables. The P4 table is available at &lt;code&gt;0xfffffffffffff000&lt;&#x2f;code&gt;. Let&#x27;s add a P4 constant to the &lt;code&gt;table&lt;&#x2f;code&gt; submodule:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffffffff_fffff000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s switch to the octal system, since it makes more sense for the other special addresses. The P4 address from above is equivalent to &lt;code&gt;0o177777_777_777_777_777_0000&lt;&#x2f;code&gt; in octal. You can see that is has index &lt;code&gt;777&lt;&#x2f;code&gt; in all tables and offset &lt;code&gt;0000&lt;&#x2f;code&gt;. The &lt;code&gt;177777&lt;&#x2f;code&gt; bits on the left are the sign extension bits, which are copies of the 47th bit. They are required because x86 only uses 48bit virtual addresses.&lt;&#x2f;p&gt;
&lt;p&gt;The other tables can be accessed through the following addresses:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Table &lt;&#x2f;th&gt;&lt;th&gt;Address                         &lt;&#x2f;th&gt;&lt;th&gt;Indexes&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;P4    &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_777_777_0000&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;â€“&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;P3    &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_777_XXX_0000&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;XXX&lt;&#x2f;code&gt; is the P4 index&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;P2    &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_777_XXX_YYY_0000&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;like above, and &lt;code&gt;YYY&lt;&#x2f;code&gt; is the P3 index&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;P1    &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0o177777_777_XXX_YYY_ZZZ_0000&lt;&#x2f;code&gt; &lt;&#x2f;td&gt;&lt;td&gt;like above, and &lt;code&gt;ZZZ&lt;&#x2f;code&gt; is the P2 index&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;If we look closely, we can see that the P3 address is equal to &lt;code&gt;(P4 &amp;lt;&amp;lt; 9) | XXX_0000&lt;&#x2f;code&gt;. And the P2 address is calculated through &lt;code&gt;(P3 &amp;lt;&amp;lt; 9) | YYY_0000&lt;&#x2f;code&gt;. So to get the next address, we need to shift it 9 bits to the left and add the table index. As a formula:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_address = (table_address &amp;lt;&amp;lt; 9) | (index &amp;lt;&amp;lt; 12)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;the-next-table-methods&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-next-table-methods&quot; aria-label=&quot;Anchor link for: the-next-table-methods&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The &lt;code&gt;next_table&lt;&#x2f;code&gt; Methods&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s add the above formula as a &lt;code&gt;Table&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry_flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self[index].flags();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; entry_flags.contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp; !&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;entry_flags.contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; table_address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _ as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        Some((table_address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(index &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        None
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The next table address is only valid if the corresponding entry is present and does not create a huge page. Then we can do some pointer casting to get the table address and use the formula to calculate the next address.&lt;&#x2f;p&gt;
&lt;p&gt;If the index is out of bounds, the function will panic since Rust checks array bounds. The panic is desired here since a wrong index should not be possible and indicates a bug.&lt;&#x2f;p&gt;
&lt;p&gt;To convert the address into references, we add two functions:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;gt; {
    self.next_table_address(index)
        .map(|address| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) })
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Table&amp;gt; {
    self.next_table_address(index)
        .map(|address| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) })
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We convert the address into raw pointers through &lt;code&gt;as&lt;&#x2f;code&gt; casts and then convert them into Rust references through &lt;code&gt;&amp;amp;mut *&lt;&#x2f;code&gt;. The latter is an &lt;code&gt;unsafe&lt;&#x2f;code&gt; operation since Rust can&#x27;t guarantee that the raw pointer is valid.&lt;&#x2f;p&gt;
&lt;p&gt;Note that &lt;code&gt;self&lt;&#x2f;code&gt; stays borrowed as long as the returned reference is valid. This is because of Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;lifetimes.html#lifetime-elision&quot;&gt;lifetime elision&lt;&#x2f;a&gt; rules. Basically, these rules say that the lifetime of an output reference is the same as the lifetime of the input reference by default. So the above function signatures are expanded to:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Table&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_mut&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;#39;a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;a mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Table&amp;gt;
{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note the additional lifetime parameters, which are identical for input and output references. That&#x27;s exactly what we want. It ensures that we can&#x27;t modify tables as long as we have references to lower tables. For example, it would be very bad if we could unmap a P3 table if we still write to one of its P2 tables.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;safety&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety&quot; aria-label=&quot;Anchor link for: safety&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h4&gt;
&lt;p&gt;Now we can start at the &lt;code&gt;P4&lt;&#x2f;code&gt; constant and use the &lt;code&gt;next_table&lt;&#x2f;code&gt; functions to access the lower tables. And we don&#x27;t even need &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks to do it! Right now, your alarm bells should be ringing. Thanks to Rust, everything we&#x27;ve done before in this post was completely safe. But we just introduced two unsafe blocks to convince Rust that there are valid tables at the specified addresses. Can we really be sure?&lt;&#x2f;p&gt;
&lt;p&gt;First, these addresses are only valid if the P4 table is mapped recursively. Since the paging module will be the only module that modifies page tables, we can introduce an invariant for the module:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The 511th entry of the active P4 table must always be mapped to the active P4 table itself.&lt;&#x2f;em&gt;&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;So if we switch to another P4 table at some time, it needs to be identity mapped &lt;em&gt;before&lt;&#x2f;em&gt; it becomes active. As long as we obey this invariant, we can safely use the special addresses. But even with this invariant, there is a big problem with the two methods:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;em&gt;What happens if we call them on a P1 table?&lt;&#x2f;em&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Well, they would calculate the address of the next table (which does not exist) and treat it as a page table. Either they construct an invalid address (if &lt;code&gt;XXX &amp;lt; 400&lt;&#x2f;code&gt;)&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-invalid-address&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; or access the mapped page itself. That way, we could easily corrupt memory or cause CPU exceptions by accident. So these two functions are not &lt;em&gt;safe&lt;&#x2f;em&gt; in Rust terms. Thus we need to make them &lt;code&gt;unsafe&lt;&#x2f;code&gt; functions unless we find some clever solution.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;some-clever-solution&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-clever-solution&quot; aria-label=&quot;Anchor link for: some-clever-solution&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Some Clever Solution&lt;&#x2f;h2&gt;
&lt;p&gt;We can use Rust&#x27;s type system to statically guarantee that the &lt;code&gt;next_table&lt;&#x2f;code&gt; methods can only be called on P4, P3, and P2 tables, but not on a P1 table. The idea is to add a &lt;code&gt;Level&lt;&#x2f;code&gt; parameter to the &lt;code&gt;Table&lt;&#x2f;code&gt; type and implement the &lt;code&gt;next_table&lt;&#x2f;code&gt; methods only for level 4, 3, and 2.&lt;&#x2f;p&gt;
&lt;p&gt;To model the levels we use a trait and empty enums:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TableLevel {}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level4 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level3 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level2 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level1 {}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TableLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level4 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TableLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level3 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TableLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level2 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;TableLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level1 {}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;An empty enum has size zero and disappears completely after compiling. Unlike an empty struct, it&#x27;s not possible to instantiate an empty enum. Since we will use &lt;code&gt;TableLevel&lt;&#x2f;code&gt; and the table levels in exported types, they need to be public.&lt;&#x2f;p&gt;
&lt;p&gt;To differentiate the P1 table from the other tables, we introduce a &lt;code&gt;HierarchicalLevel&lt;&#x2f;code&gt; trait, which is a subtrait of &lt;code&gt;TableLevel&lt;&#x2f;code&gt;. But we implement it only for the levels 4, 3, and 2:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel: TableLevel {}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level4 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level3 {}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level2 {}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we add the level parameter to the &lt;code&gt;Table&lt;&#x2f;code&gt; type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::marker::PhantomData;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;L: TableLevel&amp;gt; {
    entries: [Entry; ENTRY_COUNT],
    level: PhantomData&amp;lt;L&amp;gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We need to add a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;marker&#x2f;struct.PhantomData.html#unused-type-parameters&quot;&gt;PhantomData&lt;&#x2f;a&gt; field because unused type parameters are not allowed in Rust.&lt;&#x2f;p&gt;
&lt;p&gt;Since we changed the &lt;code&gt;Table&lt;&#x2f;code&gt; type, we need to update every use of it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffffffff_fffff000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;L&amp;gt; Table&amp;lt;L&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; L: TableLevel
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;zero(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;L&amp;gt; Table&amp;lt;L&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; L: HierarchicalLevel
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;??&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;??&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;?&amp;gt;&amp;gt;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;L&amp;gt; Index&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;L&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; L: TableLevel {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;L&amp;gt; IndexMut&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;L&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; L: TableLevel {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the &lt;code&gt;next_table&lt;&#x2f;code&gt; methods are only available for P4, P3, and P2 tables. But they have the incomplete return type &lt;code&gt;Table&amp;lt;???&amp;gt;&lt;&#x2f;code&gt; now. What should we fill in for the &lt;code&gt;???&lt;&#x2f;code&gt;?&lt;&#x2f;p&gt;
&lt;p&gt;For a P4 table we would like to return a &lt;code&gt;Table&amp;lt;Level3&amp;gt;&lt;&#x2f;code&gt;, for a P3 table a &lt;code&gt;Table&amp;lt;Level2&amp;gt;&lt;&#x2f;code&gt;, and for a P2 table a &lt;code&gt;Table&amp;lt;Level1&amp;gt;&lt;&#x2f;code&gt;. So we want to return a table of the &lt;em&gt;next level&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We can define the next level by adding an associated type to the &lt;code&gt;HierarchicalLevel&lt;&#x2f;code&gt; trait:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel: TableLevel {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: TableLevel;
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level4 {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Level3;
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level3 {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Level2;
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;HierarchicalLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Level2 {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#4ec9b0;&quot;&gt;NextLevel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Level1;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can replace the &lt;code&gt;Table&amp;lt;???&amp;gt;&lt;&#x2f;code&gt; types with &lt;code&gt;Table&amp;lt;L::NextLevel&amp;gt;&lt;&#x2f;code&gt; types and our code works as intended. You can try it with a simple test function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
    p4.next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
      .and_then(|p3| p3.next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1337&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
      .and_then(|p2| p2.next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xdeadbeaf&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
      .and_then(|p1| p1.next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xcafebabe&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Most of the indexes are completely out of bounds, so it would panic if it&#x27;s called. But we don&#x27;t need to call it since it already fails at compile time:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error: no method named `next_table` found for type
  `&amp;amp;memory::paging::table::Table&amp;lt;memory::paging::table::Level1&amp;gt;`
  in the current scope
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Remember that this is bare metal kernel code. We just used type system magic to make low-level page table manipulations safer. Rust is just awesome!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;translating-addresses&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#translating-addresses&quot; aria-label=&quot;Anchor link for: translating-addresses&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Translating Addresses&lt;&#x2f;h2&gt;
&lt;p&gt;Now let&#x27;s do something useful with our new module. We will create a function that translates a virtual address to the corresponding physical address. We add it to the &lt;code&gt;paging&#x2f;mod.rs&lt;&#x2f;code&gt; module:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate(virtual_address: VirtualAddress)
    -&amp;gt; Option&amp;lt;PhysicalAddress&amp;gt;
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; offset &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; virtual_address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;% &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    translate_page(Page::containing_address(virtual_address))
        .map(|frame| frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; offset)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It uses two functions we haven&#x27;t defined yet: &lt;code&gt;translate_page&lt;&#x2f;code&gt; and &lt;code&gt;Page::containing_address&lt;&#x2f;code&gt;. Let&#x27;s start with the latter:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;containing_address(address: VirtualAddress) -&amp;gt; Page {
    assert!(address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x0000_8000_0000_0000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;||&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xffff_8000_0000_0000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;invalid address: 0x{:x}&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, address);
    Page { number: address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The assertion is needed because there can be invalid addresses. Addresses on x86 are just 48-bit long and the other bits are just &lt;em&gt;sign extension&lt;&#x2f;em&gt;, i.e. a copy of the most significant bit. For example:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;invalid address: 0x0000_8000_0000_0000
valid address:   0xffff_8000_0000_0000
                        â””â”€â”€ bit 47
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the address space is split into two halves: the &lt;em&gt;higher half&lt;&#x2f;em&gt; containing addresses with sign extension and the &lt;em&gt;lower half&lt;&#x2f;em&gt; containing addresses without. Everything in between is invalid.&lt;&#x2f;p&gt;
&lt;p&gt;Since we added &lt;code&gt;containing_address&lt;&#x2f;code&gt;, we add the inverse method as well (maybe we need it later):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;start_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The other missing function, &lt;code&gt;translate_page&lt;&#x2f;code&gt;, looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::Frame;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate_page(page: Page) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;table::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}.next_table(page.p4_index());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;huge_page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;|| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};

    p3.and_then(|p3| p3.next_table(page.p3_index()))
      .and_then(|p2| p2.next_table(page.p2_index()))
      .and_then(|p1| p1[page.p1_index()].pointed_frame())
      .or_else(huge_page)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use an unsafe block to convert the raw &lt;code&gt;P4&lt;&#x2f;code&gt; pointer to a reference. Then we use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;option&#x2f;enum.Option.html#method.and_then&quot;&gt;Option::and_then&lt;&#x2f;a&gt; function to go through the four table levels. If some entry along the way is &lt;code&gt;None&lt;&#x2f;code&gt;, we check if the page is a huge page through the (unimplemented) &lt;code&gt;huge_page&lt;&#x2f;code&gt; closure.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Page::p*_index&lt;&#x2f;code&gt; functions return the different table indexes. They look like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    (self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;27&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p3_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    (self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;18&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p2_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    (self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p1_index(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    (self.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0o777
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;safety-1&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety-1&quot; aria-label=&quot;Anchor link for: safety-1&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h3&gt;
&lt;p&gt;We use an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block to convert the raw &lt;code&gt;P4&lt;&#x2f;code&gt; pointer into a shared reference. It&#x27;s safe because we don&#x27;t create any &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; references to the table right now and don&#x27;t switch the P4 table either. But as soon as we do something like that, we have to revisit this method.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;huge-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#huge-pages&quot; aria-label=&quot;Anchor link for: huge-pages&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Huge Pages&lt;&#x2f;h3&gt;
&lt;p&gt;The &lt;code&gt;huge_page&lt;&#x2f;code&gt; closure calculates the corresponding frame if huge pages are used. Its content looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p3.and_then(|p3| {
      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3_entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p3[page.p3_index()];
      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; 1GiB page?
      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(start_frame) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3_entry.pointed_frame() {
          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3_entry.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
              &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; address must be 1GiB aligned
              &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assert!(start_frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;% &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
              &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(Frame {
                  number: start_frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page.p2_index() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*
                          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page.p1_index(),
              });
          }
      }
      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(p2) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3.next_table(page.p3_index()) {
          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p2_entry &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p2[page.p2_index()];
          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; 2MiB page?
          &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(start_frame) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p2_entry.pointed_frame() {
              &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p2_entry.flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
                  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; address must be 2MiB aligned
                  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assert!(start_frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;% &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;ENTRY_COUNT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;== &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
                  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(Frame {
                      number: start_frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page.p1_index()
                  });
              }
          }
      }
      None
  })
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function is much longer and more complex than the &lt;code&gt;translate_page&lt;&#x2f;code&gt; function itself. To avoid this complexity in the future, we will only work with standard 4KiB pages from now on.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;mapping-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#mapping-pages&quot; aria-label=&quot;Anchor link for: mapping-pages&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Mapping Pages&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s add a function that modifies the page tables to map a &lt;code&gt;Page&lt;&#x2f;code&gt; to a &lt;code&gt;Frame&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::entry::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::FrameAllocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map_to&amp;lt;A&amp;gt;(page: Page, frame: Frame, flags: EntryFlags,
                 allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p4.next_table_create(page.p4_index(), allocator);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3.next_table_create(page.p3_index(), allocator);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p2.next_table_create(page.p2_index(), allocator);

    assert!(p1[page.p1_index()].is_unused());
    p1[page.p1_index()].set(frame, flags &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add an re-export for all &lt;code&gt;entry&lt;&#x2f;code&gt; types since they are required to call the function. We assert that the page is unmapped and always set the present flag (since it wouldn&#x27;t make sense to map a page without setting it).&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;Table::next_table_create&lt;&#x2f;code&gt; method doesn&#x27;t exist yet. It should return the next table if it exists, or create a new one. For the implementation we need the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; from the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;#a-memory-module&quot;&gt;previous post&lt;&#x2f;a&gt; and the &lt;code&gt;Table::zero&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::FrameAllocator;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;next_table_create&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                            index: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
                            allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
                            -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;L::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;NextLevel&amp;gt;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_table(index).is_none() {
        assert!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.entries[index].flags().contains(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;HUGE_PAGE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping code does not support huge pages&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; allocator.allocate_frame().expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no frames available&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        self.entries[index].set(frame, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PRESENT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITABLE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        self.next_table_mut(index).unwrap().zero();
    }
    self.next_table_mut(index).unwrap()
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can use &lt;code&gt;unwrap()&lt;&#x2f;code&gt; here since the next table definitely exists.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;safety-2&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#safety-2&quot; aria-label=&quot;Anchor link for: safety-2&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Safety&lt;&#x2f;h3&gt;
&lt;p&gt;We used an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block in &lt;code&gt;map_to&lt;&#x2f;code&gt; to convert the raw &lt;code&gt;P4&lt;&#x2f;code&gt; pointer to a &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; reference. That&#x27;s bad. It&#x27;s now possible that the &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; reference is not exclusive, which breaks Rust&#x27;s guarantees. It&#x27;s only a matter time before we run into a data race. For example, imagine that one thread maps an entry to &lt;code&gt;frame_A&lt;&#x2f;code&gt; and another thread (on the same core) tries to map the same entry to &lt;code&gt;frame_B&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that there&#x27;s no clear &lt;em&gt;owner&lt;&#x2f;em&gt; for the page tables. So let&#x27;s define page table ownership!&lt;&#x2f;p&gt;
&lt;h3 id=&quot;page-table-ownership&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#page-table-ownership&quot; aria-label=&quot;Anchor link for: page-table-ownership&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Page Table Ownership&lt;&#x2f;h3&gt;
&lt;p&gt;We define the following:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A page table owns all of its subtables.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;We already obey this rule: To get a reference to a table, we need to borrow it from its parent table through the &lt;code&gt;next_table&lt;&#x2f;code&gt; method. But who owns the P4 table?&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The recursively mapped P4 table is owned by a &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; struct.&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;We just defined some random owner for the P4 table. But it will solve our problems. And it will also provide the interface to other modules.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s create the struct:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::table::{Table, Level4};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ptr::Unique;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    p4: Unique&amp;lt;Table&amp;lt;Level4&amp;gt;&amp;gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can&#x27;t store the &lt;code&gt;Table&amp;lt;Level4&amp;gt;&lt;&#x2f;code&gt; directly because it needs to be at a special memory location (like the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;#the-text-buffer&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;). We could use a raw pointer or &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt; instead of &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;core&#x2f;ptr&#x2f;struct.Unique.html&quot;&gt;Unique&lt;&#x2f;a&gt;, but Unique indicates ownership better.&lt;&#x2f;p&gt;
&lt;p&gt;Because the &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; owns the unique recursive mapped P4 table, there must be only one &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt; instance. Thus we make the constructor function unsafe:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; ActivePageTable {
        ActivePageTable {
            p4: Unique::new_unchecked(table::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;P4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add some methods to get P4 references:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ self.p4.as_ref() }
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ self.p4.as_mut() }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since we will only create valid P4 pointers, the &lt;code&gt;unsafe&lt;&#x2f;code&gt; blocks are safe. However, we don&#x27;t make these functions public since they can be used to make page tables invalid. Only the higher level functions (such as &lt;code&gt;translate&lt;&#x2f;code&gt; or &lt;code&gt;map_to&lt;&#x2f;code&gt;) should be usable from other modules.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can make the &lt;code&gt;map_to&lt;&#x2f;code&gt; and &lt;code&gt;translate&lt;&#x2f;code&gt; functions safe by making them methods of &lt;code&gt;ActivePageTable&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ActivePageTable {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub unsafe fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new() -&amp;gt; ActivePageTable {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4_mut(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Table&amp;lt;Level4&amp;gt; {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, virtual_address: VirtualAddress)
        -&amp;gt; Option&amp;lt;PhysicalAddress&amp;gt;
    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.translate_page(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).map(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;translate_page(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, page: Page) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.p4().next_table(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map_to&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                     page: Page,
                     frame: Frame,
                     flags: EntryFlags,
                     allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p3 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.p4_mut().next_table_create(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the &lt;code&gt;p4()&lt;&#x2f;code&gt; and &lt;code&gt;p4_mut()&lt;&#x2f;code&gt; methods should be the only methods containing an &lt;code&gt;unsafe&lt;&#x2f;code&gt; block in the &lt;code&gt;paging&#x2f;mod.rs&lt;&#x2f;code&gt; file.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;more-mapping-functions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#more-mapping-functions&quot; aria-label=&quot;Anchor link for: more-mapping-functions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
More Mapping Functions&lt;&#x2f;h3&gt;
&lt;p&gt;For convenience, we add a &lt;code&gt;map&lt;&#x2f;code&gt; method that just picks a free frame for us:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;map&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, page: Page, flags: EntryFlags, allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; allocator.allocate_frame().expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;out of memory&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    self.map_to(page, frame, flags, allocator)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We also add a &lt;code&gt;identity_map&lt;&#x2f;code&gt; function to make it easier to remap the kernel in the next post:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;identity_map&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self,
                       frame: Frame,
                       flags: EntryFlags,
                       allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(frame.start_address());
    self.map_to(page, frame, flags, allocator)
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;unmapping-pages&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unmapping-pages&quot; aria-label=&quot;Anchor link for: unmapping-pages&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Unmapping Pages&lt;&#x2f;h3&gt;
&lt;p&gt;To unmap a page, we set the corresponding P1 entry to unused:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;unmap&amp;lt;A&amp;gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, page: Page, allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    assert!(self.translate(page.start_address()).is_some());

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.p4_mut()
                 .next_table_mut(page.p4_index())
                 .and_then(|p3| p3.next_table_mut(page.p3_index()))
                 .and_then(|p2| p2.next_table_mut(page.p2_index()))
                 .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;mapping code does not support huge pages&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; p1[page.p1_index()].pointed_frame().unwrap();
    p1[page.p1_index()].set_unused();
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO free p(1,2,3) table if empty
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;    allocator.deallocate_frame(frame);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The assertion ensures that the page is mapped. Thus the corresponding P1 table and frame must exist for a standard 4KiB page. We set the entry to unused and free the associated frame in the supplied frame allocator.&lt;&#x2f;p&gt;
&lt;p&gt;We can also free the P1, P2, or even P3 table when the last entry is freed. But checking the whole table on every &lt;code&gt;unmap&lt;&#x2f;code&gt; would be very expensive. So we leave the &lt;code&gt;TODO&lt;&#x2f;code&gt; in place until we find a good solution. I&#x27;m open for suggestions :).&lt;&#x2f;p&gt;
&lt;p&gt;&lt;em&gt;Spoiler&lt;&#x2f;em&gt;: There is an ugly bug in this function, which we will find in the next section.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;testing-and-bugfixing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-and-bugfixing&quot; aria-label=&quot;Anchor link for: testing-and-bugfixing&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing and Bugfixing&lt;&#x2f;h2&gt;
&lt;p&gt;To test it, we add a &lt;code&gt;test_paging&lt;&#x2f;code&gt; function in &lt;code&gt;memory&#x2f;paging&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;test_paging&amp;lt;A&amp;gt;(allocator: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;where&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; A: FrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page_table &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ ActivePageTable::new() };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; test it
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We borrow the frame allocator since we will need it for the mapping functions. To be able to call that function from main, we need to re-export it in &lt;code&gt;memory&#x2f;mod.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in memory&#x2f;mod.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self::paging::test_paging;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= ...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
memory::test_paging(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;map-to&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#map-to&quot; aria-label=&quot;Anchor link for: map-to&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
map_to&lt;&#x2f;h3&gt;
&lt;p&gt;Let&#x27;s test the &lt;code&gt;map_to&lt;&#x2f;code&gt; function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;512 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; 42th P3 entry
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; page &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Page::containing_address(addr);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; allocator.allocate_frame().expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;no more frames&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;None = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, map to &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
         page_table.translate(addr),
         frame);
page_table.map_to(page, frame, EntryFlags::empty(), allocator);
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Some = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, page_table.translate(addr));
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;next free frame: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, allocator.allocate_frame());
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We just map some random page to a free frame. To be able to borrow the page table as &lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt;, we need to make it mutable.&lt;&#x2f;p&gt;
&lt;p&gt;You should see output similar to this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None = None, map to Frame { number: 0 }
Some = Some(0)
next free frame: Some(Frame { number: 3 })
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s frame 0 because it&#x27;s the first frame returned by the frame allocator. Since we map the 42th P3 entry, the mapping code needs to create a P2 and a P1 table. So the next free frame returned by the allocator is frame 3.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;unmap&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#unmap&quot; aria-label=&quot;Anchor link for: unmap&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
unmap&lt;&#x2f;h3&gt;
&lt;p&gt;To test the &lt;code&gt;unmap&lt;&#x2f;code&gt; function, we unmap the test page so that it translates to &lt;code&gt;None&lt;&#x2f;code&gt; again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;page_table.unmap(Page::containing_address(addr), allocator);
println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;None = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, page_table.translate(addr));
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It causes a panic since we call the unimplemented &lt;code&gt;deallocate_frame&lt;&#x2f;code&gt; method in &lt;code&gt;unmap&lt;&#x2f;code&gt;. If we comment this call out, it works without problems. But there is some bug in this function nevertheless.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s read something from the mapped page (of course before we unmap it again):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:#x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(Page::containing_address(addr).start_address() &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *const u64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
});
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since we don&#x27;t zero the mapped pages, the output is random. For me, it&#x27;s &lt;code&gt;0xf000ff53f000ff53&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;If &lt;code&gt;unmap&lt;&#x2f;code&gt; worked correctly, reading it again after unmapping should cause a page fault. But it doesn&#x27;t. Instead, it just prints the same number again. When we remove the first read, we get the desired page fault (i.e. QEMU reboots again and again). So this seems to be some cache issue.&lt;&#x2f;p&gt;
&lt;p&gt;An x86 processor has many different caches because always accessing the main memory would be very slow. Most of these caches are completely &lt;em&gt;transparent&lt;&#x2f;em&gt;. That means everything works exactly the same as without them, it&#x27;s just much faster. But there is one cache, that needs to be updated manually: the &lt;em&gt;translation lookaside buffer&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The translation lookaside buffer, or TLB, caches the translation of virtual to physical addresses. It&#x27;s filled automatically when a page is accessed. But it&#x27;s not updated transparently when the mapping of a page changes. This is the reason that we still can access the page even through we unmapped it in the page table.&lt;&#x2f;p&gt;
&lt;p&gt;So to fix our &lt;code&gt;unmap&lt;&#x2f;code&gt; function, we need to remove the cached translation from the TLB. We can use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;x86_64&quot;&gt;x86_64&lt;&#x2f;a&gt; crate to do this easily. To add it, we append the following to our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;x86_64 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.2&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can use it to fix &lt;code&gt;unmap&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
    p1[page.p1_index()].set_unused();

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::instructions::tlb;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x86_64::VirtualAddress;
    tlb::flush(VirtualAddress(page.start_address()));

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO free p(1,2,3) table if empty
    &#x2f;&#x2f;allocator.deallocate_frame(frame);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the desired page fault occurs even when we access the page before.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Conclusion&lt;&#x2f;h2&gt;
&lt;p&gt;This post has become pretty long. So let&#x27;s summarize what we&#x27;ve done:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;we created a paging module and modeled page tables plus entries&lt;&#x2f;li&gt;
&lt;li&gt;we mapped the P4 page recursively and created &lt;code&gt;next_table&lt;&#x2f;code&gt; methods&lt;&#x2f;li&gt;
&lt;li&gt;we used empty enums and associated types to make the &lt;code&gt;next_table&lt;&#x2f;code&gt; functions safe&lt;&#x2f;li&gt;
&lt;li&gt;we wrote a function to translate virtual to physical addresses&lt;&#x2f;li&gt;
&lt;li&gt;we created safe functions to map and unmap pages&lt;&#x2f;li&gt;
&lt;li&gt;and we fixed stack overflow and TLB related bugs&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;remap-the-kernel&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; we will extend this module and add a function to modify inactive page tables. Through that function, we will create a new page table hierarchy that maps the kernel correctly using 4KiB pages. Then we will switch to the new table to get a safer kernel environment.&lt;&#x2f;p&gt;
&lt;p&gt;Afterwards, we will use this paging module to build a heap allocator. This will allow us to use allocation and collection types such as &lt;code&gt;Box&lt;&#x2f;code&gt; and &lt;code&gt;Vec&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;&lt;small&gt;Image sources: &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#virtual_physical_translation_source&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;&lt;&#x2f;small&gt;&lt;&#x2f;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-invalid-address&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;If the &lt;code&gt;XXX&lt;&#x2f;code&gt; part of the address is smaller than &lt;code&gt;0o400&lt;&#x2f;code&gt;, it&#x27;s binary representation doesn&#x27;t start with &lt;code&gt;1&lt;&#x2f;code&gt;. But the sign extension bits, which should be a copy of that bit, are &lt;code&gt;1&lt;&#x2f;code&gt; instead of &lt;code&gt;0&lt;&#x2f;code&gt;. Thus the address is not valid.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;virtual_physical_translation_source&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;Image sources: Modified versions of an image from  &lt;a href=&quot;https:&#x2f;&#x2f;commons.wikimedia.org&#x2f;wiki&#x2f;File:X86_Paging_64bit.svg&quot;&gt;Wikipedia&lt;&#x2f;a&gt;. The modified files are licensed under the Creative Commons Attribution-Share Alike 3.0 Unported license.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Allocating Frames</title>
                <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/allocating-frames/</link>
                <guid>https://os.phil-opp.com/allocating-frames/</guid>
                <description>&lt;p&gt;In this post we create an allocator that provides free physical frames for a future paging module. To get the required information about available and used memory we use the Multiboot information structure. Additionally, we improve the &lt;code&gt;panic&lt;&#x2f;code&gt; handler to print the corresponding message and source line.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The full source code is available on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_5&quot;&gt;GitHub&lt;&#x2f;a&gt;. Feel free to open issues there if you have any problems or improvements. You can also leave a comment at the bottom.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;preparation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#preparation&quot; aria-label=&quot;Anchor link for: preparation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Preparation&lt;&#x2f;h2&gt;
&lt;p&gt;We still have a really tiny stack of 64 bytes, which won&#x27;t suffice for this post. So we increase it to 16kB (four pages) in &lt;code&gt;boot.asm&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section .bss
...
stack_bottom:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;* &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_top:
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;the-multiboot-information-structure&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-multiboot-information-structure&quot; aria-label=&quot;Anchor link for: the-multiboot-information-structure&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Multiboot Information Structure&lt;&#x2f;h2&gt;
&lt;p&gt;When a Multiboot compliant bootloader loads a kernel, it passes a pointer to a boot information structure in the &lt;code&gt;ebx&lt;&#x2f;code&gt; register. We can use it to get information about available memory and loaded kernel sections.&lt;&#x2f;p&gt;
&lt;p&gt;First, we need to pass this pointer to our kernel as an argument to &lt;code&gt;rust_main&lt;&#x2f;code&gt;. To find out how arguments are passed to functions, we can look at the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86_calling_conventions#System_V_AMD64_ABI&quot;&gt;calling convention of Linux&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9&lt;&#x2f;p&gt;
&lt;&#x2f;blockquote&gt;
&lt;p&gt;So to pass the pointer to our kernel, we need to move it to &lt;code&gt;rdi&lt;&#x2f;code&gt; before calling the kernel. Since we&#x27;re not using the &lt;code&gt;rdi&lt;&#x2f;code&gt;&#x2f;&lt;code&gt;edi&lt;&#x2f;code&gt; register in our bootstrap code, we can simply set the &lt;code&gt;edi&lt;&#x2f;code&gt; register right after booting (in &lt;code&gt;boot.asm&lt;&#x2f;code&gt;):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;start:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;esp, stack_top
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;edi, ebx&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; Move Multiboot info pointer to edi
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can add the argument to our &lt;code&gt;rust_main&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main(multiboot_information_address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) { &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;... &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of writing an own Multiboot module, we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;multiboot2&quot;&gt;multiboot2&lt;&#x2f;a&gt; crate. It gives us some basic information about mapped kernel sections and available memory. I just wrote it for this blog post since I could not find any other Multiboot 2 crate. It&#x27;s still incomplete, but it does its job.&lt;&#x2f;p&gt;
&lt;p&gt;So let&#x27;s add a dependency on the git repository:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;multiboot2 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot2;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can use it to print available memory areas.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;available-memory&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#available-memory&quot; aria-label=&quot;Anchor link for: available-memory&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Available Memory&lt;&#x2f;h3&gt;
&lt;p&gt;The boot information structure consists of various &lt;em&gt;tags&lt;&#x2f;em&gt;. See section 3.4 of the Multiboot specification (&lt;a href=&quot;http:&#x2f;&#x2f;nongnu.askapache.com&#x2f;grub&#x2f;phcoder&#x2f;multiboot.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) for a complete list. The &lt;em&gt;memory map&lt;&#x2f;em&gt; tag contains a list of all available RAM areas. Special areas such as the VGA text buffer at &lt;code&gt;0xb8000&lt;&#x2f;code&gt; are not available. Note that some of the available memory is already used by our kernel and by the multiboot information structure itself.&lt;&#x2f;p&gt;
&lt;p&gt;To print all available memory areas, we can use the &lt;code&gt;multiboot2&lt;&#x2f;code&gt; crate in our &lt;code&gt;rust_main&lt;&#x2f;code&gt; as follows:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= unsafe&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ multiboot2::load(multiboot_information_address) };
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.memory_map_tag()
    .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Memory map tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;memory areas:&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; area &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; memory_map_tag.memory_areas() {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    start: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, length: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        area.base_addr, area.length);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;load&lt;&#x2f;code&gt; function is &lt;code&gt;unsafe&lt;&#x2f;code&gt; because it relies on a valid address. Since the memory tag is not required by the Multiboot specification, the &lt;code&gt;memory_map_tag()&lt;&#x2f;code&gt; function returns an &lt;code&gt;Option&lt;&#x2f;code&gt;. The &lt;code&gt;memory_areas()&lt;&#x2f;code&gt; function returns the desired memory area iterator.&lt;&#x2f;p&gt;
&lt;p&gt;The output looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Hello World!
memory areas:
    start: 0x0, length: 0x9fc00
    start: 0x100000, length: 0x7ee0000
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So we have one area from &lt;code&gt;0x0&lt;&#x2f;code&gt; to &lt;code&gt;0x9fc00&lt;&#x2f;code&gt;, which is a bit below the 1MiB mark. The second, bigger area starts at 1MiB and contains the rest of available memory. The area from &lt;code&gt;0x9fc00&lt;&#x2f;code&gt; to 1MiB is not available since it contains for example the VGA text buffer at &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. This is the reason for putting our kernel at 1MiB and not somewhere below.&lt;&#x2f;p&gt;
&lt;p&gt;If you give QEMU more than 4GiB of memory by passing &lt;code&gt;-m 5G&lt;&#x2f;code&gt;, you get another unusable area below the 4GiB mark. This memory is normally mapped to some hardware devices. See the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Memory_Map_(x86)&quot;&gt;OSDev Wiki&lt;&#x2f;a&gt; for more information.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;handling-panics&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#handling-panics&quot; aria-label=&quot;Anchor link for: handling-panics&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Handling Panics&lt;&#x2f;h3&gt;
&lt;p&gt;We used &lt;code&gt;expect&lt;&#x2f;code&gt; in the code above, which will panic if there is no memory map tag. But our current panic handler just loops without printing any error message. Of course we could replace &lt;code&gt;expect&lt;&#x2f;code&gt; by a &lt;code&gt;match&lt;&#x2f;code&gt;, but we should fix the panic handler nonetheless:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[lang &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic_fmt() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;PANIC&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we get a &lt;code&gt;PANIC&lt;&#x2f;code&gt; message. But we can do even better. The &lt;code&gt;panic_fmt&lt;&#x2f;code&gt; function has actually some arguments:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[lang &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic_fmt(fmt: core::fmt::Arguments, file: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    line: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u32&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;!
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;PANIC in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; at line &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;:&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, file, line);
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, fmt);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Be careful with these arguments as the compiler does not check the function signature for &lt;code&gt;lang_items&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now we get the panic message and the causing source line. You can try it by inserting a &lt;code&gt;panic&lt;&#x2f;code&gt; somewhere.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;kernel-elf-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#kernel-elf-sections&quot; aria-label=&quot;Anchor link for: kernel-elf-sections&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Kernel ELF Sections&lt;&#x2f;h3&gt;
&lt;p&gt;To read and print the sections of our kernel ELF file, we can use the &lt;em&gt;Elf-sections&lt;&#x2f;em&gt; tag:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; boot_info.elf_sections_tag()
    .expect(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Elf-sections tag required&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;kernel sections:&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; section &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections() {
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;    addr: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, size: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;, flags: 0x&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:x}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        section.addr, section.size, section.flags);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This should print out the start address and size of all kernel sections. If the section is writable, the &lt;code&gt;0x1&lt;&#x2f;code&gt; bit is set in &lt;code&gt;flags&lt;&#x2f;code&gt;. The &lt;code&gt;0x4&lt;&#x2f;code&gt; bit marks an executable section and the &lt;code&gt;0x2&lt;&#x2f;code&gt; bit indicates that the section was loaded in memory. For example, the &lt;code&gt;.text&lt;&#x2f;code&gt; section is executable but not writable and the &lt;code&gt;.data&lt;&#x2f;code&gt; section just the opposite.&lt;&#x2f;p&gt;
&lt;p&gt;But when we execute it, tons of really small sections are printed. We can use the &lt;code&gt;objdump -h build&#x2f;kernel-x86_64.bin&lt;&#x2f;code&gt; command to list the sections with name. There seem to be over 200 sections and many of them start with &lt;code&gt;.text.*&lt;&#x2f;code&gt; or &lt;code&gt;.data.rel.ro.local.*&lt;&#x2f;code&gt;. This is because the Rust compiler puts e.g. each function in its own &lt;code&gt;.text&lt;&#x2f;code&gt; subsection. That way, unused functions are removed when the linker omits unused sections.&lt;&#x2f;p&gt;
&lt;p&gt;To merge these subsections, we need to update our linker script:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ENTRY(start)

SECTIONS {
    . = 1M;

    .boot :
    {
        KEEP(*(.multiboot_header))
    }

    .text :
    {
        *(.text .text.*)
    }

    .rodata : {
        *(.rodata .rodata.*)
    }

    .data.rel.ro : {
        *(.data.rel.ro.local*) *(.data.rel.ro .data.rel.ro.*)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;These lines are taken from the default linker script of &lt;code&gt;ld&lt;&#x2f;code&gt;, which can be obtained through &lt;code&gt;ldÂ â€‘verbose&lt;&#x2f;code&gt;. The &lt;code&gt;.text&lt;&#x2f;code&gt; &lt;em&gt;output&lt;&#x2f;em&gt; section contains now all &lt;code&gt;.text.*&lt;&#x2f;code&gt; &lt;em&gt;input&lt;&#x2f;em&gt; sections of the static library (and the same applies for the &lt;code&gt;.rodata&lt;&#x2f;code&gt; and &lt;code&gt;.data.rel.ro&lt;&#x2f;code&gt; sections).&lt;&#x2f;p&gt;
&lt;p&gt;Now there are only 12 sections left and we get a much more useful output:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;qemu-memory-areas-and-kernel-sections.png&quot; alt=&quot;qemu output&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;If you like, you can compare this output to the &lt;code&gt;objdump -h build&#x2f;kernel-x86_64.bin&lt;&#x2f;code&gt; output. You will see that the start addresses and sizes match exactly for each section. The sections with flags &lt;code&gt;0x0&lt;&#x2f;code&gt; are mostly debug sections, so they don&#x27;t need to be loaded. And the last few sections of the QEMU output aren&#x27;t in the &lt;code&gt;objdump&lt;&#x2f;code&gt; output because they are special sections such as string tables.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;start-and-end-of-kernel&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#start-and-end-of-kernel&quot; aria-label=&quot;Anchor link for: start-and-end-of-kernel&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Start and End of Kernel&lt;&#x2f;h3&gt;
&lt;p&gt;We can now use the ELF section tag to calculate the start and end address of our loaded kernel:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections().map(|s| s.addr)
    .min().unwrap();
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; elf_sections_tag.sections().map(|s| s.addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.size)
    .max().unwrap();
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The other used memory area is the Multiboot Information structure:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_information_address;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(boot_info.total_size &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Printing these numbers gives us:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel_start: 0x100000, kernel_end: 0x11a168
multiboot_start: 0x11d400, multiboot_end: 0x11d9c8
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the kernel starts at 1MiB (like expected) and is about 105 KiB in size. The multiboot information structure was placed at &lt;code&gt;0x11d400&lt;&#x2f;code&gt; by GRUB and needs 1480 bytes. Of course your numbers could be a bit different due to different versions of Rust or GRUB (or some differences in the source code).&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-frame-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-frame-allocator&quot; aria-label=&quot;Anchor link for: a-frame-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A frame allocator&lt;&#x2f;h2&gt;
&lt;p&gt;When using paging, the physical memory is split into equally sized chunks (normally 4096 bytes) Such a chunk is called &amp;quot;physical page&amp;quot; or &amp;quot;frame&amp;quot;. These frames can be mapped to any virtual page through page tables. For more information about paging take a peek at the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;We will need a free frame in many cases. For example when want to increase the size of our future kernel heap. Or when we create a new page table. Or when we add a new kernel thread and thus need to allocate a new stack. So we need some kind of allocator that keeps track of physical frames and gives us a free one when needed.&lt;&#x2f;p&gt;
&lt;p&gt;There are various ways to write such a frame allocator:&lt;&#x2f;p&gt;
&lt;p&gt;We could create some kind of linked list from the free frames. For example, each frame could begin with a pointer to the next free frame. Since the frames are free, this would not overwrite any data. Our allocator would just save the head of the list and could easily allocate and deallocate frames by updating pointers. Unfortunately, this approach has a problem: It requires reading and writing these free frames. So we would need to map all physical frames to some virtual address, at least temporary. Another disadvantage is that we need to create this linked list at startup. That implies that we need to set over one million pointers at startup if the machine has 4GiB of RAM.&lt;&#x2f;p&gt;
&lt;p&gt;Another approach is to create some kind of data structure such as a &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Page_Frame_Allocation#Physical_Memory_Allocators&quot;&gt;bitmap or a stack&lt;&#x2f;a&gt; to manage free frames. We could place it in the already identity mapped area right behind the kernel or multiboot structure. That way we would not need to (temporary) map each free frame. But it has the same problem of the slow initial creating&#x2f;filling. In fact, we will use this approach in a future post to manage frames that are freed again. But for the initial management of free frames, we use a different method.&lt;&#x2f;p&gt;
&lt;p&gt;In the following, we will use Multiboot&#x27;s memory map directly. The idea is to maintain a simple counter that starts at frame 0 and is increased constantly. If the current frame is available (part of an available area in the memory map) and not used by the kernel or the multiboot structure (we know their start and end addresses), we know that it&#x27;s free and return it. Else, we increase the counter to the next possibly free frame. That way, we don&#x27;t need to create a data structure when booting and the physical frames can remain unmapped. The only problem is that we cannot reasonably free frames again, but we will solve that problem in a future post (by adding an intermediate frame stack that saves freed frames).&lt;&#x2f;p&gt;
&lt;!--- TODO link future post --&gt;
&lt;p&gt;So let&#x27;s start implementing our memory map based frame allocator.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-memory-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-memory-module&quot; aria-label=&quot;Anchor link for: a-memory-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Memory Module&lt;&#x2f;h3&gt;
&lt;p&gt;First we create a memory module with a &lt;code&gt;Frame&lt;&#x2f;code&gt; type (&lt;code&gt;src&#x2f;memory&#x2f;mod.rs&lt;&#x2f;code&gt;):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame {
    number: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;(Don&#x27;t forget to add the &lt;code&gt;mod memory&lt;&#x2f;code&gt; line to &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;.) Instead of e.g. the start address, we just store the frame number. We use &lt;code&gt;usize&lt;&#x2f;code&gt; here since the number of frames depends on the memory size. The long &lt;code&gt;derive&lt;&#x2f;code&gt; line makes frames printable and comparable.&lt;&#x2f;p&gt;
&lt;p&gt;To make it easy to get the corresponding frame for a physical address, we add a &lt;code&gt;containing_address&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4096&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;containing_address(address: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; Frame {
        Frame{ number: address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;PAGE_SIZE &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We also add a &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub trait &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deallocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, frame: Frame);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This allows us to create another, more advanced frame allocator in the future.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-allocator&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-allocator&quot; aria-label=&quot;Anchor link for: the-allocator&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Allocator&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can put everything together and create the actual frame allocator. Therefor we create a &lt;code&gt;src&#x2f;memory&#x2f;area_frame_allocator.rs&lt;&#x2f;code&gt; submodule. The allocator struct looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::{Frame, FrameAllocator};
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;multiboot2::{MemoryAreaIter, MemoryArea};

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;AreaFrameAllocator {
    next_free_frame: Frame,
    current_area: Option&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;#39;static&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; MemoryArea&amp;gt;,
    areas: MemoryAreaIter,
    kernel_start: Frame,
    kernel_end: Frame,
    multiboot_start: Frame,
    multiboot_end: Frame,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;next_free_frame&lt;&#x2f;code&gt; field is a simple counter that is increased every time we return a frame. It&#x27;s initialized to &lt;code&gt;0&lt;&#x2f;code&gt; and every frame below it counts as used. The &lt;code&gt;current_area&lt;&#x2f;code&gt; field holds the memory area that contains &lt;code&gt;next_free_frame&lt;&#x2f;code&gt;. If &lt;code&gt;next_free_frame&lt;&#x2f;code&gt; leaves this area, we will look for the next one in &lt;code&gt;areas&lt;&#x2f;code&gt;. When there are no areas left, all frames are used and &lt;code&gt;current_area&lt;&#x2f;code&gt; becomes &lt;code&gt;None&lt;&#x2f;code&gt;. The &lt;code&gt;{kernel, multiboot}_{start, end}&lt;&#x2f;code&gt; fields are used to avoid returning already used fields.&lt;&#x2f;p&gt;
&lt;p&gt;To implement the &lt;code&gt;FrameAllocator&lt;&#x2f;code&gt; trait, we need to implement the allocation and deallocation methods:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;AreaFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO (see below)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deallocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, frame: Frame) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; TODO (see below)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;allocate_frame&lt;&#x2f;code&gt; method looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `allocate_frame` in `impl FrameAllocator for AreaFrameAllocator`

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(area) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.current_area {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; &amp;quot;Clone&amp;quot; the frame to return it if it&amp;#39;s free. Frame doesn&amp;#39;t
    &#x2f;&#x2f; implement Clone, but we can construct an identical frame.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Frame{ number: self.next_free_frame.number };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; the last frame of the current area
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; current_area_last_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; area.base_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; area.length &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        Frame::containing_address(address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)
    };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; current_area_last_frame {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; all frames of current area are used, switch to next area
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.choose_next_area();
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.kernel_end {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; `frame` is used by the kernel
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Frame {
            number: self.kernel_end.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else if&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.multiboot_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.multiboot_end {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; `frame` is used by the multiboot information structure
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Frame {
            number: self.multiboot_end.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
    } &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; frame is unused, increment `next_free_frame` and return it
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free_frame.number &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;return &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(frame);
    }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; `frame` was not valid, try it again with the updated `next_free_frame`
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.allocate_frame()
} &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;else &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    None &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; no free frames left
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;choose_next_area&lt;&#x2f;code&gt; method isn&#x27;t part of the trait and thus goes into a new &lt;code&gt;implÂ AreaFrameAllocator&lt;&#x2f;code&gt; block:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `impl AreaFrameAllocator`

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;choose_next_area(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
    self.current_area &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.areas.clone().filter(|area| {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; area.base_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; area.length &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
        Frame::containing_address(address &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free_frame
    }).min_by_key(|area| area.base_addr);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Some(area) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.current_area {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; start_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Frame::containing_address(area.base_addr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.next_free_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; start_frame {
            self.next_free_frame &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; start_frame;
        }
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This function chooses the area with the minimal base address that still has free frames, i.e. &lt;code&gt;next_free_frame&lt;&#x2f;code&gt; is smaller than its last frame. Note that we need to clone the iterator because the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.min_by_key&quot;&gt;min_by_key&lt;&#x2f;a&gt; function consumes it. If there are no areas with free frames left, &lt;code&gt;min_by_key&lt;&#x2f;code&gt; automatically returns the desired &lt;code&gt;None&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;If the &lt;code&gt;next_free_frame&lt;&#x2f;code&gt; is below the new &lt;code&gt;current_area&lt;&#x2f;code&gt;, it needs to be updated to the area&#x27;s start frame. Else, the &lt;code&gt;allocate_frame&lt;&#x2f;code&gt; call could return an unavailable frame.&lt;&#x2f;p&gt;
&lt;p&gt;We don&#x27;t have a data structure to store free frames, so we can&#x27;t implement &lt;code&gt;deallocate_frame&lt;&#x2f;code&gt; reasonably. Thus we use the &lt;code&gt;unimplemented&lt;&#x2f;code&gt; macro, which just panics when the method is called:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;FrameAllocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;AreaFrameAllocator {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;allocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; Option&amp;lt;Frame&amp;gt; {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; described above
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;deallocate_frame(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, _frame: Frame) {
        unimplemented!()
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we only need a constructor function to make the allocator usable:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(kernel_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, kernel_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
      multiboot_start: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, multiboot_end: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
      memory_areas: MemoryAreaIter) -&amp;gt; AreaFrameAllocator
{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; AreaFrameAllocator {
        next_free_frame: Frame::containing_address(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;),
        current_area: None,
        areas: memory_areas,
        kernel_start: Frame::containing_address(kernel_start),
        kernel_end: Frame::containing_address(kernel_end),
        multiboot_start: Frame::containing_address(multiboot_start),
        multiboot_end: Frame::containing_address(multiboot_end),
    };
    allocator.choose_next_area();
    allocator
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we call &lt;code&gt;choose_next_area&lt;&#x2f;code&gt; manually here because &lt;code&gt;allocate_frame&lt;&#x2f;code&gt; returns &lt;code&gt;None&lt;&#x2f;code&gt; as soon as &lt;code&gt;current_area&lt;&#x2f;code&gt; is &lt;code&gt;None&lt;&#x2f;code&gt;. So by calling &lt;code&gt;choose_next_area&lt;&#x2f;code&gt; we initialize it to the area with the minimal base address.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;testing-it&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#testing-it&quot; aria-label=&quot;Anchor link for: testing-it&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Testing it&lt;&#x2f;h3&gt;
&lt;p&gt;In order to test it in main, we need to &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;crates-and-modules.html#re-exporting-with-pub-use&quot;&gt;re-export&lt;&#x2f;a&gt; the &lt;code&gt;AreaFrameAllocator&lt;&#x2f;code&gt; in the &lt;code&gt;memory&lt;&#x2f;code&gt; module. Then we can create a new allocator:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;memory::AreaFrameAllocator::new(
    kernel_start &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, kernel_end &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, multiboot_start,
    multiboot_end, memory_map_tag.memory_areas());
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can test it by adding some frame allocations:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{:?}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, frame_allocator.allocate_frame());
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You will see that the frame number starts at &lt;code&gt;0&lt;&#x2f;code&gt; and increases steadily, but the kernel and Multiboot frames are left out (you need to allocate many frames to see this since the kernel starts at frame 256).&lt;&#x2f;p&gt;
&lt;p&gt;The following &lt;code&gt;for&lt;&#x2f;code&gt; loop allocates all frames and prints out the total number of allocated frames:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; i &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;.. &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if let &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;None &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; frame_allocator.allocate_frame() {
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;allocated &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; frames&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, i);
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;break&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You can try different amounts of memory by passing e.g. &lt;code&gt;-m 500M&lt;&#x2f;code&gt; to QEMU. To compare these numbers, &lt;a href=&quot;http:&#x2f;&#x2f;www.wolframalpha.com&#x2f;input&#x2f;?i=%2832605+*+4096%29+bytes+in+MiB&quot;&gt;WolframAlpha&lt;&#x2f;a&gt; can be very helpful.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#conclusion&quot; aria-label=&quot;Anchor link for: conclusion&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Conclusion&lt;&#x2f;h2&gt;
&lt;p&gt;Now we have a working frame allocator. It is a bit rudimentary and cannot free frames, but it also is very fast since it reuses the Multiboot memory map and does not need any costly initialization. A future post will build upon this allocator and add a stack-like data structure for freed frames.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;page-tables&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; will be about paging again. We will use the frame allocator to create a safe module that allows us to switch page tables and map pages. Then we will use this module and the information from the Elf-sections tag to remap the kernel correctly.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;recommended-posts&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#recommended-posts&quot; aria-label=&quot;Anchor link for: recommended-posts&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Recommended Posts&lt;&#x2f;h2&gt;
&lt;p&gt;Eric Kidd started the &lt;a href=&quot;http:&#x2f;&#x2f;www.randomhacks.net&#x2f;bare-metal-rust&#x2f;&quot;&gt;Bare Metal Rust&lt;&#x2f;a&gt; series last week. Like this post, it builds upon the code from &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;&quot;&gt;Printing to Screen&lt;&#x2f;a&gt;, but tries to support keyboard input instead of wrestling through memory management details.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Printing to Screen</title>
                <pubDate>Fri, 23 Oct 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/printing-to-screen/</link>
                <guid>https://os.phil-opp.com/printing-to-screen/</guid>
                <description>&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt; we switched from assembly to &lt;a href=&quot;https:&#x2f;&#x2f;www.rust-lang.org&#x2f;&quot;&gt;Rust&lt;&#x2f;a&gt;, a systems programming language that provides great safety. But so far we are using unsafe features like &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;raw-pointers.html&quot;&gt;raw pointers&lt;&#x2f;a&gt; whenever we want to print to screen. In this post we will create a Rust module that provides a safe and easy-to-use interface for the VGA text buffer. It will support Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;std&#x2f;fmt&#x2f;#related-macros&quot;&gt;formatting macros&lt;&#x2f;a&gt;, too.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This post uses recent unstable features, so you need an up-to-date nighly compiler. If you have any questions, problems, or suggestions please &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;file an issue&lt;&#x2f;a&gt; or create a comment at the bottom. The code from this post is also available on &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_4&quot;&gt;GitHub&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-vga-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-vga-text-buffer&quot; aria-label=&quot;Anchor link for: the-vga-text-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The VGA Text Buffer&lt;&#x2f;h2&gt;
&lt;p&gt;The text buffer starts at physical address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; and contains the characters displayed on screen. It has 25 rows and 80 columns. Each screen character has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s) &lt;&#x2f;th&gt;&lt;th&gt;Value&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-7    &lt;&#x2f;td&gt;&lt;td&gt;ASCII code point&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8-11   &lt;&#x2f;td&gt;&lt;td&gt;Foreground color&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;12-14  &lt;&#x2f;td&gt;&lt;td&gt;Background color&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;15     &lt;&#x2f;td&gt;&lt;td&gt;Blink&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;The following colors are available:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Number &lt;&#x2f;th&gt;&lt;th&gt;Color      &lt;&#x2f;th&gt;&lt;th&gt;Number + Bright Bit &lt;&#x2f;th&gt;&lt;th&gt;Bright Color&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0x0    &lt;&#x2f;td&gt;&lt;td&gt;Black      &lt;&#x2f;td&gt;&lt;td&gt;0x8                 &lt;&#x2f;td&gt;&lt;td&gt;Dark Gray&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x1    &lt;&#x2f;td&gt;&lt;td&gt;Blue       &lt;&#x2f;td&gt;&lt;td&gt;0x9                 &lt;&#x2f;td&gt;&lt;td&gt;Light Blue&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x2    &lt;&#x2f;td&gt;&lt;td&gt;Green      &lt;&#x2f;td&gt;&lt;td&gt;0xa                 &lt;&#x2f;td&gt;&lt;td&gt;Light Green&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x3    &lt;&#x2f;td&gt;&lt;td&gt;Cyan       &lt;&#x2f;td&gt;&lt;td&gt;0xb                 &lt;&#x2f;td&gt;&lt;td&gt;Light Cyan&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x4    &lt;&#x2f;td&gt;&lt;td&gt;Red        &lt;&#x2f;td&gt;&lt;td&gt;0xc                 &lt;&#x2f;td&gt;&lt;td&gt;Light Red&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x5    &lt;&#x2f;td&gt;&lt;td&gt;Magenta    &lt;&#x2f;td&gt;&lt;td&gt;0xd                 &lt;&#x2f;td&gt;&lt;td&gt;Pink&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x6    &lt;&#x2f;td&gt;&lt;td&gt;Brown      &lt;&#x2f;td&gt;&lt;td&gt;0xe                 &lt;&#x2f;td&gt;&lt;td&gt;Yellow&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;0x7    &lt;&#x2f;td&gt;&lt;td&gt;Light Gray &lt;&#x2f;td&gt;&lt;td&gt;0xf                 &lt;&#x2f;td&gt;&lt;td&gt;White&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Bit 4 is the &lt;em&gt;bright bit&lt;&#x2f;em&gt;, which turns for example blue into light blue. It is unavailable in background color as the bit is used to control if the text should blink. If you want to use a light background color (e.g. white) you have to disable blinking through a &lt;a href=&quot;http:&#x2f;&#x2f;www.ctyme.com&#x2f;intr&#x2f;rb-0117.htm&quot;&gt;BIOS function&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-basic-rust-module&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-basic-rust-module&quot; aria-label=&quot;Anchor link for: a-basic-rust-module&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A basic Rust Module&lt;&#x2f;h2&gt;
&lt;p&gt;Now that we know how the VGA buffer works, we can create a Rust module to handle printing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f;â€¯in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The content of this module can live either in &lt;code&gt;src&#x2f;vga_buffer.rs&lt;&#x2f;code&gt; or &lt;code&gt;src&#x2f;vga_buffer&#x2f;mod.rs&lt;&#x2f;code&gt;. The latter supports submodules while the former does not. But our module does not need any submodules so we create it as &lt;code&gt;src&#x2f;vga_buffer.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;All of the code below goes into our new module (unless specified otherwise).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;colors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#colors&quot; aria-label=&quot;Anchor link for: colors&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Colors&lt;&#x2f;h3&gt;
&lt;p&gt;First, we represent the different colors using an enum:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[allow(dead_code)]
#[repr(u8)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Color {
    Black      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Blue       &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Green      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Cyan       &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Red        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Magenta    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;5&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Brown      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightGray  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;7&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    DarkGray   &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightBlue  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;9&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightGreen &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;10&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightCyan  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    LightRed   &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;12&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Pink       &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;13&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    Yellow     &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;14&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    White      &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;15&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;custom_types&#x2f;enum&#x2f;c_like.html&quot;&gt;C-like enum&lt;&#x2f;a&gt; here to explicitly specify the number for each color. Because of the &lt;code&gt;repr(u8)&lt;&#x2f;code&gt; attribute each enum variant is stored as an &lt;code&gt;u8&lt;&#x2f;code&gt;. Actually 4 bits would be sufficient, but Rust doesn&#x27;t have an &lt;code&gt;u4&lt;&#x2f;code&gt; type.&lt;&#x2f;p&gt;
&lt;p&gt;Normally the compiler would issue a warning for each unused variant. By using the &lt;code&gt;#[allow(dead_code)]&lt;&#x2f;code&gt; attribute we disable these warnings for the &lt;code&gt;Color&lt;&#x2f;code&gt; enum.&lt;&#x2f;p&gt;
&lt;p&gt;To represent a full color code that specifies foreground and background color, we create a newtype on top of &lt;code&gt;u8&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ColorCode(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ColorCode {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new(foreground: Color, background: Color) -&amp;gt; ColorCode {
        ColorCode((background &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;4 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(foreground &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;))
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;ColorCode&lt;&#x2f;code&gt; contains the full color byte, containing foreground and background color. Blinking is enabled implicitly by using a bright background color (soon we will disable blinking anyway). The &lt;code&gt;new&lt;&#x2f;code&gt; function is a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;0911-const-fn.md&quot;&gt;const function&lt;&#x2f;a&gt; to allow it in static initializers. As &lt;code&gt;const&lt;&#x2f;code&gt; functions are unstable we need to add the &lt;code&gt;const_fn&lt;&#x2f;code&gt; feature in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;the-text-buffer&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-text-buffer&quot; aria-label=&quot;Anchor link for: the-text-buffer&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Text Buffer&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can add structures to represent a screen character and the text buffer:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ScreenChar {
    ascii_character: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode,
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;25&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;const &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;80&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Buffer {
    chars: [[ScreenChar; BUFFER_WIDTH]; BUFFER_HEIGHT],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since the field ordering in default structs is undefined in Rust, we need the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;nomicon&#x2f;other-reprs.html#reprc&quot;&gt;repr(C)&lt;&#x2f;a&gt; attribute. It guarantees that the struct&#x27;s fields are laid out exactly like in a C struct and thus guarantees the correct field ordering.&lt;&#x2f;p&gt;
&lt;p&gt;To actually write to screen, we now create a writer type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::ptr::Unique;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode,
    buffer: Unique&amp;lt;Buffer&amp;gt;,
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The writer will always write to the last line and shift lines up when a line is full (or on &lt;code&gt;\n&lt;&#x2f;code&gt;). The &lt;code&gt;column_position&lt;&#x2f;code&gt; field keeps track of the current position in the last row. The current foreground and background colors are specified by &lt;code&gt;color_code&lt;&#x2f;code&gt; and a pointer to the VGA buffer is stored in &lt;code&gt;buffer&lt;&#x2f;code&gt;. To make it possible to create a &lt;code&gt;static&lt;&#x2f;code&gt; Writer later, the &lt;code&gt;buffer&lt;&#x2f;code&gt; field stores an &lt;code&gt;Unique&amp;lt;Buffer&amp;gt;&lt;&#x2f;code&gt; instead of a plain &lt;code&gt;*mut Buffer&lt;&#x2f;code&gt;. &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;core&#x2f;ptr&#x2f;struct.Unique.html&quot;&gt;Unique&lt;&#x2f;a&gt; is a wrapper that implements Send&#x2f;Sync and is thus usable as a &lt;code&gt;static&lt;&#x2f;code&gt;. Since it&#x27;s unstable, you may need to add the &lt;code&gt;unique&lt;&#x2f;code&gt; feature to &lt;code&gt;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(unique)]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;printing-characters&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-characters&quot; aria-label=&quot;Anchor link for: printing-characters&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing Characters&lt;&#x2f;h2&gt;
&lt;p&gt;Now we can use the &lt;code&gt;Writer&lt;&#x2f;code&gt; to modify the buffer&#x27;s characters. First we create a method to write a single ASCII byte (it doesn&#x27;t compile yet):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, byte: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.new_line(),
            byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;if &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                    self.new_line();
                }

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.column_position;

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; color_code &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.color_code;
                self.buffer().chars[row][col] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ScreenChar {
                    ascii_character: byte,
                    color_code: color_code,
                };
                self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
            }
        }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;buffer(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Buffer {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ self.buffer.as_mut() }
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new_line(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* TODO *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If the byte is the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Newline&quot;&gt;newline&lt;&#x2f;a&gt; byte &lt;code&gt;\n&lt;&#x2f;code&gt;, the writer does not print anything. Instead it calls a &lt;code&gt;new_line&lt;&#x2f;code&gt; method, which we&#x27;ll implement later. Other bytes get printed to the screen in the second match case.&lt;&#x2f;p&gt;
&lt;p&gt;When printing a byte, the writer checks if the current line is full. In that case, a &lt;code&gt;new_line&lt;&#x2f;code&gt; call is required before to wrap the line. Then it writes a new &lt;code&gt;ScreenChar&lt;&#x2f;code&gt; to the buffer at the current position. Finally, the current column position is advanced.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;buffer()&lt;&#x2f;code&gt; auxiliary method converts the raw pointer in the &lt;code&gt;buffer&lt;&#x2f;code&gt; field into a safe mutable buffer reference. The unsafe block is needed because the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;core&#x2f;ptr&#x2f;struct.Unique.html#method.as_mut&quot;&gt;as_mut()&lt;&#x2f;a&gt; method of &lt;code&gt;Unique&lt;&#x2f;code&gt; is unsafe. But our &lt;code&gt;buffer()&lt;&#x2f;code&gt; method itself isn&#x27;t marked as unsafe, so it must not introduce any unsafety (e.g. cause segfaults). To guarantee that, it&#x27;s very important that the &lt;code&gt;buffer&lt;&#x2f;code&gt; field always points to a valid &lt;code&gt;Buffer&lt;&#x2f;code&gt;. It&#x27;s like a contract that we must stand to every time we create a &lt;code&gt;Writer&lt;&#x2f;code&gt;. To ensure that it&#x27;s not possible to create an invalid &lt;code&gt;Writer&lt;&#x2f;code&gt; from outside of the module, the struct must have at least one private field and public creation functions are not allowed either.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;cannot-move-out-of-borrowed-content&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cannot-move-out-of-borrowed-content&quot; aria-label=&quot;Anchor link for: cannot-move-out-of-borrowed-content&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Cannot Move out of Borrowed Content&lt;&#x2f;h3&gt;
&lt;p&gt;When we try to compile it, we get the following error:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0507]: cannot move out of borrowed content
  --&amp;gt; src&#x2f;vga_buffer.rs:79:34
   |
79 | let color_code = self.color_code;
   |                  ^^^^ cannot move out of borrowed content
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The reason it that Rust &lt;em&gt;moves&lt;&#x2f;em&gt; values by default instead of copying them like other languages. And we cannot move &lt;code&gt;color_code&lt;&#x2f;code&gt; out of &lt;code&gt;self&lt;&#x2f;code&gt; because we only borrowed &lt;code&gt;self&lt;&#x2f;code&gt;. For more information check out the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;ownership.html&quot;&gt;ownership section&lt;&#x2f;a&gt; in the Rust book.&lt;&#x2f;p&gt;
&lt;p&gt;To fix it, we can implement the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Copy.html&quot;&gt;Copy&lt;&#x2f;a&gt; trait for the &lt;code&gt;ColorCode&lt;&#x2f;code&gt; type. The easiest way to do this is to use the built-in &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;rust-by-example&#x2f;custom_types&#x2f;enum&#x2f;c_like.html&quot;&gt;derive macro&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[derive(Debug, Clone, Copy)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ColorCode(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We also derive the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;clone&#x2f;trait.Clone.html&quot;&gt;Clone&lt;&#x2f;a&gt; trait, since it&#x27;s a requirement for &lt;code&gt;Copy&lt;&#x2f;code&gt;, and the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Debug.html&quot;&gt;Debug&lt;&#x2f;a&gt; trait, which allows us to print this field for debugging purposes.&lt;&#x2f;p&gt;
&lt;p&gt;Now our project should compile again.&lt;&#x2f;p&gt;
&lt;p&gt;However, the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;core&#x2f;marker&#x2f;trait.Copy.html#when-should-my-type-be-copy&quot;&gt;documentation for Copy&lt;&#x2f;a&gt; says: &lt;em&gt;â€œif your type can implement Copy, it shouldâ€&lt;&#x2f;em&gt;. Therefore we also derive Copy for &lt;code&gt;Color&lt;&#x2f;code&gt; and &lt;code&gt;ScreenChar&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
#[repr(u8)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub enum &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Color {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

#[derive(Debug, Clone, Copy)]
#[repr(C)]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ScreenChar {...}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;try-it-out&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#try-it-out&quot; aria-label=&quot;Anchor link for: try-it-out&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Try it out!&lt;&#x2f;h3&gt;
&lt;p&gt;To write some characters to the screen, you can create a temporary function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print_something() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
        column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: ColorCode::new(Color::LightGreen, Color::Black),
        buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ Unique::new_unchecked(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) },
    };

    writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It just creates a new Writer that points to the VGA buffer at &lt;code&gt;0xb8000&lt;&#x2f;code&gt;. To use the unstable &lt;code&gt;Unique::new_unchecked&lt;&#x2f;code&gt; function, we need to add the feature flag &lt;code&gt;#![feature(const_unique_new)]&lt;&#x2f;code&gt; to the top of our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Then it writes the byte &lt;code&gt;b&#x27;H&#x27;&lt;&#x2f;code&gt; to it. The &lt;code&gt;b&lt;&#x2f;code&gt; prefix creates a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference.html#characters-and-strings&quot;&gt;byte character&lt;&#x2f;a&gt;, which represents an ASCII code point. When we call &lt;code&gt;vga_buffer::print_something&lt;&#x2f;code&gt; in main, a &lt;code&gt;H&lt;&#x2f;code&gt; should be printed in the &lt;em&gt;lower&lt;&#x2f;em&gt; left corner of the screen in light green:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;vga-H-lower-left.png&quot; alt=&quot;QEMU output with a green H in the lower left corner&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;volatile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#volatile&quot; aria-label=&quot;Anchor link for: volatile&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Volatile&lt;&#x2f;h3&gt;
&lt;p&gt;We just saw that our &lt;code&gt;H&lt;&#x2f;code&gt; was printed correctly. However, it might not work with future Rust compilers that optimize more aggressively.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that we only write to the &lt;code&gt;Buffer&lt;&#x2f;code&gt; and never read from it again. The compiler doesn&#x27;t know about the side effect that some characters appear on the screen. So it might decide that these writes are unnecessary and can be omitted.&lt;&#x2f;p&gt;
&lt;p&gt;To avoid this erroneous optimization, we need to specify these writes as &lt;em&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Volatile_(computer_programming)&quot;&gt;volatile&lt;&#x2f;a&gt;&lt;&#x2f;em&gt;. This tells the compiler that the write has side effects and should not be optimized away.&lt;&#x2f;p&gt;
&lt;p&gt;In order to use volatile writes for the VGA buffer, we use the &lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;volatile&quot;&gt;volatile&lt;&#x2f;a&gt; library. This &lt;em&gt;crate&lt;&#x2f;em&gt; (this is how packages are called in the Rust world) provides a &lt;code&gt;Volatile&lt;&#x2f;code&gt; wrapper type with &lt;code&gt;read&lt;&#x2f;code&gt; and &lt;code&gt;write&lt;&#x2f;code&gt; methods. These methods internally use the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ptr&#x2f;fn.read_volatile.html&quot;&gt;read_volatile&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;ptr&#x2f;fn.write_volatile.html&quot;&gt;write_volatile&lt;&#x2f;a&gt; functions of the standard library and thus guarantee that the reads&#x2f;writes are not optimized away.&lt;&#x2f;p&gt;
&lt;p&gt;We can add a dependency on the &lt;code&gt;volatile&lt;&#x2f;code&gt; crate by adding it to the &lt;code&gt;dependencies&lt;&#x2f;code&gt; section of our &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;volatile &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;0.1.0&lt;&#x2f;code&gt; is the &lt;a href=&quot;http:&#x2f;&#x2f;semver.org&#x2f;&quot;&gt;semantic&lt;&#x2f;a&gt; version number. For more information, see the &lt;a href=&quot;http:&#x2f;&#x2f;doc.crates.io&#x2f;specifying-dependencies.html&quot;&gt;Specifying Dependencies&lt;&#x2f;a&gt; guide of the cargo documentation.&lt;&#x2f;p&gt;
&lt;p&gt;Now we&#x27;ve declared that our project depends on the &lt;code&gt;volatile&lt;&#x2f;code&gt; crate and are able to import it in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; volatile;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s use it to make writes to the VGA buffer volatile. We update our &lt;code&gt;Buffer&lt;&#x2f;code&gt; type as follows:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;volatile::Volatile;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;struct &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Buffer {
    chars: [[Volatile&amp;lt;ScreenChar&amp;gt;; BUFFER_WIDTH]; BUFFER_HEIGHT],
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;ScreenChar&lt;&#x2f;code&gt;, we&#x27;re now using a &lt;code&gt;Volatile&amp;lt;ScreenChar&amp;gt;&lt;&#x2f;code&gt;. (The &lt;code&gt;Volatile&lt;&#x2f;code&gt; type is &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch10-00-generics.html&quot;&gt;generic&lt;&#x2f;a&gt; and can wrap (almost) any type). This ensures that we can&#x27;t accidentally write to it through a â€œnormalâ€ write. Instead, we have to use the &lt;code&gt;write&lt;&#x2f;code&gt; method now.&lt;&#x2f;p&gt;
&lt;p&gt;This means that we have to update our &lt;code&gt;Writer::write_byte&lt;&#x2f;code&gt; method:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, byte: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;u8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;match&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte {
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.new_line(),
            byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...

                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.buffer().chars[row][col].write(ScreenChar {
                    ascii_character: byte,
                    color_code: color_code,
                });
                &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
        }
    }
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of a normal assignment using &lt;code&gt;=&lt;&#x2f;code&gt;, we&#x27;re now using the &lt;code&gt;write&lt;&#x2f;code&gt; method. This guarantees that the compiler will never optimize away this write.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;printing-strings&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#printing-strings&quot; aria-label=&quot;Anchor link for: printing-strings&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Printing Strings&lt;&#x2f;h2&gt;
&lt;p&gt;To print whole strings, we can convert them to bytes and print them one-by-one:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `impl Writer`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, s: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.bytes() {
      self.write_byte(byte)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You can try it yourself in the &lt;code&gt;print_something&lt;&#x2f;code&gt; function.&lt;&#x2f;p&gt;
&lt;p&gt;When you print strings with some special characters like &lt;code&gt;Ã¤&lt;&#x2f;code&gt; or &lt;code&gt;Î»&lt;&#x2f;code&gt;, you&#x27;ll notice that they cause weird symbols on screen. That&#x27;s because they are represented by multiple bytes in &lt;a href=&quot;http:&#x2f;&#x2f;www.fileformat.info&#x2f;info&#x2f;unicode&#x2f;utf8.htm&quot;&gt;UTF-8&lt;&#x2f;a&gt;. By converting them to bytes, we of course get strange results. But since the VGA buffer doesn&#x27;t support UTF-8, it&#x27;s not possible to display these characters anyway.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;support-formatting-macros&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#support-formatting-macros&quot; aria-label=&quot;Anchor link for: support-formatting-macros&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Support Formatting Macros&lt;&#x2f;h3&gt;
&lt;p&gt;It would be nice to support Rust&#x27;s formatting macros, too. That way, we can easily print different types like integers or floats. To support them, we need to implement the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;trait.Write.html&quot;&gt;core::fmt::Write&lt;&#x2f;a&gt; trait. The only required method of this trait is &lt;code&gt;write_str&lt;&#x2f;code&gt; that looks quite similar to our &lt;code&gt;write_str&lt;&#x2f;code&gt; method. To implement the trait, we just need to move it into an &lt;code&gt;impl fmt::Write for Writer&lt;&#x2f;code&gt; block and add a return type:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;impl &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;fmt::Write &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Writer {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, s: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;str&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) -&amp;gt; fmt::Result {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; s.bytes() {
          self.write_byte(byte)
        }
        Ok(())
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;Ok(())&lt;&#x2f;code&gt; is just a &lt;code&gt;Ok&lt;&#x2f;code&gt; Result containing the &lt;code&gt;()&lt;&#x2f;code&gt; type. We can drop the &lt;code&gt;pub&lt;&#x2f;code&gt; because trait methods are always public.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can use Rust&#x27;s built-in &lt;code&gt;write!&lt;&#x2f;code&gt;&#x2f;&lt;code&gt;writeln!&lt;&#x2f;code&gt; formatting macros:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in the `print_something` function
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;};
writer.write_byte(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39;H&amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
writer.write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;ello! &amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
write!(writer, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;The numbers are &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt; and &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3.0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now you should see a &lt;code&gt;Hello! The numbers are 42 and 0.3333333333333333&lt;&#x2f;code&gt; at the bottom of the screen.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;newlines&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#newlines&quot; aria-label=&quot;Anchor link for: newlines&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Newlines&lt;&#x2f;h3&gt;
&lt;p&gt;Right now, we just ignore newlines and characters that don&#x27;t fit into the line anymore. Instead we want to move every character one line up (the top line gets deleted) and start at the beginning of the last line again. To do this, we add an implementation for the &lt;code&gt;new_line&lt;&#x2f;code&gt; method of &lt;code&gt;Writer&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `impl Writer`

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;new_line(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; buffer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self.buffer();
            &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; character &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; buffer.chars[row][col].read();
            buffer.chars[row &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;- &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;][col].write(character);
        }
    }
    self.clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;-&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    self.column_position &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, row: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* TODO *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We iterate over all screen characters and move each characters one row up. Note that the range notation (&lt;code&gt;..&lt;&#x2f;code&gt;) is exclusive the upper bound. We also omit the 0th row (the first range starts at &lt;code&gt;1&lt;&#x2f;code&gt;) because it&#x27;s the row that is shifted off screen.&lt;&#x2f;p&gt;
&lt;p&gt;Now we only need to implement the &lt;code&gt;clear_row&lt;&#x2f;code&gt; method to finish the newline code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in `impl Writer`
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clear_row(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;&amp;amp;mut &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;self, row: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;usize&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; blank &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; ScreenChar {
        ascii_character: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;#39; &amp;#39;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
        color_code: self.color_code,
    };
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; col &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_WIDTH &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        self.buffer().chars[row][col].write(blank);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;This method clears a row by overwriting all of its characters with a space character.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;providing-an-interface&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#providing-an-interface&quot; aria-label=&quot;Anchor link for: providing-an-interface&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Providing an Interface&lt;&#x2f;h2&gt;
&lt;p&gt;To provide a global writer that can used as an interface from other modules, we can add a &lt;code&gt;static&lt;&#x2f;code&gt; writer:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; Writer {
    column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode::new(Color::LightGreen, Color::Black),
    buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ Unique::new_unchecked(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) },
};
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;But we can&#x27;t use it to print anything! You can try it yourself in the &lt;code&gt;print_something&lt;&#x2f;code&gt; function. The reason is that we try to take a mutable reference (&lt;code&gt;&amp;amp;mut&lt;&#x2f;code&gt;) to a immutable &lt;code&gt;static&lt;&#x2f;code&gt; when calling &lt;code&gt;WRITER.print_byte&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To resolve it, we could use a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;second-edition&#x2f;ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable&quot;&gt;mutable static&lt;&#x2f;a&gt;. But then every read and write to it would be unsafe since it could easily introduce data races and other bad things. Using &lt;code&gt;static mut&lt;&#x2f;code&gt; is highly discouraged, there are even proposals to &lt;a href=&quot;https:&#x2f;&#x2f;internals.rust-lang.org&#x2f;t&#x2f;pre-rfc-remove-static-mut&#x2f;1437&quot;&gt;remove it&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;But what are the alternatives? We could try to use a cell type like &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cell&#x2f;struct.RefCell.html&quot;&gt;RefCell&lt;&#x2f;a&gt; or even &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;cell&#x2f;struct.UnsafeCell.html&quot;&gt;UnsafeCell&lt;&#x2f;a&gt; to provide &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;mutability.html#interior-vs.-exterior-mutability&quot;&gt;interior mutability&lt;&#x2f;a&gt;. But these types aren&#x27;t &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;marker&#x2f;trait.Sync.html&quot;&gt;Sync&lt;&#x2f;a&gt; (with good reason), so we can&#x27;t use them in statics.&lt;&#x2f;p&gt;
&lt;p&gt;To get synchronized interior mutability, users of the standard library can use &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;sync&#x2f;struct.Mutex.html&quot;&gt;Mutex&lt;&#x2f;a&gt;. It provides mutual exclusion by blocking threads when the resource is already locked. But our basic kernel does not have any blocking support or even a concept of threads, so we can&#x27;t use it either. However there is a really basic kind of mutex in computer science that requires no operating system features: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Spinlock&quot;&gt;spinlock&lt;&#x2f;a&gt;. Instead of blocking, the threads simply try to lock it again and again in a tight loop and thus burn CPU time until the mutex is free again.&lt;&#x2f;p&gt;
&lt;p&gt;To use a spinning mutex, we can add the &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;spin&quot;&gt;spin crate&lt;&#x2f;a&gt; as a dependency:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# in Cargo.toml
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rlibc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.4&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;spin &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.4.5&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; spin;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Then we can use the spinning Mutex to add interior mutability to our static writer:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs again
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;spin::Mutex;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
pub static &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: Mutex&amp;lt;Writer&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;Mutex::new(Writer {
    column_position: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
    color_code: ColorCode::new(Color::LightGreen, Color::Black),
    buffer: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ Unique::new_unchecked(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) },
});
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;docs.rs&#x2f;spin&#x2f;0.4.5&#x2f;spin&#x2f;struct.Mutex.html#method.new&quot;&gt;Mutex::new&lt;&#x2f;a&gt; is a const function, too, so it can be used in statics.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can easily print from our main function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    vga_buffer::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_str(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello again&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    write!(vga_buffer::WRITER.lock(), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;, some numbers: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{} {}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;42&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1.337&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Note that we need to import the &lt;code&gt;Write&lt;&#x2f;code&gt; trait if we want to use its functions.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;a-println-macro&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-println-macro&quot; aria-label=&quot;Anchor link for: a-println-macro&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A println macro&lt;&#x2f;h2&gt;
&lt;p&gt;Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;book&#x2f;second-edition&#x2f;appendix-04-macros.html&quot;&gt;macro syntax&lt;&#x2f;a&gt; is a bit strange, so we won&#x27;t try to write a macro from scratch. Instead we look at the source of the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.println!.html&quot;&gt;&lt;code&gt;println!&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; in the standard library:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! println {
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(print!(concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
    ($fmt:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;expr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(print!(concat!($fmt, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#e3bbab;&quot;&gt;\n&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;), &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Macros are defined through one or more rules, which are similar to &lt;code&gt;match&lt;&#x2f;code&gt; arms. The &lt;code&gt;println&lt;&#x2f;code&gt; macro has two rules: The first rule is for invocations with a single argument (e.g. &lt;code&gt;println!(&amp;quot;Hello&amp;quot;)&lt;&#x2f;code&gt;) and the second rule is for invocations with additional parameters (e.g. &lt;code&gt;println!(&amp;quot;{}{}&amp;quot;, 4, 2)&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;Both rules simply append a newline character (&lt;code&gt;\n&lt;&#x2f;code&gt;) to the format string and then invoke the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.print!.html&quot;&gt;&lt;code&gt;print!&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt;, which is defined as:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($crate::io::_print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)));
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The macro expands to a call of the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;46d39f3329487115e7d7dcd37bc64eea6ef9ba4e&#x2f;src&#x2f;libstd&#x2f;io&#x2f;stdio.rs#L631&quot;&gt;&lt;code&gt;_print&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt; in the &lt;code&gt;io&lt;&#x2f;code&gt; module. The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;macros.html#the-variable-crate&quot;&gt;&lt;code&gt;$crate&lt;&#x2f;code&gt; variable&lt;&#x2f;a&gt; ensures that the macro also works from outside the &lt;code&gt;std&lt;&#x2f;code&gt; crate. For example, it expands to &lt;code&gt;::std&lt;&#x2f;code&gt; when it&#x27;s used in other crates.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;std&#x2f;macro.format_args.html&quot;&gt;&lt;code&gt;format_args&lt;&#x2f;code&gt; macro&lt;&#x2f;a&gt; builds a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;fmt&#x2f;struct.Arguments.html&quot;&gt;fmt::Arguments&lt;&#x2f;a&gt; type from the passed arguments, which is passed to &lt;code&gt;_print&lt;&#x2f;code&gt;. The &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;46d39f3329487115e7d7dcd37bc64eea6ef9ba4e&#x2f;src&#x2f;libstd&#x2f;io&#x2f;stdio.rs#L631&quot;&gt;&lt;code&gt;_print&lt;&#x2f;code&gt; function&lt;&#x2f;a&gt; of libstd is rather complicated, as it supports different &lt;code&gt;Stdout&lt;&#x2f;code&gt; devices. We don&#x27;t need that complexity since we just want to print to the VGA buffer.&lt;&#x2f;p&gt;
&lt;p&gt;To print to the VGA buffer, we just copy the &lt;code&gt;println!&lt;&#x2f;code&gt; macro and modify the &lt;code&gt;print!&lt;&#x2f;code&gt; macro to use our static &lt;code&gt;WRITER&lt;&#x2f;code&gt; instead of &lt;code&gt;_print&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;({
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;$crate::vga_buffer::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock();
        writer.write_fmt(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)).unwrap();
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Instead of a &lt;code&gt;_print&lt;&#x2f;code&gt; function, we call the &lt;code&gt;write_fmt&lt;&#x2f;code&gt; method of our static &lt;code&gt;Writer&lt;&#x2f;code&gt;. Since we&#x27;re using a method from the &lt;code&gt;Write&lt;&#x2f;code&gt; trait, we need to import it before. The additional &lt;code&gt;unwrap()&lt;&#x2f;code&gt; at the end panics if printing isn&#x27;t successful. But since we always return &lt;code&gt;Ok&lt;&#x2f;code&gt; in &lt;code&gt;write_str&lt;&#x2f;code&gt;, that should not happen.&lt;&#x2f;p&gt;
&lt;p&gt;Note the additional &lt;code&gt;{}&lt;&#x2f;code&gt; scope around the macro: We write &lt;code&gt;=&amp;gt; ({â€¦})&lt;&#x2f;code&gt; instead of &lt;code&gt;=&amp;gt; (â€¦)&lt;&#x2f;code&gt;. The additional &lt;code&gt;{}&lt;&#x2f;code&gt; avoids that the &lt;code&gt;Write&lt;&#x2f;code&gt; trait is silently imported to the parent scope when &lt;code&gt;print&lt;&#x2f;code&gt; is used.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;clearing-the-screen&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#clearing-the-screen&quot; aria-label=&quot;Anchor link for: clearing-the-screen&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Clearing the screen&lt;&#x2f;h3&gt;
&lt;p&gt;We can now use &lt;code&gt;println!&lt;&#x2f;code&gt; to add a rather trivial function to clear the screen:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;clear_screen() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for _ in &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;BUFFER_HEIGHT &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
        println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h3 id=&quot;hello-world-using-println&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world-using-println&quot; aria-label=&quot;Anchor link for: hello-world-using-println&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hello World using &lt;code&gt;println&lt;&#x2f;code&gt;&lt;&#x2f;h3&gt;
&lt;p&gt;To use &lt;code&gt;println&lt;&#x2f;code&gt; in &lt;code&gt;lib.rs&lt;&#x2f;code&gt;, we need to import the macros of the VGA buffer module first. Therefore we add a &lt;code&gt;#[macro_use]&lt;&#x2f;code&gt; attribute to the module declaration:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[macro_use]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mod &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; ATTENTION: we have a very small stack and no guard page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;vga_buffer::clear_screen();
    println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Since we imported the macros at crate level, they are available in all modules and thus provide an easy and safe interface to the VGA buffer.&lt;&#x2f;p&gt;
&lt;p&gt;As expected, we now see a &lt;em&gt;â€œHello World!â€&lt;&#x2f;em&gt; on a cleared screen:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;vga-hello-world.png&quot; alt=&quot;QEMU printing â€œHello World!â€ on a cleared screen&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;h3 id=&quot;deadlocks&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#deadlocks&quot; aria-label=&quot;Anchor link for: deadlocks&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Deadlocks&lt;&#x2f;h3&gt;
&lt;p&gt;Whenever we use locks, we must be careful to not accidentally introduce &lt;em&gt;deadlocks&lt;&#x2f;em&gt;. A &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Deadlock&quot;&gt;deadlock&lt;&#x2f;a&gt; occurs when a thread&#x2f;program waits for a lock that will never be released. Normally, this happens when multiple threads access multiple locks. For example, when thread A holds lock 1 and tries to acquire lock 2 and -- at the same time -- thread B holds lock 2 and tries to acquire lock 1.&lt;&#x2f;p&gt;
&lt;p&gt;However, a deadlock can also occur when a thread tries to acquire the same lock twice. This way we can trigger a deadlock in our VGA driver:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in rust_main in src&#x2f;lib.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;{}&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, { println!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;inner&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;); &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;outer&amp;quot; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;});
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The argument passed to &lt;code&gt;println&lt;&#x2f;code&gt; is new block that resolves to the string &lt;em&gt;â€œouterâ€&lt;&#x2f;em&gt; (a block always returns the result of the last expression). But before returning â€œouterâ€, the block tries to print the string &lt;em&gt;â€œinnerâ€&lt;&#x2f;em&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;When we try this code in QEMU, we see that neither of the strings are printed. To understand what&#x27;s happening, we take a look at our &lt;code&gt;print&lt;&#x2f;code&gt; macro again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;({
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; writer &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;$crate::vga_buffer::&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock();
        writer.write_fmt(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)).unwrap();
    });
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So we &lt;em&gt;first&lt;&#x2f;em&gt; lock the &lt;code&gt;WRITER&lt;&#x2f;code&gt; and then we evaluate the arguments using &lt;code&gt;format_args&lt;&#x2f;code&gt;. The problem is that the argument in our code example contains another &lt;code&gt;println&lt;&#x2f;code&gt;, which tries to lock the &lt;code&gt;WRITER&lt;&#x2f;code&gt; again. So now the inner &lt;code&gt;println&lt;&#x2f;code&gt; waits for the outer &lt;code&gt;println&lt;&#x2f;code&gt; and vice versa. Thus, a deadlock occurs and the CPU spins endlessly.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-the-deadlock&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-the-deadlock&quot; aria-label=&quot;Anchor link for: fixing-the-deadlock&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing the Deadlock&lt;&#x2f;h3&gt;
&lt;p&gt;In order to fix the deadlock, we need to evaluate the arguments &lt;em&gt;before&lt;&#x2f;em&gt; locking the &lt;code&gt;WRITER&lt;&#x2f;code&gt;. We can do so by moving the locking and printing logic into a new &lt;code&gt;print&lt;&#x2f;code&gt; function (like it&#x27;s done in the standard library):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; in src&#x2f;vga_buffer.rs

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;macro_rules! print {
    (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg:tt)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;({
        $crate::vga_buffer::print(format_args!(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;($arg)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;));
    });
}

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;print(args: fmt::Arguments) {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;use &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;core::fmt::Write;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;WRITER&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.lock().write_fmt(args).unwrap();
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now the macro only evaluates the arguments (through &lt;code&gt;format_args!&lt;&#x2f;code&gt;) and passes them to the new &lt;code&gt;print&lt;&#x2f;code&gt; function. The &lt;code&gt;print&lt;&#x2f;code&gt; function then locks the &lt;code&gt;WRITER&lt;&#x2f;code&gt; and prints the formatting arguments using &lt;code&gt;write_fmt&lt;&#x2f;code&gt;. So now the arguments are evaluated before locking the &lt;code&gt;WRITER&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Thus, we fixed the deadlock:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;fixed-println-deadlock.png&quot; alt=&quot;QEMU printing â€œinnerâ€ and then â€œouterâ€&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;We see that both â€œinnerâ€ and â€œouterâ€ are printed.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the next posts we will map the kernel pages correctly so that accessing &lt;code&gt;0x0&lt;&#x2f;code&gt; or writing to &lt;code&gt;.rodata&lt;&#x2f;code&gt; is not possible anymore. To obtain the loaded kernel sections we will read the Multiboot information structure. Then we will create a paging module and use it to switch to a new page table where the kernel sections are mapped correctly.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;allocating-frames&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; describes the Multiboot information structure and creates a frame allocator using the information about memory areas.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;other-rust-os-projects&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#other-rust-os-projects&quot; aria-label=&quot;Anchor link for: other-rust-os-projects&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Other Rust OS Projects&lt;&#x2f;h2&gt;
&lt;p&gt;Now that you know the very basics of OS development in Rust, you should also check out the following projects:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;thepowersgang&#x2f;rust-barebones-kernel&quot;&gt;Rust Bare-Bones Kernel&lt;&#x2f;a&gt;: A basic kernel with roughly the same functionality as ours. Writes output to the serial port instead of the VGA buffer and maps the kernel to the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Higher_Half_Kernel&quot;&gt;higher half&lt;&#x2f;a&gt; (instead of our identity mapping).
&lt;em&gt;Note&lt;&#x2f;em&gt;: You need to &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cross-compile-binutils&#x2f;&quot;&gt;cross compile binutils&lt;&#x2f;a&gt; to build it (or you create some symbolic links&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-symlink&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; if you&#x27;re on x86_64).&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;RustOS-Fork-Holding-Ground&#x2f;RustOS&quot;&gt;RustOS&lt;&#x2f;a&gt;: More advanced kernel that supports allocation, keyboard inputs, and threads. It also has a scheduler and a basic network driver.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;thepowersgang&#x2f;rust_os&quot;&gt;&amp;quot;Tifflin&amp;quot; Experimental Kernel&lt;&#x2f;a&gt;: Big kernel project by thepowersgang, that is actively developed and has over 650 commits. It has a separate userspace and supports multiple file systems, even a GUI is included. Needs a cross compiler.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;redox-os&#x2f;redox&quot;&gt;Redox&lt;&#x2f;a&gt;: Probably the most complete Rust OS today. It has an active community and over 1000 Github stars. File systems, network, an audio player, a picture viewer, and much more. Just take a look at the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;redox-os&#x2f;redox#what-it-looks-like&quot;&gt;screenshots&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-symlink&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;You will need to symlink &lt;code&gt;x86_64-none_elf-XXX&lt;&#x2f;code&gt; to &lt;code&gt;&#x2f;usr&#x2f;bin&#x2f;XXX&lt;&#x2f;code&gt; where &lt;code&gt;XXX&lt;&#x2f;code&gt; is in {&lt;code&gt;as&lt;&#x2f;code&gt;, &lt;code&gt;ld&lt;&#x2f;code&gt;, &lt;code&gt;objcopy&lt;&#x2f;code&gt;, &lt;code&gt;objdump&lt;&#x2f;code&gt;, &lt;code&gt;strip&lt;&#x2f;code&gt;}. The &lt;code&gt;x86_64-none_elf-XXX&lt;&#x2f;code&gt; files must be in some folder that is in your &lt;code&gt;$PATH&lt;&#x2f;code&gt;. But then you can only build for your x86_64 host architecture, so use this hack only for testing.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>Set Up Rust</title>
                <pubDate>Wed, 02 Sep 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/set-up-rust/</link>
                <guid>https://os.phil-opp.com/set-up-rust/</guid>
                <description>&lt;p&gt;In the previous posts we created a &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;multiboot-kernel&#x2f;&quot;&gt;minimal Multiboot kernel&lt;&#x2f;a&gt; and &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;&quot;&gt;switched to Long Mode&lt;&#x2f;a&gt;. Now we can finally switch to &lt;a href=&quot;https:&#x2f;&#x2f;www.rust-lang.org&#x2f;&quot;&gt;Rust&lt;&#x2f;a&gt; code. Rust is a high-level language without runtime. It allows us to not link the standard library and write bare metal code. Unfortunately the setup is not quite hassle-free yet.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;This blog post tries to set up Rust step-by-step and point out the different problems. If you have any questions, problems, or suggestions please &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;file an issue&lt;&#x2f;a&gt; or create a comment at the bottom. The code from this post is in a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_3&quot;&gt;Github repository&lt;&#x2f;a&gt;, too.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;installing-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#installing-rust&quot; aria-label=&quot;Anchor link for: installing-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Installing Rust&lt;&#x2f;h2&gt;
&lt;p&gt;We need a nightly compiler, as we will use many unstable features. To manage Rust installations I highly recommend &lt;a href=&quot;https:&#x2f;&#x2f;www.rustup.rs&#x2f;&quot;&gt;rustup&lt;&#x2f;a&gt;. It allows you to install nightly, beta, and stable compilers side-by-side and makes it easy to update them. To use a nightly compiler for the current directory, you can run &lt;code&gt;rustup override add nightly&lt;&#x2f;code&gt;. Alternatively, you can add a file called &lt;code&gt;rust-toolchain&lt;&#x2f;code&gt; to the project&#x27;s root directory:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;nightly
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The code from this post (and all following) is &lt;a href=&quot;https:&#x2f;&#x2f;travis-ci.org&#x2f;phil-opp&#x2f;blog_os&quot;&gt;automatically tested&lt;&#x2f;a&gt; every day and should always work for the newest nightly. If it doesn&#x27;t, please &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;file an issue&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;creating-a-cargo-project&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-cargo-project&quot; aria-label=&quot;Anchor link for: creating-a-cargo-project&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a Cargo project&lt;&#x2f;h2&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2f;&#x2f;doc.crates.io&#x2f;guide.html&quot;&gt;Cargo&lt;&#x2f;a&gt; is Rust&#x27;s excellent package manager. Normally you would call &lt;code&gt;cargo new&lt;&#x2f;code&gt; when you want to create a new project folder. We can&#x27;t use it because our folder already exists, so we need to do it manually. Fortunately we only need to add a cargo configuration file named &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;package&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;name &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;blog_os&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;version &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0.1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;authors &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Philipp Oppermann &amp;lt;dev@phil-opp.com&amp;gt;&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]

[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;lib&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;crate-type &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;staticlib&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;package&lt;&#x2f;code&gt; section contains required project metadata such as the &lt;a href=&quot;http:&#x2f;&#x2f;doc.crates.io&#x2f;manifest.html#the-package-section&quot;&gt;semantic crate version&lt;&#x2f;a&gt;. The &lt;code&gt;lib&lt;&#x2f;code&gt; section specifies that we want to build a static library, i.e. a library that contains all of its dependencies. This is required to link the Rust project with our kernel.&lt;&#x2f;p&gt;
&lt;p&gt;Now we place our root source file in &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#![feature(lang_items)]
#![no_std]

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {}

#[lang &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;eh_personality&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] #[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eh_personality() {}
#[lang &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic_fmt&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] #[no_mangle] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;panic_fmt() -&amp;gt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;! &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s break it down:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#!&lt;&#x2f;code&gt; defines an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;attributes.html&quot;&gt;attribute&lt;&#x2f;a&gt; of the current module. Since we are at the root module, the attributes apply to the crate itself.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;feature&lt;&#x2f;code&gt; attribute is used to allow the specified &lt;em&gt;feature-gated&lt;&#x2f;em&gt; attributes in this crate. You can&#x27;t do that in a stable&#x2f;beta compiler, so this is one reason we need a Rust nighly.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;no_std&lt;&#x2f;code&gt; attribute prevents the automatic linking of the standard library. We can&#x27;t use &lt;code&gt;std&lt;&#x2f;code&gt; because it relies on operating system features like files, system calls, and various device drivers. Remember that currently the only â€œfeatureâ€ of our OS is printing &lt;code&gt;OKAY&lt;&#x2f;code&gt; :).&lt;&#x2f;li&gt;
&lt;li&gt;A &lt;code&gt;#&lt;&#x2f;code&gt; without a &lt;code&gt;!&lt;&#x2f;code&gt; afterwards defines an attribute for the &lt;em&gt;following&lt;&#x2f;em&gt; item (a function in our case).&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;no_mangle&lt;&#x2f;code&gt; attribute disables the automatic &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Name_mangling&quot;&gt;name mangling&lt;&#x2f;a&gt; that Rust uses to get unique function names. We want to do a &lt;code&gt;call rust_main&lt;&#x2f;code&gt; from our assembly code, so this function name must stay as it is.&lt;&#x2f;li&gt;
&lt;li&gt;We mark our main function as &lt;code&gt;extern&lt;&#x2f;code&gt; to make it compatible to the standard C &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Calling_convention&quot;&gt;calling convention&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;lang&lt;&#x2f;code&gt; attribute defines a Rust &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;book&#x2f;lang-items.html&quot;&gt;language item&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;eh_personality&lt;&#x2f;code&gt; function is used for Rust&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nomicon&#x2f;unwinding.html&quot;&gt;unwinding&lt;&#x2f;a&gt; on &lt;code&gt;panic!&lt;&#x2f;code&gt;. We can leave it empty since we don&#x27;t have any unwinding support in our OS yet.&lt;&#x2f;li&gt;
&lt;li&gt;The &lt;code&gt;panic_fmt&lt;&#x2f;code&gt; function is the entry point on panic. Right now we can&#x27;t do anything useful, so we just make sure that it doesn&#x27;t return (required by the &lt;code&gt;!&lt;&#x2f;code&gt; return type).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;building-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-rust&quot; aria-label=&quot;Anchor link for: building-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Building Rust&lt;&#x2f;h2&gt;
&lt;p&gt;We can now build it using &lt;code&gt;cargo build&lt;&#x2f;code&gt;, which creates a static library at &lt;code&gt;target&#x2f;debug&#x2f;libblog_os.a&lt;&#x2f;code&gt;. However, the resulting library is specific to our &lt;em&gt;host&lt;&#x2f;em&gt; operating system. This is undesirable, because our target system might be different.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s define some properties of our target system:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;x86_64&lt;&#x2f;strong&gt;: Our target CPU is a recent &lt;code&gt;x86_64&lt;&#x2f;code&gt; CPU.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;No operating system&lt;&#x2f;strong&gt;: Our target does not run any operating system (we&#x27;re currently writing it), so the compiler should not assume any OS-specific functionality.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;Handles hardware interrupts&lt;&#x2f;strong&gt;: We&#x27;re writing a kernel, so we&#x27;ll need to handle asynchronous hardware interrupts at some point. This means that we have to disable a certain stack pointer optimization (the so-called &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;09&#x2f;06&#x2f;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2f;a&gt;), because it would cause stack corruptions otherwise.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;No SSE&lt;&#x2f;strong&gt;: Our target might not have &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2f;a&gt; support. Even if it does, we probably don&#x27;t want to use SSE instructions in our kernel, because it makes interrupt handling much slower. We will explain this in detail in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;â€œHandling Exceptionsâ€&lt;&#x2f;a&gt; post.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;strong&gt;No hardware floats&lt;&#x2f;strong&gt;: The &lt;code&gt;x86_64&lt;&#x2f;code&gt; architecture uses SSE instructions for floating point operations, which we don&#x27;t want to use (see the previous point). So we also need to avoid hardware floating point operations in our kernel. Instead, we will use &lt;em&gt;soft floats&lt;&#x2f;em&gt;, which are basically software functions that emulate floating point operations using normal integers.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;target-specifications&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#target-specifications&quot; aria-label=&quot;Anchor link for: target-specifications&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Target Specifications&lt;&#x2f;h3&gt;
&lt;p&gt;Rust allows us to define &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.1.0&#x2f;rustc_back&#x2f;target&#x2f;&quot;&gt;custom targets&lt;&#x2f;a&gt; through a JSON configuration file. A minimal target specification equal to &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; (the default 64-bit Linux target) looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-linux-gnu&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linux&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;llvm-target&lt;&#x2f;code&gt; field specifies the target triple that is passed to LLVM. &lt;a href=&quot;http:&#x2f;&#x2f;llvm.org&#x2f;docs&#x2f;LangRef.html#target-triple&quot;&gt;Target triples&lt;&#x2f;a&gt; are a naming convention that define the CPU architecture (e.g., &lt;code&gt;x86_64&lt;&#x2f;code&gt; or &lt;code&gt;arm&lt;&#x2f;code&gt;), the vendor (e.g., &lt;code&gt;apple&lt;&#x2f;code&gt; or &lt;code&gt;unknown&lt;&#x2f;code&gt;), the operating system (e.g., &lt;code&gt;windows&lt;&#x2f;code&gt; or &lt;code&gt;linux&lt;&#x2f;code&gt;), and the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Application_binary_interface&quot;&gt;ABI&lt;&#x2f;a&gt; (e.g., &lt;code&gt;gnu&lt;&#x2f;code&gt; or &lt;code&gt;msvc&lt;&#x2f;code&gt;). For example, the target triple for 64-bit Linux is &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; and for 32-bit Windows the target triple is &lt;code&gt;i686-pc-windows-msvc&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;data-layout&lt;&#x2f;code&gt; field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications separated by a &lt;code&gt;-&lt;&#x2f;code&gt; character. For example, the &lt;code&gt;e&lt;&#x2f;code&gt; means little endian and &lt;code&gt;S128&lt;&#x2f;code&gt; specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the &lt;a href=&quot;http:&#x2f;&#x2f;llvm.org&#x2f;docs&#x2f;LangRef.html#data-layout&quot;&gt;LLVM documentation&lt;&#x2f;a&gt; but there shouldn&#x27;t be a reason to change this string.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;linker-flavor&lt;&#x2f;code&gt; field was recently introduced in &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;pull&#x2f;40018&quot;&gt;#40018&lt;&#x2f;a&gt; with the intention to add support for the LLVM linker &lt;a href=&quot;https:&#x2f;&#x2f;lld.llvm.org&#x2f;&quot;&gt;LLD&lt;&#x2f;a&gt;, which is platform independent. In the future, this might allow easy cross compilation without the need to install a gcc cross compiler for linking.&lt;&#x2f;p&gt;
&lt;p&gt;The other fields are used for conditional compilation. This allows crate authors to use &lt;code&gt;cfg&lt;&#x2f;code&gt; variables to write special code for depending on the OS or the architecture. There isn&#x27;t any up-to-date documentation about these fields but the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;c772948b687488a087356cb91432425662e034b9&#x2f;src&#x2f;librustc_back&#x2f;target&#x2f;mod.rs#L194-L214&quot;&gt;corresponding source code&lt;&#x2f;a&gt; is quite readable.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;a-kernel-target-specification&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-kernel-target-specification&quot; aria-label=&quot;Anchor link for: a-kernel-target-specification&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
A Kernel Target Specification&lt;&#x2f;h3&gt;
&lt;p&gt;For our target system, we define the following JSON configuration in a file named &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;llvm-target&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64-unknown-none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;data-layout&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;linker-flavor&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;gcc&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-endian&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;little&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-pointer-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;target-c-int-width&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;32&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;arch&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;x86_64&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;os&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;none&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;disable-redzone&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;true&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;features&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;-mmx,-sse,+soft-float&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;As &lt;code&gt;llvm-target&lt;&#x2f;code&gt; we use &lt;code&gt;x86_64-unknown-none&lt;&#x2f;code&gt;, which defines the &lt;code&gt;x86_64&lt;&#x2f;code&gt; architecture, an &lt;code&gt;unknown&lt;&#x2f;code&gt; vendor, and no operating system (&lt;code&gt;none&lt;&#x2f;code&gt;). The ABI doesn&#x27;t matter for us, so we just leave it off. The &lt;code&gt;data-layout&lt;&#x2f;code&gt; field is just copied from the &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt; target. We also use the same values for the &lt;code&gt;target-endian&lt;&#x2f;code&gt;, &lt;code&gt;target-pointer-width&lt;&#x2f;code&gt;, &lt;code&gt;target-c-int-width&lt;&#x2f;code&gt;, and &lt;code&gt;arch&lt;&#x2f;code&gt; fields. For the &lt;code&gt;os&lt;&#x2f;code&gt; field we choose &lt;code&gt;none&lt;&#x2f;code&gt;, since our kernel runs on bare metal.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;the-red-zone&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-red-zone&quot; aria-label=&quot;Anchor link for: the-red-zone&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Red Zone&lt;&#x2f;h4&gt;
&lt;p&gt;The &lt;a href=&quot;http:&#x2f;&#x2f;eli.thegreenplace.net&#x2f;2011&#x2f;09&#x2f;06&#x2f;stack-frame-layout-on-x86-64#the-red-zone&quot;&gt;red zone&lt;&#x2f;a&gt; is an optimization of the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;System_V_ABI&quot;&gt;System V ABI&lt;&#x2f;a&gt; that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;red-zone.svg&quot; alt=&quot;stack frame with red zone&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The image shows the stack frame of a function with &lt;code&gt;n&lt;&#x2f;code&gt; local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.&lt;&#x2f;p&gt;
&lt;p&gt;The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that&#x27;s not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).&lt;&#x2f;p&gt;
&lt;p&gt;However, this optimization leads to huge problems with exceptions or hardware interrupts. Let&#x27;s assume that an exception occurs while a function uses the red zone:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;red-zone-overwrite.svg&quot; alt=&quot;red zone overwritten by exception handler&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won&#x27;t work correctly anymore when we return from the exception handler. This might lead to strange bugs that &lt;a href=&quot;http:&#x2f;&#x2f;forum.osdev.org&#x2f;viewtopic.php?t=21720&quot;&gt;take weeks to debug&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;To avoid such bugs when we implement exception handling in the future, we disable the red zone right from the beginning. This is achieved by adding the &lt;code&gt;&amp;quot;disable-redzone&amp;quot;: true&lt;&#x2f;code&gt; line to our target configuration file.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;simd-extensions&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#simd-extensions&quot; aria-label=&quot;Anchor link for: simd-extensions&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
SIMD Extensions&lt;&#x2f;h4&gt;
&lt;p&gt;The &lt;code&gt;features&lt;&#x2f;code&gt; field enables&#x2f;disables target features. We disable the &lt;code&gt;mmx&lt;&#x2f;code&gt; and &lt;code&gt;sse&lt;&#x2f;code&gt; features by prefixing them with a minus and enable the &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature by prefixing it with a plus.  The &lt;code&gt;mmx&lt;&#x2f;code&gt; and &lt;code&gt;sse&lt;&#x2f;code&gt; features determine support for &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;SIMD&quot;&gt;Single Instruction Multiple Data (SIMD)&lt;&#x2f;a&gt; instructions, which simultaneously perform an operation (e.g. addition) on multiple data words. The &lt;code&gt;x86&lt;&#x2f;code&gt; architecture supports the following standards:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;MMX_(instruction_set)&quot;&gt;MMX&lt;&#x2f;a&gt;: The &lt;em&gt;Multi Media Extension&lt;&#x2f;em&gt; instruction set was introduced in 1997 and defines eight 64 bit registers called &lt;code&gt;mm0&lt;&#x2f;code&gt; through &lt;code&gt;mm7&lt;&#x2f;code&gt;. These registers are just aliases for the registers of the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X87&quot;&gt;x87 floating point unit&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Streaming_SIMD_Extensions&quot;&gt;SSE&lt;&#x2f;a&gt;: The &lt;em&gt;Streaming SIMD Extensions&lt;&#x2f;em&gt; instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called &lt;code&gt;xmm0&lt;&#x2f;code&gt; through &lt;code&gt;xmm15&lt;&#x2f;code&gt; and are 128 bits each.&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Advanced_Vector_Extensions&quot;&gt;AVX&lt;&#x2f;a&gt;: The &lt;em&gt;Advanced Vector Extensions&lt;&#x2f;em&gt; are extensions that further increase the size of the multimedia registers. The new registers are called &lt;code&gt;ymm0&lt;&#x2f;code&gt; through &lt;code&gt;ymm15&lt;&#x2f;code&gt; and are 256 bits each. They extend the &lt;code&gt;xmm&lt;&#x2f;code&gt; registers, so e.g. &lt;code&gt;xmm0&lt;&#x2f;code&gt; is the lower half of &lt;code&gt;ymm0&lt;&#x2f;code&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;By using such SIMD standards, programs can often speed up significantly. Good compilers are able to transform normal loops into such SIMD code automatically through a process called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Automatic_vectorization&quot;&gt;auto-vectorization&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;However, the large SIMD registers lead to problems in OS kernels. The reason is that the kernel has to backup all registers that it uses on each hardware interrupt (we will look into this in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;handling-exceptions&#x2f;&quot;&gt;â€œHandling Exceptionsâ€&lt;&#x2f;a&gt; post). So if the kernel uses SIMD registers, it has to backup a lot more data, which noticeably decreases performance. To avoid this performance loss, we disable the &lt;code&gt;sse&lt;&#x2f;code&gt; and &lt;code&gt;mmx&lt;&#x2f;code&gt; features (the &lt;code&gt;avx&lt;&#x2f;code&gt; feature is disabled by default).&lt;&#x2f;p&gt;
&lt;p&gt;As noted above, floating point operations on &lt;code&gt;x86_64&lt;&#x2f;code&gt; use SSE registers, so floats are no longer usable without SSE. Unfortunately, the Rust core library already uses floats (e.g., it implements traits for &lt;code&gt;f32&lt;&#x2f;code&gt; and &lt;code&gt;f64&lt;&#x2f;code&gt;), so we need an alternative way to implement float operations. The &lt;code&gt;soft-float&lt;&#x2f;code&gt; feature solves this problem by emulating all floating point operations through software functions based on normal integers.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;compiling&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#compiling&quot; aria-label=&quot;Anchor link for: compiling&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Compiling&lt;&#x2f;h3&gt;
&lt;p&gt;To build our kernel for our new target, we pass the configuration file&#x27;s name as &lt;code&gt;--target&lt;&#x2f;code&gt; argument. There is currently an &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;cargo&#x2f;issues&#x2f;4905&quot;&gt;open bug&lt;&#x2f;a&gt; for custom target specifications, so you also need to set the &lt;code&gt;RUST_TARGET_PATH&lt;&#x2f;code&gt; environment variable to the current directory, otherwise Rust doesn&#x27;t find your target. The full command is:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;RUST_TARGET_PATH=$(pwd) cargo build --target x86_64-blog_os
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;However, the following error occurs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error[E0463]: can&amp;#39;t find crate for `core`
  |
  = note: the `x86_64-blog_os` target may not be installed
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The error tells us that the Rust compiler no longer finds the core library. The &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;index.html&quot;&gt;core library&lt;&#x2f;a&gt; is implicitly linked to all &lt;code&gt;no_std&lt;&#x2f;code&gt; crates and contains things such as &lt;code&gt;Result&lt;&#x2f;code&gt;, &lt;code&gt;Option&lt;&#x2f;code&gt;, and iterators.&lt;&#x2f;p&gt;
&lt;p&gt;The problem is that the core library is distributed together with the Rust compiler as a &lt;em&gt;precompiled&lt;&#x2f;em&gt; library. So it is only valid for the host triple (e.g., &lt;code&gt;x86_64-unknown-linux-gnu&lt;&#x2f;code&gt;) but not for our custom target. If we want to compile code for other targets, we need to recompile &lt;code&gt;core&lt;&#x2f;code&gt; for these targets first.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;xargo&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#xargo&quot; aria-label=&quot;Anchor link for: xargo&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Xargo&lt;&#x2f;h4&gt;
&lt;p&gt;That&#x27;s where &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;japaric&#x2f;xargo&quot;&gt;xargo&lt;&#x2f;a&gt; comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cargo install xargo
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Xargo depends on the rust source code, which we can install with &lt;code&gt;rustup component add rust-src&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Xargo is â€œa drop-in replacement for cargoâ€, so every cargo command also works with &lt;code&gt;xargo&lt;&#x2f;code&gt;. You can do e.g. &lt;code&gt;xargo --help&lt;&#x2f;code&gt;, &lt;code&gt;xargo clean&lt;&#x2f;code&gt;, or &lt;code&gt;xargo doc&lt;&#x2f;code&gt;. However, the &lt;code&gt;build&lt;&#x2f;code&gt; command gains additional functionality: &lt;code&gt;xargo build&lt;&#x2f;code&gt; will automatically cross compile the &lt;code&gt;core&lt;&#x2f;code&gt; library when compiling for custom targets.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s try it:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; RUST_TARGET_PATH=$(pwd) xargo build --target=x86_64-blog_os
   Compiling core v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;libcore)
    Finished release &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;optimized&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; target(s) in 22.87 secs
   Compiling blog_os v0.1.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;blog_os&#x2f;tags)
    Finished dev &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;unoptimized + debuginfo&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; target(s) in 0.29 secs
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It worked! We see that &lt;code&gt;xargo&lt;&#x2f;code&gt; cross-compiled the &lt;code&gt;core&lt;&#x2f;code&gt; library for our new custom target and then continued to compile our &lt;code&gt;blog_os&lt;&#x2f;code&gt; crate. After compilation, we can find a static library at &lt;code&gt;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a&lt;&#x2f;code&gt;, which can be linked with our assembly kernel.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;integrating-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#integrating-rust&quot; aria-label=&quot;Anchor link for: integrating-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Integrating Rust&lt;&#x2f;h2&gt;
&lt;p&gt;Let&#x27;s try to integrate our Rust library into our assembly kernel so that we can call the &lt;code&gt;rust_main&lt;&#x2f;code&gt; function. For that we need to pass the &lt;code&gt;libblog_os.a&lt;&#x2f;code&gt; file to the linker, together with the assembly object files.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;adjusting-the-makefile&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#adjusting-the-makefile&quot; aria-label=&quot;Anchor link for: adjusting-the-makefile&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Adjusting the Makefile&lt;&#x2f;h3&gt;
&lt;p&gt;To build and link the rust library on &lt;code&gt;make&lt;&#x2f;code&gt;, we extend our &lt;code&gt;Makefile&lt;&#x2f;code&gt;(&lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;blob&#x2f;first_edition_post_3&#x2f;Makefile&quot;&gt;full file&lt;&#x2f;a&gt;):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;# ...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
target ?= &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;-blog_os&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
rust_os :&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;= target&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;target&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;debug&#x2f;libblog_os.a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# ...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.PHONY: all clean run iso kernel
# ...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: kernel &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	@ld -n -T &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; -o &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; \
		&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

kernel:
	@RUST_TARGET_PATH=&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;shell pwd&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt; xargo build --target &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;target&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We add a new &lt;code&gt;kernel&lt;&#x2f;code&gt; target that just executes &lt;code&gt;xargo build&lt;&#x2f;code&gt; and modify the &lt;code&gt;$(kernel)&lt;&#x2f;code&gt; target to link the created static lib. We also add the new &lt;code&gt;kernel&lt;&#x2f;code&gt; target to the &lt;code&gt;.PHONY&lt;&#x2f;code&gt; list, since it does not belong to a file with that name.&lt;&#x2f;p&gt;
&lt;p&gt;But now &lt;code&gt;xargo build&lt;&#x2f;code&gt; is executed on every &lt;code&gt;make&lt;&#x2f;code&gt;, even if no source file was changed. And the ISO is recreated on every &lt;code&gt;make iso&lt;&#x2f;code&gt;&#x2f;&lt;code&gt;make run&lt;&#x2f;code&gt;, too. We could try to avoid this by adding dependencies on all rust source and cargo configuration files to the &lt;code&gt;kernel&lt;&#x2f;code&gt; target, but the ISO creation takes only half a second on my machine and most of the time we will have changed a Rust file when we run &lt;code&gt;make&lt;&#x2f;code&gt;. So we keep it simple for now and let cargo do the bookkeeping of changed files (it does it anyway).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;calling-rust&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#calling-rust&quot; aria-label=&quot;Anchor link for: calling-rust&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Calling Rust&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can call the main method in &lt;code&gt;long_mode_start&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;bits 64
long_mode_start:
    ...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; call the rust main
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;extern rust_main&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;     ; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; new

    ; print `OKAY` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f592f412f4b2f4f
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], rax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By defining &lt;code&gt;rust_main&lt;&#x2f;code&gt; as &lt;code&gt;extern&lt;&#x2f;code&gt; we tell nasm that the function is defined in another file. As the linker takes care of linking them together, we&#x27;ll get a linker error if we have a typo in the name or forget to mark the rust function as &lt;code&gt;pub extern&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;If we&#x27;ve done everything right, we should still see the green &lt;code&gt;OKAY&lt;&#x2f;code&gt; when executing &lt;code&gt;make run&lt;&#x2f;code&gt;. That means that we successfully called the Rust function and returned back to assembly.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;fixing-linker-errors&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#fixing-linker-errors&quot; aria-label=&quot;Anchor link for: fixing-linker-errors&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Fixing Linker Errors&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can try some Rust code:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;World&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; y &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; x;
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When we test it using &lt;code&gt;make run&lt;&#x2f;code&gt;, it fails with &lt;code&gt;undefined reference to &#x27;memcpy&#x27;&lt;&#x2f;code&gt;. The &lt;code&gt;memcpy&lt;&#x2f;code&gt; function is one of the basic functions of the C library (&lt;code&gt;libc&lt;&#x2f;code&gt;). Usually the &lt;code&gt;libc&lt;&#x2f;code&gt; crate is linked to every Rust program together with the standard library, but we opted out through &lt;code&gt;#![no_std]&lt;&#x2f;code&gt;. We could try to fix this by adding the &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;1.10.0&#x2f;libc&#x2f;index.html&quot;&gt;libc crate&lt;&#x2f;a&gt; as &lt;code&gt;extern crate&lt;&#x2f;code&gt;. But &lt;code&gt;libc&lt;&#x2f;code&gt; is just a wrapper for the system &lt;code&gt;libc&lt;&#x2f;code&gt;, for example &lt;code&gt;glibc&lt;&#x2f;code&gt; on Linux, so this won&#x27;t work for us. Instead we need to recreate the basic &lt;code&gt;libc&lt;&#x2f;code&gt; functions such as &lt;code&gt;memcpy&lt;&#x2f;code&gt;, &lt;code&gt;memmove&lt;&#x2f;code&gt;, &lt;code&gt;memset&lt;&#x2f;code&gt;, and &lt;code&gt;memcmp&lt;&#x2f;code&gt; in Rust.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;rlibc&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#rlibc&quot; aria-label=&quot;Anchor link for: rlibc&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
rlibc&lt;&#x2f;h4&gt;
&lt;p&gt;Fortunately there already is a crate for that: &lt;a href=&quot;https:&#x2f;&#x2f;crates.io&#x2f;crates&#x2f;rlibc&quot;&gt;rlibc&lt;&#x2f;a&gt;. When we look at its &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;alexcrichton&#x2f;rlibc&#x2f;blob&#x2f;defb486e765846417a8e73329e8c5196f1dca49a&#x2f;src&#x2f;lib.rs&quot;&gt;source code&lt;&#x2f;a&gt; we see that it contains no magic, just some &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;raw-pointers.html&quot;&gt;raw pointer&lt;&#x2f;a&gt; operations in a while loop. To add &lt;code&gt;rlibc&lt;&#x2f;code&gt; as a dependency we just need to add two lines to the &lt;code&gt;Cargo.toml&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#ff3333;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[&lt;&#x2f;span&gt;&lt;span style=&quot;color:#808080;&quot;&gt;dependencies&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rlibc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1.0&amp;quot;
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;and an &lt;code&gt;extern crate&lt;&#x2f;code&gt; definition in our &lt;code&gt;src&#x2f;lib.rs&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;...
extern crate&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; rlibc;

#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now &lt;code&gt;make run&lt;&#x2f;code&gt; doesn&#x27;t complain about &lt;code&gt;memcpy&lt;&#x2f;code&gt; anymore. Instead it will show a pile of new ugly linker errors:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(core-92335f822fa6c9a6.0.o):
    In function `_$LT$f32$u20$as$u20$core..num..dec2flt..
        rawfp..RawFloat$GT$::from_int::h50f7952efac3fdca&amp;#39;:
    core.cgu-0.rs:(.text._ZN59_$LT$f32$u20$as$u20$core..num..dec2flt..
        rawfp..RawFloat$GT$8from_int17h50f7952efac3fdcaE+0x2):
    undefined reference to `__floatundisf&amp;#39;
target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(core-92335f822fa6c9a6.0.o):
    In function `_$LT$f64$u20$as$u20$core..num..dec2flt..rawfp..
        RawFloat$GT$::from_int::h12a81f175246914a&amp;#39;:
    core.cgu-0.rs:(.text._ZN59_$LT$f64$u20$as$u20$core..num..dec2flt..rawfp..
        RawFloat$GT$8from_int17h12a81f175246914aE+0x2):
    undefined reference to `__floatundidf&amp;#39;
target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(core-92335f822fa6c9a6.0.o):
    In function `core::num::from_str_radix::h09b12650704e0508&amp;#39;:
    core.cgu-0.rs:(.text._ZN4core3num14from_str_radix
        17h09b12650704e0508E+0xcf):
    undefined reference to `__muloti4&amp;#39;
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h4 id=&quot;gc-sections&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#gc-sections&quot; aria-label=&quot;Anchor link for: gc-sections&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
--gc-sections&lt;&#x2f;h4&gt;
&lt;p&gt;The new errors are linker errors about various missing functions such as &lt;code&gt;__floatundisf&lt;&#x2f;code&gt; or &lt;code&gt;__muloti4&lt;&#x2f;code&gt;. These functions are part of LLVM&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;compiler-rt.llvm.org&#x2f;&quot;&gt;&lt;code&gt;compiler-rt&lt;&#x2f;code&gt; builtins&lt;&#x2f;a&gt; and are normally linked by the standard library. For &lt;code&gt;no_std&lt;&#x2f;code&gt; crates like ours, one has to link the &lt;code&gt;compiler-rt&lt;&#x2f;code&gt; library manually. Unfortunately, this library is implemented in C and the build process is a bit cumbersome. Alternatively, there is the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang-nursery&#x2f;compiler-builtins&quot;&gt;compiler-builtins&lt;&#x2f;a&gt; crate that tries to port the library to Rust, but it isn&#x27;t complete yet.&lt;&#x2f;p&gt;
&lt;p&gt;In our case, there is a much simpler solution, since our kernel doesn&#x27;t really need any of those functions yet. So we can just tell the linker to remove unused program sections and hopefully all references to these functions will disappear. Removing unused sections is generally a good idea as it reduces kernel size. The magic linker flag for this is &lt;code&gt;--gc-sections&lt;&#x2f;code&gt;, which stands for â€œgarbage collect sectionsâ€. Let&#x27;s add it to the &lt;code&gt;$(kernel)&lt;&#x2f;code&gt; target in our &lt;code&gt;Makefile&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;xargo &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ld -n --gc-sections -T &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; -o &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;\
		&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_os&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can do a &lt;code&gt;make run&lt;&#x2f;code&gt; again and it compiles without errors again. However, it doesn&#x27;t boot anymore:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;GRUB error: no multiboot header found.
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;What happened? Well, the linker removed unused sections. And since we don&#x27;t use the Multiboot section anywhere, &lt;code&gt;ld&lt;&#x2f;code&gt; removes it, too. So we need to tell the linker explicitly that it should keep this section. The &lt;code&gt;KEEP&lt;&#x2f;code&gt; command does exactly that, so we add it to the linker script (&lt;code&gt;linker.ld&lt;&#x2f;code&gt;):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.boot :
{
    &#x2f;* ensure that the multiboot header is at the beginning *&#x2f;
    KEEP(*(.multiboot_header))
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now everything should work again (the green &lt;code&gt;OKAY&lt;&#x2f;code&gt;). But there is another linking issue, which is triggered by some other example code.&lt;&#x2f;p&gt;
&lt;h4 id=&quot;panic-abort&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#panic-abort&quot; aria-label=&quot;Anchor link for: panic-abort&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
panic = &amp;quot;abort&amp;quot;&lt;&#x2f;h4&gt;
&lt;p&gt;The following snippet still fails:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;...
    let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;3&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;).flat_map(|x| &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;x).zip(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;..&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;);
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The error is a linker error again (hence the ugly error message):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
    In function `core::ptr::drop_in_place&amp;lt;core::iter::Zip&amp;lt;
        core::iter::FlatMap&amp;lt;core::ops::Range&amp;lt;i32&amp;gt;, core::ops::Range&amp;lt;i32&amp;gt;,
        closure&amp;gt;, core::ops::RangeFrom&amp;lt;i32&amp;gt;&amp;gt;&amp;gt;&amp;#39;:
        &#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;libcore&#x2f;ptr.rs:66:
    undefined reference to `_Unwind_Resume&amp;#39;
target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
    In function `core::iter::iterator::Iterator::zip&amp;lt;core::iter::FlatMap&amp;lt;
        core::ops::Range&amp;lt;i32&amp;gt;, core::ops::Range&amp;lt;i32&amp;gt;, closure&amp;gt;,
        core::ops::RangeFrom&amp;lt;i32&amp;gt;&amp;gt;&amp;#39;:
        &#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;libcore&#x2f;iter&#x2f;iterator.rs:389:
    undefined reference to `_Unwind_Resume&amp;#39;
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;So the linker can&#x27;t find a function named &lt;code&gt;_Unwind_Resume&lt;&#x2f;code&gt; that is referenced e.g. in &lt;code&gt;iter&#x2f;iterator.rs:389&lt;&#x2f;code&gt; in libcore. This reference is not really there at &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;rust-lang&#x2f;rust&#x2f;blob&#x2f;c58c928e658d2e45f816fd05796a964aa83759da&#x2f;src&#x2f;libcore&#x2f;iter&#x2f;iterator.rs#L389&quot;&gt;line 389&lt;&#x2f;a&gt; of libcore&#x27;s &lt;code&gt;iterator.rs&lt;&#x2f;code&gt;. Instead, it is a compiler inserted &lt;em&gt;landing pad&lt;&#x2f;em&gt;, which is used for panic handling.&lt;&#x2f;p&gt;
&lt;p&gt;By default, the destructors of all stack variables are run when a &lt;code&gt;panic&lt;&#x2f;code&gt; occurs. This is called &lt;em&gt;unwinding&lt;&#x2f;em&gt; and allows parent threads to &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;concurrency.html#panics&quot;&gt;recover from panics&lt;&#x2f;a&gt;. However, it requires a platform specific gcc library, which isn&#x27;t available in our kernel.&lt;&#x2f;p&gt;
&lt;p&gt;Fortunately, Rust allows us to disable unwinding for our target. For that we add the following line to our &lt;code&gt;x86_64-blog_os.json&lt;&#x2f;code&gt; file:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;...&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#ff3333;&quot;&gt;,
  &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;panic-strategy&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;abort&amp;quot;
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;}

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;By setting the &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;nox&#x2f;rust-rfcs&#x2f;blob&#x2f;master&#x2f;text&#x2f;1513-less-unwinding.md&quot;&gt;panic strategy&lt;&#x2f;a&gt; to &lt;code&gt;abort&lt;&#x2f;code&gt; instead of the default &lt;code&gt;unwind&lt;&#x2f;code&gt;, we disable all unwinding in our kernel. Let&#x27;s try &lt;code&gt;make run&lt;&#x2f;code&gt; again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;   Compiling core v0.0.0 (file:&#x2f;&#x2f;&#x2f;â€¦&#x2f;rust&#x2f;src&#x2f;libcore)
    Finished release [optimized] target(s) in 22.24 secs
    Finished dev [unoptimized + debuginfo] target(s) in 0.5 secs
target&#x2f;x86_64-blog_os&#x2f;debug&#x2f;libblog_os.a(blog_os-b5a29f28b14f1f1f.0.o):
    In function `core::ptr::drop_in_place&amp;lt;â€¦&amp;gt;&amp;#39;:
    &#x2f;â€¦&#x2f;src&#x2f;libcore&#x2f;ptr.rs:66:
    undefined reference to `_Unwind_Resume&amp;#39;
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We see that &lt;code&gt;xargo&lt;&#x2f;code&gt; recompiles the &lt;code&gt;core&lt;&#x2f;code&gt; crate, but the &lt;code&gt;_Unwind_Resume&lt;&#x2f;code&gt; error still occurs. This is because our &lt;code&gt;blog_os&lt;&#x2f;code&gt; crate was not recompiled somehow and thus still references the unwinding function. To fix this, we need to force a recompile using &lt;code&gt;cargo clean&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; cargo clean
&amp;gt; make run
   Compiling rlibc v1.0.0
   Compiling blog_os v0.1.0 (file:&#x2f;&#x2f;&#x2f;home&#x2f;philipp&#x2f;Documents&#x2f;blog_os&#x2f;tags)
warning: unused variable: `test` [â€¦]

    Finished dev [unoptimized + debuginfo] target(s) in 0.60 secs
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It worked! We no longer see linker errors and our kernel prints &lt;code&gt;OKAY&lt;&#x2f;code&gt; again.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;hello-world&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#hello-world&quot; aria-label=&quot;Anchor link for: hello-world&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Hello World!&lt;&#x2f;h2&gt;
&lt;p&gt;Finally, it&#x27;s time for a &lt;code&gt;Hello World!&lt;&#x2f;code&gt; from Rust:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;#[no_mangle]
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pub extern fn &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rust_main() {
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; ATTENTION: we have a very small stack and no guard page

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; hello &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= b&lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;Hello World!&amp;quot;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; color_byte &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0x1f&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; white foreground, blue background

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let mut&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; hello_colored &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[color_byte; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;24&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;];
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;for &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(i, char_byte) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;in&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; hello.into_iter().enumerate() {
        hello_colored[i&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;] &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= *&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;char_byte;
    }

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;&#x2f; write `Hello World!` to the center of the VGA text buffer
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;let&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; buffer_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;= &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;0xb8000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1988&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;as *mut _&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;unsafe &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;buffer_ptr &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;=&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; hello_colored };

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;loop&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;{}
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Some notes:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;b&lt;&#x2f;code&gt; prefix creates a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;reference.html#characters-and-strings&quot;&gt;byte string&lt;&#x2f;a&gt;, which is just an array of &lt;code&gt;u8&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;nightly&#x2f;core&#x2f;iter&#x2f;trait.Iterator.html#method.enumerate&quot;&gt;enumerate&lt;&#x2f;a&gt; is an &lt;code&gt;Iterator&lt;&#x2f;code&gt; method that adds the current index &lt;code&gt;i&lt;&#x2f;code&gt; to elements&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;buffer_ptr&lt;&#x2f;code&gt; is a &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;raw-pointers.html&quot;&gt;raw pointer&lt;&#x2f;a&gt; that points to the center of the VGA text buffer&lt;&#x2f;li&gt;
&lt;li&gt;Rust doesn&#x27;t know the VGA buffer and thus can&#x27;t guarantee that writing to the &lt;code&gt;buffer_ptr&lt;&#x2f;code&gt; is safe (it could point to important data). So we need to tell Rust that we know what we are doing by using an &lt;a href=&quot;https:&#x2f;&#x2f;doc.rust-lang.org&#x2f;book&#x2f;unsafe.html&quot;&gt;unsafe block&lt;&#x2f;a&gt;.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h3 id=&quot;stack-overflows&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#stack-overflows&quot; aria-label=&quot;Anchor link for: stack-overflows&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Stack Overflows&lt;&#x2f;h3&gt;
&lt;p&gt;Since we still use the small 64 byte &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;#creating-a-stack&quot;&gt;stack from the last post&lt;&#x2f;a&gt;, we must be careful not to &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Stack_overflow&quot;&gt;overflow&lt;&#x2f;a&gt; it. Normally, Rust tries to avoid stack overflows through &lt;em&gt;guard pages&lt;&#x2f;em&gt;: The page below the stack isn&#x27;t mapped and such a stack overflow triggers a page fault (instead of silently overwriting random memory). But we can&#x27;t unmap the page below our stack right now since we currently use only a single big page. Fortunately the stack is located just above the page tables. So some important page table entry would probably get overwritten on stack overflow and then a page fault occurs, too.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;Until now we write magic bits to some memory location when we want to print something to screen. In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; we create a abstraction for the VGA text buffer that allows us to print strings in different colors and provides a simple interface.&lt;&#x2f;p&gt;
</description>
            </item>
        
            <item>
                <title>Entering Long Mode</title>
                <pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/entering-longmode/</link>
                <guid>https://os.phil-opp.com/entering-longmode/</guid>
                <description>&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;multiboot-kernel&#x2f;&quot;&gt;previous post&lt;&#x2f;a&gt; we created a minimal multiboot kernel. It just prints &lt;code&gt;OK&lt;&#x2f;code&gt; and hangs. The goal is to extend it and call 64-bit &lt;a href=&quot;http:&#x2f;&#x2f;www.rust-lang.org&#x2f;&quot;&gt;Rust&lt;&#x2f;a&gt; code. But the CPU is currently in &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Protected_mode&quot;&gt;protected mode&lt;&#x2f;a&gt; and allows only 32-bit instructions and up to 4GiB memory. So we need to set up &lt;em&gt;Paging&lt;&#x2f;em&gt; and switch to the 64-bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Long_mode&quot;&gt;long mode&lt;&#x2f;a&gt; first.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;I tried to explain everything in detail and to keep the code as simple as possible. If you have any questions, suggestions, or issues, please leave a comment or &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;create an issue&lt;&#x2f;a&gt; on Github. The source code is available in a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_2&#x2f;src&#x2f;arch&#x2f;x86_64&quot;&gt;repository&lt;&#x2f;a&gt;, too.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;some-tests&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#some-tests&quot; aria-label=&quot;Anchor link for: some-tests&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Some Tests&lt;&#x2f;h2&gt;
&lt;p&gt;To avoid bugs and strange errors on old CPUs we should check if the processor supports every needed feature. If not, the kernel should abort and display an error message. To handle errors easily, we create an error procedure in &lt;code&gt;boot.asm&lt;&#x2f;code&gt;. It prints a rudimentary &lt;code&gt;ERR: X&lt;&#x2f;code&gt; message, where X is an error code letter, and hangs:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#608b4e;&quot;&gt;; Prints `ERR: ` and the given error code to screen and hangs.
; parameter: error code (in ascii) in al
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f524f45
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8004&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f3a4f52
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8008&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x4f204f20
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;byte  [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb800a&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], al
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;At address &lt;code&gt;0xb8000&lt;&#x2f;code&gt; begins the so-called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;VGA-compatible_text_mode&quot;&gt;VGA text buffer&lt;&#x2f;a&gt;. It&#x27;s an array of screen characters that are displayed by the graphics card. A &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;printing-to-screen&#x2f;&quot;&gt;future post&lt;&#x2f;a&gt; will cover the VGA buffer in detail and create a Rust interface to it. But for now, manual bit-fiddling is the easiest option.&lt;&#x2f;p&gt;
&lt;p&gt;A screen character consists of a 8 bit color code and a 8 bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;ASCII&quot;&gt;ASCII&lt;&#x2f;a&gt; character. We used the color code &lt;code&gt;4f&lt;&#x2f;code&gt; for all characters, which means white text on red background. &lt;code&gt;0x52&lt;&#x2f;code&gt; is an ASCII &lt;code&gt;R&lt;&#x2f;code&gt;, &lt;code&gt;0x45&lt;&#x2f;code&gt; is an &lt;code&gt;E&lt;&#x2f;code&gt;, &lt;code&gt;0x3a&lt;&#x2f;code&gt; is a &lt;code&gt;:&lt;&#x2f;code&gt;, and &lt;code&gt;0x20&lt;&#x2f;code&gt; is a space. The second space is overwritten by the given ASCII byte. Finally the CPU is stopped with the &lt;code&gt;hlt&lt;&#x2f;code&gt; instruction.&lt;&#x2f;p&gt;
&lt;p&gt;Now we can add some check &lt;em&gt;functions&lt;&#x2f;em&gt;. A function is just a normal label with an &lt;code&gt;ret&lt;&#x2f;code&gt; (return) instruction at the end. The &lt;code&gt;call&lt;&#x2f;code&gt; instruction can be used to call it. Unlike the &lt;code&gt;jmp&lt;&#x2f;code&gt; instruction that just jumps to a memory address, the &lt;code&gt;call&lt;&#x2f;code&gt; instruction will push a return address to the stack (and the &lt;code&gt;ret&lt;&#x2f;code&gt; will jump to this address). But we don&#x27;t have a stack yet. The &lt;a href=&quot;http:&#x2f;&#x2f;stackoverflow.com&#x2f;a&#x2f;1464052&#x2f;866447&quot;&gt;stack pointer&lt;&#x2f;a&gt; in the esp register could point to some important data or even invalid memory. So we need to update it and point it to some valid stack memory.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;creating-a-stack&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-a-stack&quot; aria-label=&quot;Anchor link for: creating-a-stack&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating a Stack&lt;&#x2f;h3&gt;
&lt;p&gt;To create stack memory we reserve some bytes at the end of our &lt;code&gt;boot.asm&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
section .bss
stack_bottom:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;64
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_top:
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;A stack doesn&#x27;t need to be initialized because we will &lt;code&gt;pop&lt;&#x2f;code&gt; only when we &lt;code&gt;pushed&lt;&#x2f;code&gt; before. So storing the stack memory in the executable file would make it unnecessary large. By using the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;.bss&quot;&gt;.bss&lt;&#x2f;a&gt; section and the &lt;code&gt;resb&lt;&#x2f;code&gt; (reserve byte) command, we just store the length of the uninitialized data (= 64). When loading the executable, GRUB will create the section of required size in memory.&lt;&#x2f;p&gt;
&lt;p&gt;To use the new stack, we update the stack pointer register right after &lt;code&gt;start&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;global start

section .text
bits 32
start:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;esp, stack_top&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; print `OK` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use &lt;code&gt;stack_top&lt;&#x2f;code&gt; because the stack grows downwards: A &lt;code&gt;push eax&lt;&#x2f;code&gt; subtracts 4 from &lt;code&gt;esp&lt;&#x2f;code&gt; and does a &lt;code&gt;mov [esp], eax&lt;&#x2f;code&gt; afterwards (&lt;code&gt;eax&lt;&#x2f;code&gt; is a general purpose register).&lt;&#x2f;p&gt;
&lt;p&gt;Now we have a valid stack pointer and are able to call functions. The following check functions are just here for completeness and I won&#x27;t explain details. Basically they all work the same: They will check for a feature and jump to &lt;code&gt;error&lt;&#x2f;code&gt; if it&#x27;s not available.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;multiboot-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multiboot-check&quot; aria-label=&quot;Anchor link for: multiboot-check&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Multiboot check&lt;&#x2f;h3&gt;
&lt;p&gt;We rely on some Multiboot features in the next posts. To make sure the kernel was really loaded by a Multiboot compliant bootloader, we can check the &lt;code&gt;eax&lt;&#x2f;code&gt; register. According to the Multiboot specification (&lt;a href=&quot;http:&#x2f;&#x2f;nongnu.askapache.com&#x2f;grub&#x2f;phcoder&#x2f;multiboot.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;), the bootloader must write the magic value &lt;code&gt;0x36d76289&lt;&#x2f;code&gt; to it before loading a kernel. To verify that we can add a simple function:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_multiboot:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x36d76289
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jne &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_multiboot
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_multiboot:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;al, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;0&amp;quot;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We use the &lt;code&gt;cmp&lt;&#x2f;code&gt; instruction to compare the value in &lt;code&gt;eax&lt;&#x2f;code&gt; to the magic value. If the values are equal, the &lt;code&gt;cmp&lt;&#x2f;code&gt; instruction sets the zero flag in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;FLAGS register&lt;&#x2f;a&gt;. The &lt;code&gt;jne&lt;&#x2f;code&gt; (â€œjump if not equalâ€) instruction reads this zero flag and jumps to the given address if it&#x27;s not set. Thus we jump to the &lt;code&gt;.no_multiboot&lt;&#x2f;code&gt; label if &lt;code&gt;eax&lt;&#x2f;code&gt; does not contain the magic value.&lt;&#x2f;p&gt;
&lt;p&gt;In &lt;code&gt;no_multiboot&lt;&#x2f;code&gt;, we use the &lt;code&gt;jmp&lt;&#x2f;code&gt; (â€œjumpâ€) instruction to jump to our error function. We could just as well use the &lt;code&gt;call&lt;&#x2f;code&gt; instruction, which additionally pushes the return address. But the return address is not needed because &lt;code&gt;error&lt;&#x2f;code&gt; never returns. To pass &lt;code&gt;0&lt;&#x2f;code&gt; as error code to the &lt;code&gt;error&lt;&#x2f;code&gt; function, we move it into &lt;code&gt;al&lt;&#x2f;code&gt; before the jump (&lt;code&gt;error&lt;&#x2f;code&gt; will read it from there).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;cpuid-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#cpuid-check&quot; aria-label=&quot;Anchor link for: cpuid-check&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
CPUID check&lt;&#x2f;h3&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;CPUID&quot;&gt;CPUID&lt;&#x2f;a&gt; is a CPU instruction that can be used to get various information about the CPU. But not every processor supports it. CPUID detection is quite laborious, so we just copy a detection function from the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Setting_Up_Long_Mode#Detection_of_CPUID&quot;&gt;OSDev wiki&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_cpuid:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; Check if CPUID is supported by attempting to flip the ID bit (bit 21)
    ; in the FLAGS register. If we can flip it, CPUID is available.

    ; Copy FLAGS in to EAX via stack
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pushfd
    pop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Copy to ECX as well for comparing later on
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx, eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Flip the ID bit
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;xor &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;21&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Copy EAX to FLAGS via the stack
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;push &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;popfd&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Copy FLAGS back to EAX (with the flipped bit if CPUID is supported)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;pushfd
    pop &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Restore FLAGS from the old version stored in ECX (i.e. flipping the
    ; ID bit back if it was ever flipped).
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;push &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;popfd&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; Compare EAX and ECX. If they are equal then that means the bit
    ; wasn&amp;#39;t flipped, and CPUID isn&amp;#39;t supported.
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, ecx
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;je &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_cpuid
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_cpuid:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;al, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;1&amp;quot;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Basically, the &lt;code&gt;CPUID&lt;&#x2f;code&gt; instruction is supported if we can flip some bit in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;FLAGS_register&quot;&gt;FLAGS register&lt;&#x2f;a&gt;. We can&#x27;t operate on the flags register directly, so we need to load it into some general purpose register such as &lt;code&gt;eax&lt;&#x2f;code&gt; first. The only way to do this is to push the &lt;code&gt;FLAGS&lt;&#x2f;code&gt; register on the stack through the &lt;code&gt;pushfd&lt;&#x2f;code&gt; instruction and then pop it into &lt;code&gt;eax&lt;&#x2f;code&gt;. Equally, we write it back through &lt;code&gt;push ecx&lt;&#x2f;code&gt; and &lt;code&gt;popfd&lt;&#x2f;code&gt;. To flip the bit we use the &lt;code&gt;xor&lt;&#x2f;code&gt; instruction to perform an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Exclusive_or&quot;&gt;exclusive OR&lt;&#x2f;a&gt;. Finally we compare the two values and jump to &lt;code&gt;.no_cpuid&lt;&#x2f;code&gt; if both are equal (&lt;code&gt;je&lt;&#x2f;code&gt; â€“ â€œjump if equalâ€). The &lt;code&gt;.no_cpuid&lt;&#x2f;code&gt; code just jumps to the &lt;code&gt;error&lt;&#x2f;code&gt; function with error code &lt;code&gt;1&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Don&#x27;t worry, you don&#x27;t need to understand the details.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;long-mode-check&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#long-mode-check&quot; aria-label=&quot;Anchor link for: long-mode-check&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Long Mode check&lt;&#x2f;h3&gt;
&lt;p&gt;Now we can use CPUID to detect whether long mode can be used. I use code from &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Setting_Up_Long_Mode#x86_or_x86-64&quot;&gt;OSDev&lt;&#x2f;a&gt; again:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_long_mode:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; test if extended processor info in available
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; implicit argument for cpuid
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cpuid&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                  ; get highest supported argument
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000001&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; it needs to be at least 0x80000001
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_long_mode&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; if it&amp;#39;s less, the CPU is too old for long mode

    ; use extended info to test if long mode is available
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x80000001&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; argument for extended processor info
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cpuid&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                  ; returns various feature bits in ecx and edx
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;test &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;edx, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;29&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;      ; test if the LM-bit is set in the D-register
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jz &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_long_mode&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; If it&amp;#39;s not set, there is no long mode
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.no_long_mode:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;al, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#d69d85;&quot;&gt;&amp;quot;2&amp;quot;
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;error
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Like many low-level things, CPUID is a bit strange. Instead of taking a parameter, the &lt;code&gt;cpuid&lt;&#x2f;code&gt; instruction implicitly uses the &lt;code&gt;eax&lt;&#x2f;code&gt; register as argument. To test if long mode is available, we need to call &lt;code&gt;cpuid&lt;&#x2f;code&gt; with &lt;code&gt;0x80000001&lt;&#x2f;code&gt; in &lt;code&gt;eax&lt;&#x2f;code&gt;. This loads some information to the &lt;code&gt;ecx&lt;&#x2f;code&gt; and &lt;code&gt;edx&lt;&#x2f;code&gt; registers. Long mode is supported if the 29th bit in &lt;code&gt;edx&lt;&#x2f;code&gt; is set. &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;CPUID#EAX.3D80000001h:_Extended_Processor_Info_and_Feature_Bits&quot;&gt;Wikipedia&lt;&#x2f;a&gt; has detailed information.&lt;&#x2f;p&gt;
&lt;p&gt;If you look at the assembly above, you&#x27;ll probably notice that we call &lt;code&gt;cpuid&lt;&#x2f;code&gt; twice. The reason is that the CPUID command started with only a few functions and was extended over time. So old processors may not know the &lt;code&gt;0x80000001&lt;&#x2f;code&gt; argument at all. To test if they do, we need to invoke &lt;code&gt;cpuid&lt;&#x2f;code&gt; with &lt;code&gt;0x80000000&lt;&#x2f;code&gt; in &lt;code&gt;eax&lt;&#x2f;code&gt; first. It returns the highest supported parameter value in &lt;code&gt;eax&lt;&#x2f;code&gt;. If it&#x27;s at least &lt;code&gt;0x80000001&lt;&#x2f;code&gt;, we can test for long mode as described above. Else the CPU is old and doesn&#x27;t know what long mode is either. In that case, we directly jump to &lt;code&gt;.no_long_mode&lt;&#x2f;code&gt; through the &lt;code&gt;jb&lt;&#x2f;code&gt; instruction (â€œjump if belowâ€).&lt;&#x2f;p&gt;
&lt;h3 id=&quot;putting-it-together&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#putting-it-together&quot; aria-label=&quot;Anchor link for: putting-it-together&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Putting it together&lt;&#x2f;h3&gt;
&lt;p&gt;We just call these check functions right after start:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;global start

section .text
bits 32
start:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;esp, stack_top

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_multiboot
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_cpuid
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_long_mode&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; print `OK` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When the CPU doesn&#x27;t support a needed feature, we get an error message with an unique error code. Now we can start the real work.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#paging&quot; aria-label=&quot;Anchor link for: paging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Paging&lt;&#x2f;h2&gt;
&lt;p&gt;&lt;em&gt;Paging&lt;&#x2f;em&gt; is a memory management scheme that separates virtual and physical memory. The address space is split into equal sized &lt;em&gt;pages&lt;&#x2f;em&gt; and a &lt;em&gt;page table&lt;&#x2f;em&gt; specifies which virtual page points to which physical page. If you never heard of paging, you might want to look at the paging introduction (&lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;vm-paging.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) of the &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;&quot;&gt;Three Easy Pieces&lt;&#x2f;a&gt; OS book.&lt;&#x2f;p&gt;
&lt;p&gt;In long mode, x86 uses a page size of 4096 bytes and a 4 level page table that consists of:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the Page-Map Level-4 Table (PML4),&lt;&#x2f;li&gt;
&lt;li&gt;the Page-Directory Pointer Table (PDP),&lt;&#x2f;li&gt;
&lt;li&gt;the Page-Directory Table (PD),&lt;&#x2f;li&gt;
&lt;li&gt;and the Page Table (PT).&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;As I don&#x27;t like these names, I will call them P4, P3, P2, and P1 from now on.&lt;&#x2f;p&gt;
&lt;p&gt;Each page table contains 512 entries and one entry is 8 bytes, so they fit exactly in one page (&lt;code&gt;512*8 = 4096&lt;&#x2f;code&gt;). To translate a virtual address to a physical address the CPU&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#hardware_lookup&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; will do the following&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#virtual_physical_translation_source&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;:&lt;&#x2f;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;X86_Paging_64bit.svg&quot; alt=&quot;translation of virtual to physical addresses in 64 bit mode&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;Get the address of the P4 table from the CR3 register&lt;&#x2f;li&gt;
&lt;li&gt;Use bits 39-47 (9 bits) as an index into P4 (&lt;code&gt;2^9 = 512 = number of entries&lt;&#x2f;code&gt;)&lt;&#x2f;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P3&lt;&#x2f;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P2&lt;&#x2f;li&gt;
&lt;li&gt;Use the following 9 bits as an index into P1&lt;&#x2f;li&gt;
&lt;li&gt;Use the last 12 bits as page offset (&lt;code&gt;2^12 = 4096 = page size&lt;&#x2f;code&gt;)&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;But what happens to bits 48-63 of the 64-bit virtual address? Well, they can&#x27;t be used. The â€œ64-bitâ€ long mode is in fact just a 48-bit mode. The bits 48-63 must be copies of bit 47, so each valid virtual address is still unique. For more information see &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;X86-64#Virtual_address_space_details&quot;&gt;Wikipedia&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;An entry in the P4, P3, P2, and P1 tables consists of the page aligned 52-bit &lt;em&gt;physical&lt;&#x2f;em&gt; address of the frame or the next page table and the following bits that can be OR-ed in:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)                &lt;&#x2f;th&gt;&lt;th&gt;Name &lt;&#x2f;th&gt;&lt;th&gt;Meaning&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0 &lt;&#x2f;td&gt;&lt;td&gt;present &lt;&#x2f;td&gt;&lt;td&gt;the page is currently in memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;1 &lt;&#x2f;td&gt;&lt;td&gt;writable &lt;&#x2f;td&gt;&lt;td&gt;it&#x27;s allowed to write to this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;2 &lt;&#x2f;td&gt;&lt;td&gt;user accessible &lt;&#x2f;td&gt;&lt;td&gt;if not set, only kernel mode code can access this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;3 &lt;&#x2f;td&gt;&lt;td&gt;write through caching &lt;&#x2f;td&gt;&lt;td&gt;writes go directly to memory&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;4 &lt;&#x2f;td&gt;&lt;td&gt;disable cache &lt;&#x2f;td&gt;&lt;td&gt;no cache is used for this page&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;5 &lt;&#x2f;td&gt;&lt;td&gt;accessed &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when this page is used&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;6 &lt;&#x2f;td&gt;&lt;td&gt;dirty &lt;&#x2f;td&gt;&lt;td&gt;the CPU sets this bit when a write to this page occurs&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;7 &lt;&#x2f;td&gt;&lt;td&gt;huge page&#x2f;null &lt;&#x2f;td&gt;&lt;td&gt;must be 0 in P1 and P4, creates a 1GiB page in P3, creates a 2MiB page in P2&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;8 &lt;&#x2f;td&gt;&lt;td&gt;global &lt;&#x2f;td&gt;&lt;td&gt;page isn&#x27;t flushed from caches on address space switch (PGE bit of CR4 register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;9-11 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;52-62 &lt;&#x2f;td&gt;&lt;td&gt;available &lt;&#x2f;td&gt;&lt;td&gt;can be used freely by the OS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;63 &lt;&#x2f;td&gt;&lt;td&gt;no execute &lt;&#x2f;td&gt;&lt;td&gt;forbid executing code on this page (the NXE bit in the EFER register must be set)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;h3 id=&quot;set-up-identity-paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#set-up-identity-paging&quot; aria-label=&quot;Anchor link for: set-up-identity-paging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Set Up Identity Paging&lt;&#x2f;h3&gt;
&lt;p&gt;When we switch to long mode, paging will be activated automatically. The CPU will then try to read the instruction at the following address, but this address is now a virtual address. So we need to do &lt;em&gt;identity mapping&lt;&#x2f;em&gt;, i.e. map a physical address to the same virtual address.&lt;&#x2f;p&gt;
&lt;p&gt;The &lt;code&gt;huge page&lt;&#x2f;code&gt; bit is now very useful to us. It creates a 2MiB (when used in P2) or even a 1GiB page (when used in P3). So we could map the first &lt;em&gt;gigabytes&lt;&#x2f;em&gt; of the kernel with only one P4 and one P3 table by using 1GiB pages. Unfortunately 1GiB pages are relatively new feature, for example Intel introduced it 2010 in the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Westmere_(microarchitecture)#Technology&quot;&gt;Westmere architecture&lt;&#x2f;a&gt;. Therefore we will use 2MiB pages instead to make our kernel compatible to older computers, too.&lt;&#x2f;p&gt;
&lt;p&gt;To identity map the first gigabyte of our kernel with 512 2MiB pages, we need one P4, one P3, and one P2 table. Of course we will replace them with finer-grained tables later. But now that we&#x27;re stuck with assembly, we choose the easiest way.&lt;&#x2f;p&gt;
&lt;p&gt;We can add these two tables at the beginning&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#page_table_alignment&quot;&gt;3&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; of the &lt;code&gt;.bss&lt;&#x2f;code&gt; section:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...

section .bss
align &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p4_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p3_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;p2_table:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;4096
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_bottom:
    resb &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;64
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;stack_top:
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;resb&lt;&#x2f;code&gt; command reserves the specified amount of bytes without initializing them, so the 8KiB don&#x27;t need to be saved in the executable. The &lt;code&gt;align 4096&lt;&#x2f;code&gt; ensures that the page tables are page aligned.&lt;&#x2f;p&gt;
&lt;p&gt;When GRUB creates the &lt;code&gt;.bss&lt;&#x2f;code&gt; section in memory, it will initialize it to &lt;code&gt;0&lt;&#x2f;code&gt;. So the &lt;code&gt;p4_table&lt;&#x2f;code&gt; is already valid (it contains 512 non-present entries) but not very useful. To be able to map 2MiB pages, we need to link P4&#x27;s first entry to the &lt;code&gt;p3_table&lt;&#x2f;code&gt; and P3&#x27;s first entry to the the &lt;code&gt;p2_table&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_up_page_tables:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; map first P4 entry to P3 table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, p3_table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, 0b11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[p4_table], eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; map first P3 entry to P2 table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, p2_table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, 0b11&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[p3_table], eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; TODO map each P2 entry to a huge 2MiB page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We just set the present and writable bits (&lt;code&gt;0b11&lt;&#x2f;code&gt; is a binary number) in the aligned P3 table address and move it to the first 4 bytes of the P4 table. Then we do the same to link the first P3 entry to the &lt;code&gt;p2_table&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;p&gt;Now we need to map P2&#x27;s first entry to a huge page starting at 0, P2&#x27;s second entry to a huge page starting at 2MiB, P2&#x27;s third entry to a huge page starting at 4MiB, and so on. It&#x27;s time for our first (and only) assembly loop:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_up_page_tables:
    ...&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; map each P2 entry to a huge 2MiB page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;         ; counter variable

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.map_p2_table:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; map ecx-th P2 entry to a huge page that starts at address 2MiB*ecx
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x200000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;  ; 2MiB
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mul &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;            ; start address of ecx-th page
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, 0b10000011&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; present + writable + huge
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[p2_table + ecx * &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; map ecx-th entry

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;inc &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;            ; increase counter
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;cmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;512&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;       ; if counter == 512, the whole P2 table is mapped
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jne &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.map_p2_table&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;  ; else map the next entry

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Maybe I should first explain how an assembly loop works. We use the &lt;code&gt;ecx&lt;&#x2f;code&gt; register as a counter variable, just like &lt;code&gt;i&lt;&#x2f;code&gt; in a for loop. After mapping the &lt;code&gt;ecx-th&lt;&#x2f;code&gt; entry, we increase &lt;code&gt;ecx&lt;&#x2f;code&gt; by one and jump to &lt;code&gt;.map_p2_table&lt;&#x2f;code&gt; again if it&#x27;s still smaller than 512.&lt;&#x2f;p&gt;
&lt;p&gt;To map a P2 entry we first calculate the start address of its page in &lt;code&gt;eax&lt;&#x2f;code&gt;: The &lt;code&gt;ecx-th&lt;&#x2f;code&gt; entry needs to be mapped to &lt;code&gt;ecx * 2MiB&lt;&#x2f;code&gt;. We use the &lt;code&gt;mul&lt;&#x2f;code&gt; operation for that, which multiplies &lt;code&gt;eax&lt;&#x2f;code&gt; with the given register and stores the result in &lt;code&gt;eax&lt;&#x2f;code&gt;. Then we set the &lt;code&gt;present&lt;&#x2f;code&gt;, &lt;code&gt;writable&lt;&#x2f;code&gt;, and &lt;code&gt;huge page&lt;&#x2f;code&gt; bits and write it to the P2 entry. The address of the &lt;code&gt;ecx-th&lt;&#x2f;code&gt; entry in P2 is &lt;code&gt;p2_table + ecx * 8&lt;&#x2f;code&gt;, because each entry is 8 bytes large.&lt;&#x2f;p&gt;
&lt;p&gt;Now the first gigabyte (512 * 2MiB) of our kernel is identity mapped and thus accessible through the same physical and virtual addresses.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;enable-paging&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#enable-paging&quot; aria-label=&quot;Anchor link for: enable-paging&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Enable Paging&lt;&#x2f;h3&gt;
&lt;p&gt;To enable paging and enter long mode, we need to do the following:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;write the address of the P4 table to the CR3 register (the CPU will look there, see the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;#paging&quot;&gt;paging section&lt;&#x2f;a&gt;)&lt;&#x2f;li&gt;
&lt;li&gt;long mode is an extension of &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Physical_Address_Extension&quot;&gt;Physical Address Extension&lt;&#x2f;a&gt; (PAE), so we need to enable PAE first&lt;&#x2f;li&gt;
&lt;li&gt;Set the long mode bit in the EFER register&lt;&#x2f;li&gt;
&lt;li&gt;Enable Paging&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;The assembly function looks like this (some boring bit-moving to various registers):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;enable_paging:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; load P4 to cr3 register (cpu uses this to access the P4 table)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, p4_table
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cr3, eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; enable PAE-flag in cr4 (Physical Address Extension)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, cr4
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;5
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cr4, eax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; set the long mode bit in the EFER MSR (model specific register)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ecx, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xC0000080
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;rdmsr
    or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;wrmsr&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; enable paging in the cr0 register
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, cr0
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;or &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;eax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt; &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;31
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cr0, eax

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;ret
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;or eax, 1 &amp;lt;&amp;lt; X&lt;&#x2f;code&gt; is a common pattern. It sets the bit &lt;code&gt;X&lt;&#x2f;code&gt; in the eax register (&lt;code&gt;&amp;lt;&amp;lt;&lt;&#x2f;code&gt; is a left shift). Through &lt;code&gt;rdmsr&lt;&#x2f;code&gt; and &lt;code&gt;wrmsr&lt;&#x2f;code&gt; it&#x27;s possible to read&#x2f;write to the so-called model specific registers at address &lt;code&gt;ecx&lt;&#x2f;code&gt; (in this case &lt;code&gt;ecx&lt;&#x2f;code&gt; points to the EFER register).&lt;&#x2f;p&gt;
&lt;p&gt;Finally we need to call our new functions in &lt;code&gt;start&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
start:
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;esp, stack_top

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_multiboot
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_cpuid
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;check_long_mode

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set_up_page_tables&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;enable_paging&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;     ; new

    ; print `OK` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f4b2f4f
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;To test it we execute &lt;code&gt;make run&lt;&#x2f;code&gt;. If the green OK is still printed, we have successfully enabled paging!&lt;&#x2f;p&gt;
&lt;h2 id=&quot;the-global-descriptor-table&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-global-descriptor-table&quot; aria-label=&quot;Anchor link for: the-global-descriptor-table&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Global Descriptor Table&lt;&#x2f;h2&gt;
&lt;p&gt;After enabling Paging, the processor is in long mode. So we can use 64-bit instructions now, right? Wrong. The processor is still in a 32-bit compatibility submode. To actually execute 64-bit code, we need to set up a new Global Descriptor Table.
The Global Descriptor Table (GDT) was used for &lt;em&gt;Segmentation&lt;&#x2f;em&gt; in old operating systems. I won&#x27;t explain Segmentation but the &lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;&quot;&gt;Three Easy Pieces&lt;&#x2f;a&gt; OS book has good introduction (&lt;a href=&quot;http:&#x2f;&#x2f;pages.cs.wisc.edu&#x2f;%7Eremzi&#x2f;OSTEP&#x2f;vm-segmentation.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) again.&lt;&#x2f;p&gt;
&lt;p&gt;Today almost everyone uses Paging instead of Segmentation (and so do we). But on x86, a GDT is always required, even when you&#x27;re not using Segmentation. GRUB has set up a valid 32-bit GDT for us but now we need to switch to a long mode GDT.&lt;&#x2f;p&gt;
&lt;p&gt;A GDT always starts with a 0-entry and contains an arbitrary number of segment entries afterwards. A 64-bit entry has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Bit(s)                &lt;&#x2f;th&gt;&lt;th&gt;Name &lt;&#x2f;th&gt;&lt;th&gt;Meaning&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0-41 &lt;&#x2f;td&gt;&lt;td&gt;ignored &lt;&#x2f;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;42 &lt;&#x2f;td&gt;&lt;td&gt;conforming &lt;&#x2f;td&gt;&lt;td&gt;the current privilege level can be higher than the specified level for code segments (else it must match exactly)&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;43 &lt;&#x2f;td&gt;&lt;td&gt;executable &lt;&#x2f;td&gt;&lt;td&gt;if set, it&#x27;s a code segment, else it&#x27;s a data segment&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;44 &lt;&#x2f;td&gt;&lt;td&gt;descriptor type &lt;&#x2f;td&gt;&lt;td&gt;should be 1 for code and data segments&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;45-46 &lt;&#x2f;td&gt;&lt;td&gt;privilege &lt;&#x2f;td&gt;&lt;td&gt;the &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Security#Rings&quot;&gt;ring level&lt;&#x2f;a&gt;: 0 for kernel, 3 for user&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;47 &lt;&#x2f;td&gt;&lt;td&gt;present &lt;&#x2f;td&gt;&lt;td&gt;must be 1 for valid selectors&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;48-52 &lt;&#x2f;td&gt;&lt;td&gt;ignored &lt;&#x2f;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;53 &lt;&#x2f;td&gt;&lt;td&gt;64-bit &lt;&#x2f;td&gt;&lt;td&gt;should be set for 64-bit code segments&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;54 &lt;&#x2f;td&gt;&lt;td&gt;32-bit &lt;&#x2f;td&gt;&lt;td&gt;must be 0 for 64-bit segments&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;55-63 &lt;&#x2f;td&gt;&lt;td&gt;ignored &lt;&#x2f;td&gt;&lt;td&gt;ignored in 64-bit mode&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;We need one code segment, a data segment is not necessary in 64-bit mode. Code segments have the following bits set: &lt;em&gt;descriptor type&lt;&#x2f;em&gt;, &lt;em&gt;present&lt;&#x2f;em&gt;, &lt;em&gt;executable&lt;&#x2f;em&gt; and the &lt;em&gt;64-bit&lt;&#x2f;em&gt; flag. Translated to assembly the long mode GDT looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section .rodata
gdt64:
    dq &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dq (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We chose the &lt;code&gt;.rodata&lt;&#x2f;code&gt; section here because it&#x27;s initialized read-only data. The &lt;code&gt;dq&lt;&#x2f;code&gt; command stands for &lt;code&gt;define quad&lt;&#x2f;code&gt; and outputs a 64-bit constant (similar to &lt;code&gt;dw&lt;&#x2f;code&gt; and &lt;code&gt;dd&lt;&#x2f;code&gt;). And the &lt;code&gt;(1&amp;lt;&amp;lt;43)&lt;&#x2f;code&gt; is a bit shift that sets bit 43.&lt;&#x2f;p&gt;
&lt;h3 id=&quot;loading-the-gdt&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#loading-the-gdt&quot; aria-label=&quot;Anchor link for: loading-the-gdt&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Loading the GDT&lt;&#x2f;h3&gt;
&lt;p&gt;To load our new 64-bit GDT, we have to tell the CPU its address and length. We do this by passing the memory location of a special pointer structure to the &lt;code&gt;lgdt&lt;&#x2f;code&gt; (load GDT) instruction. The pointer structure looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt64:
    dq &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dq (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.pointer:
    dw $ - gdt64 - &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dq gdt64
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The first 2 bytes specify the (GDT length - 1). The &lt;code&gt;$&lt;&#x2f;code&gt; is a special symbol that is replaced with the current address (it&#x27;s equal to &lt;code&gt;.pointer&lt;&#x2f;code&gt; in our case). The following 8 bytes specify the GDT address. Labels that start with a point (such as &lt;code&gt;.pointer&lt;&#x2f;code&gt;) are sub-labels of the last label without point. To access them, they must be prefixed with the parent label (e.g., &lt;code&gt;gdt64.pointer&lt;&#x2f;code&gt;).&lt;&#x2f;p&gt;
&lt;p&gt;Now we can load the GDT in &lt;code&gt;start&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;start:
    ...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;call &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;enable_paging&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; load the 64-bit GDT
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;lgdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[gdt64.pointer]&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; print `OK` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;When you still see the green &lt;code&gt;OK&lt;&#x2f;code&gt;, everything went fine and the new GDT is loaded. But we still can&#x27;t execute 64-bit code: The code selector register &lt;code&gt;cs&lt;&#x2f;code&gt; still has the values from the old GDT. To update it, we need to load it with the GDT offset (in bytes) of the desired segment. In our case the code segment starts at byte 8 of the GDT, but we don&#x27;t want to hardcode that 8 (in case we modify our GDT later). Instead, we add a &lt;code&gt;.code&lt;&#x2f;code&gt; label to our GDT, that calculates the offset directly from the GDT:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section .rodata
gdt64:
    dq &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; zero entry
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.code: equ $ - gdt64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; new
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dq (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;43&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;44&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;47&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;) | (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;1&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;lt;&amp;lt;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;53&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; code segment
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;.pointer:
    ...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;We can&#x27;t just use a normal label here, since we need the table &lt;em&gt;offset&lt;&#x2f;em&gt;. We calculate this offset using the current address &lt;code&gt;$&lt;&#x2f;code&gt; and set the label to this value using &lt;a href=&quot;http:&#x2f;&#x2f;www.nasm.us&#x2f;doc&#x2f;nasmdoc3.html#section-3.2.4&quot;&gt;equ&lt;&#x2f;a&gt;. Now we can use &lt;code&gt;gdt64.code&lt;&#x2f;code&gt; instead of 8 and this label will still work if we modify the GDT.&lt;&#x2f;p&gt;
&lt;p&gt;In order to finally enter the true 64-bit mode, we need to load &lt;code&gt;cs&lt;&#x2f;code&gt; with &lt;code&gt;gdt64.code&lt;&#x2f;code&gt;. But we can&#x27;t do it through &lt;code&gt;mov&lt;&#x2f;code&gt;. The only way to reload the code selector is a &lt;em&gt;far jump&lt;&#x2f;em&gt; or a &lt;em&gt;far return&lt;&#x2f;em&gt;. These instructions work like a normal jump&#x2f;return but change the code selector. We use a far jump to a long mode label:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;global start
extern long_mode_start
...
start:
    ...
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;lgdt &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;[gdt64.pointer]

    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;jmp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gdt64.code:long_mode_start
...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The actual &lt;code&gt;long_mode_start&lt;&#x2f;code&gt; label is defined as &lt;code&gt;extern&lt;&#x2f;code&gt;, so it&#x27;s part of another file. The &lt;code&gt;jmp gdt64.code:long_mode_start&lt;&#x2f;code&gt; is the mentioned far jump.&lt;&#x2f;p&gt;
&lt;p&gt;I put the 64-bit code into a new file to separate it from the 32-bit code, thereby we can&#x27;t call the (now invalid) 32-bit code accidentally. The new file (I named it &lt;code&gt;long_mode_init.asm&lt;&#x2f;code&gt;) looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;global long_mode_start

section .text
bits 64
long_mode_start:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; print `OKAY` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f592f412f4b2f4f
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], rax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;You should see a green &lt;code&gt;OKAY&lt;&#x2f;code&gt; on the screen. Some notes on this last step:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;As the CPU expects 64-bit instructions now, we use &lt;code&gt;bits 64&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;We can now use the extended registers. Instead of the 32-bit &lt;code&gt;eax&lt;&#x2f;code&gt;, &lt;code&gt;ebx&lt;&#x2f;code&gt;, etc. we now have the 64-bit &lt;code&gt;rax&lt;&#x2f;code&gt;, &lt;code&gt;rbx&lt;&#x2f;code&gt;, â€¦&lt;&#x2f;li&gt;
&lt;li&gt;and we can write these 64-bit registers directly to memory using &lt;code&gt;mov qword&lt;&#x2f;code&gt; (quad word)&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;&lt;em&gt;Congratulations&lt;&#x2f;em&gt;! You have successfully wrestled through this CPU configuration and compatibility mode mess :).&lt;&#x2f;p&gt;
&lt;h4 id=&quot;one-last-thing&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#one-last-thing&quot; aria-label=&quot;Anchor link for: one-last-thing&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
One Last Thing&lt;&#x2f;h4&gt;
&lt;p&gt;Above, we reloaded the code segment register &lt;code&gt;cs&lt;&#x2f;code&gt; with the new GDT offset. However, the data segment registers &lt;code&gt;ss&lt;&#x2f;code&gt;, &lt;code&gt;ds&lt;&#x2f;code&gt;, &lt;code&gt;es&lt;&#x2f;code&gt;, &lt;code&gt;fs&lt;&#x2f;code&gt;, and &lt;code&gt;gs&lt;&#x2f;code&gt; still contain the data segment offsets of the old GDT. This isn&#x27;t necessarily bad, since they&#x27;re ignored by almost all instructions in 64-bit mode. However, there are a few instructions that expect a valid data segment descriptor &lt;em&gt;or the null descriptor&lt;&#x2f;em&gt; in those registers. An example is the the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;#the&quot;&gt;iretq&lt;&#x2f;a&gt; instruction that we&#x27;ll need in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;returning-from-exceptions&#x2f;&quot;&gt;&lt;em&gt;Returning from Exceptions&lt;&#x2f;em&gt;&lt;&#x2f;a&gt; post.&lt;&#x2f;p&gt;
&lt;p&gt;To avoid future problems, we reload all data segment registers with null:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;long_mode_start:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; load 0 into all data segment registers
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ax, &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ss, ax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ds, ax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;es, ax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;fs, ax
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;gs, ax&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; print `OKAY` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;...
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;It&#x27;s time to finally leave assembly behind and switch to &lt;a href=&quot;http:&#x2f;&#x2f;www.rust-lang.org&#x2f;&quot;&gt;Rust&lt;&#x2f;a&gt;. Rust is a systems language without garbage collections that guarantees memory safety. Through a real type system and many abstractions it feels like a high-level language but can still be low-level enough for OS development. The &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;set-up-rust&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; describes the Rust setup.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;hardware_lookup&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;In the x86 architecture, the page tables are &lt;em&gt;hardware walked&lt;&#x2f;em&gt;, so the CPU will look at the table on its own when it needs a translation. Other architectures, for example MIPS, just throw an exception and let the OS translate the virtual address.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;virtual_physical_translation_source&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;Image source: &lt;a href=&quot;https:&#x2f;&#x2f;commons.wikimedia.org&#x2f;wiki&#x2f;File:X86_Paging_64bit.svg&quot;&gt;Wikipedia&lt;&#x2f;a&gt;, with modified font size, page table naming, and removed sign extended bits. The modified file is licensed under the Creative Commons Attribution-Share Alike 3.0 Unported license.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;page_table_alignment&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;3&lt;&#x2f;sup&gt;
&lt;p&gt;Page tables need to be page-aligned as the bits 0-11 are used for flags. By putting these tables at the beginning of &lt;code&gt;.bss&lt;&#x2f;code&gt;, the linker can just page align the whole section and we don&#x27;t have unused padding bytes in between.&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
            <item>
                <title>A minimal Multiboot Kernel</title>
                <pubDate>Tue, 18 Aug 2015 00:00:00 +0000</pubDate>
                <link>https://os.phil-opp.com/multiboot-kernel/</link>
                <guid>https://os.phil-opp.com/multiboot-kernel/</guid>
                <description>&lt;p&gt;This post explains how to create a minimal x86 operating system kernel using the Multiboot standard. In fact, it will just boot and print &lt;code&gt;OK&lt;&#x2f;code&gt; to the screen. In subsequent blog posts we will extend it using the &lt;a href=&quot;http:&#x2f;&#x2f;www.rust-lang.org&#x2f;&quot;&gt;Rust&lt;&#x2f;a&gt; programming language.&lt;&#x2f;p&gt;
&lt;p id=&quot;zola-continue-reading&quot;&gt;&lt;a name=&quot;continue-reading&quot;&gt;&lt;&#x2f;a&gt;&lt;&#x2f;p&gt;
&lt;p&gt;I tried to explain everything in detail and to keep the code as simple as possible. If you have any questions, suggestions or other issues, please leave a comment or &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&quot;&gt;create an issue&lt;&#x2f;a&gt; on Github. The source code is available in a &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;tree&#x2f;first_edition_post_1&#x2f;src&#x2f;arch&#x2f;x86_64&quot;&gt;repository&lt;&#x2f;a&gt;, too.&lt;&#x2f;p&gt;
&lt;p&gt;Note that this tutorial is written mainly for Linux. For some known problems on OS X see the comment section and &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;phil-opp&#x2f;blog_os&#x2f;issues&#x2f;55&quot;&gt;this issue&lt;&#x2f;a&gt;. If you want to use a virtual Linux machine, you can find instructions and a Vagrantfile in Ashley Willams&#x27;s &lt;a href=&quot;https:&#x2f;&#x2f;github.com&#x2f;ashleygwilliams&#x2f;x86-kernel&quot;&gt;x86-kernel repository&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;overview&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Overview&lt;&#x2f;h2&gt;
&lt;p&gt;When you turn on a computer, it loads the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;BIOS&quot;&gt;BIOS&lt;&#x2f;a&gt; from some special flash memory. The BIOS runs self test and initialization routines of the hardware, then it looks for bootable devices. If it finds one, the control is transferred to its &lt;em&gt;bootloader&lt;&#x2f;em&gt;, which is a small portion of executable code stored at the device&#x27;s beginning. The bootloader has to determine the location of the kernel image on the device and load it into memory. It also needs to switch the CPU to the so-called &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Protected_mode&quot;&gt;protected mode&lt;&#x2f;a&gt; because x86 CPUs start in the very limited &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Real_Mode&quot;&gt;real mode&lt;&#x2f;a&gt; by default (to be compatible to programs from 1978).&lt;&#x2f;p&gt;
&lt;p&gt;We won&#x27;t write a bootloader because that would be a complex project on its own (if you really want to do it, check out &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Rolling_Your_Own_Bootloader&quot;&gt;&lt;em&gt;Rolling Your Own Bootloader&lt;&#x2f;em&gt;&lt;&#x2f;a&gt;). Instead we will use one of the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Comparison_of_boot_loaders&quot;&gt;many well-tested bootloaders&lt;&#x2f;a&gt; out there to boot our kernel from a CD-ROM. But which one?&lt;&#x2f;p&gt;
&lt;h2 id=&quot;multiboot&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#multiboot&quot; aria-label=&quot;Anchor link for: multiboot&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Multiboot&lt;&#x2f;h2&gt;
&lt;p&gt;Fortunately there is a bootloader standard: the &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Multiboot_Specification&quot;&gt;Multiboot Specification&lt;&#x2f;a&gt;. Our kernel just needs to indicate that it supports Multiboot and every Multiboot-compliant bootloader can boot it. We will use the Multiboot 2 specification (&lt;a href=&quot;http:&#x2f;&#x2f;nongnu.askapache.com&#x2f;grub&#x2f;phcoder&#x2f;multiboot.pdf&quot;&gt;PDF&lt;&#x2f;a&gt;) together with the well-known &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;GRUB_2&quot;&gt;GRUB 2&lt;&#x2f;a&gt; bootloader.&lt;&#x2f;p&gt;
&lt;p&gt;To indicate our Multiboot 2 support to the bootloader, our kernel must start with a &lt;em&gt;Multiboot Header&lt;&#x2f;em&gt;, which has the following format:&lt;&#x2f;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Field         &lt;&#x2f;th&gt;&lt;th&gt;Type            &lt;&#x2f;th&gt;&lt;th&gt;Value&lt;&#x2f;th&gt;&lt;&#x2f;tr&gt;&lt;&#x2f;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;magic number  &lt;&#x2f;td&gt;&lt;td&gt;u32             &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0xE85250D6&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;architecture  &lt;&#x2f;td&gt;&lt;td&gt;u32             &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;0&lt;&#x2f;code&gt; for i386, &lt;code&gt;4&lt;&#x2f;code&gt; for MIPS&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;header length &lt;&#x2f;td&gt;&lt;td&gt;u32             &lt;&#x2f;td&gt;&lt;td&gt;total header size, including tags&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;checksum      &lt;&#x2f;td&gt;&lt;td&gt;u32             &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;-(magic + architecture + header_length)&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;tags          &lt;&#x2f;td&gt;&lt;td&gt;variable        &lt;&#x2f;td&gt;&lt;td&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;tr&gt;&lt;td&gt;end tag       &lt;&#x2f;td&gt;&lt;td&gt;(u16, u16, u32) &lt;&#x2f;td&gt;&lt;td&gt;&lt;code&gt;(0, 0, 8)&lt;&#x2f;code&gt;&lt;&#x2f;td&gt;&lt;&#x2f;tr&gt;
&lt;&#x2f;tbody&gt;&lt;&#x2f;table&gt;
&lt;p&gt;Converted to a x86 assembly file it looks like this (Intel syntax):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;section .multiboot_header
header_start:
    dd &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xe85250d6&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                ; magic number (multiboot 2)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dd &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;                         ; architecture 0 (protected mode i386)
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dd header_end - header_start&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt; ; header length
    ; checksum
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dd &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x100000000 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;- (&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xe85250d6 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;+ &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0 &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;+ (header_end - header_start))&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;

    ; insert optional multiboot tags here

    ; required end tag
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dw &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; type
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dw &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; flags
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dd &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;8&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;    ; size
&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;header_end:
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;If you don&#x27;t know x86 assembly, here is some quick guide:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the header will be written to a section named &lt;code&gt;.multiboot_header&lt;&#x2f;code&gt; (we need this later)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;header_start&lt;&#x2f;code&gt; and &lt;code&gt;header_end&lt;&#x2f;code&gt; are &lt;em&gt;labels&lt;&#x2f;em&gt; that mark a memory location, we use them to calculate the header length easily&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;&#x2f;code&gt; stands for &lt;code&gt;define double&lt;&#x2f;code&gt; (32bit) and &lt;code&gt;dw&lt;&#x2f;code&gt; stands for &lt;code&gt;define word&lt;&#x2f;code&gt; (16bit). They just output the specified 32bit&#x2f;16bit constant.&lt;&#x2f;li&gt;
&lt;li&gt;the additional &lt;code&gt;0x100000000&lt;&#x2f;code&gt; in the checksum calculation is a small hack&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#fn-checksum_hack&quot;&gt;1&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt; to avoid a compiler warning&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;We can already &lt;em&gt;assemble&lt;&#x2f;em&gt; this file (which I called &lt;code&gt;multiboot_header.asm&lt;&#x2f;code&gt;) using &lt;code&gt;nasm&lt;&#x2f;code&gt;. It produces a flat binary by default, so the resulting file just contains our 24 bytes (in little endian if you work on a x86 machine):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; nasm multiboot_header.asm
&amp;gt; hexdump -x multiboot_header
0000000    50d6    e852    0000    0000    0018    0000    af12    17ad
0000010    0000    0000    0008    0000
0000018
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;the-boot-code&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#the-boot-code&quot; aria-label=&quot;Anchor link for: the-boot-code&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
The Boot Code&lt;&#x2f;h2&gt;
&lt;p&gt;To boot our kernel, we must add some code that the bootloader can call. Let&#x27;s create a file named &lt;code&gt;boot.asm&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;global start

section .text
bits 32
start:&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;
    ; print `OK` to screen
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;mov &lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;dword [&lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0xb8000&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;], &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b4cea8;&quot;&gt;0x2f4b2f4f
    &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;hlt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;There are some new commands:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;global&lt;&#x2f;code&gt; exports a label (makes it public). As &lt;code&gt;start&lt;&#x2f;code&gt; will be the entry point of our kernel, it needs to be public.&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;code&gt;.text&lt;&#x2f;code&gt; section is the default section for executable code&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;bits 32&lt;&#x2f;code&gt; specifies that the following lines are 32-bit instructions. It&#x27;s needed because the CPU is still in &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Protected_mode&quot;&gt;Protected mode&lt;&#x2f;a&gt; when GRUB starts our kernel. When we switch to &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Long_mode&quot;&gt;Long mode&lt;&#x2f;a&gt; in the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; we can use &lt;code&gt;bits 64&lt;&#x2f;code&gt; (64-bit instructions).&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;code&gt;mov dword&lt;&#x2f;code&gt; instruction moves the 32bit constant &lt;code&gt;0x2f4b2f4f&lt;&#x2f;code&gt; to the memory at address &lt;code&gt;b8000&lt;&#x2f;code&gt; (it prints &lt;code&gt;OK&lt;&#x2f;code&gt; to the screen, an explanation follows in the next posts)&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;hlt&lt;&#x2f;code&gt; is the halt instruction and causes the CPU to stop&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Through assembling, viewing and disassembling we can see the CPU &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Opcode&quot;&gt;Opcodes&lt;&#x2f;a&gt; in action:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; nasm boot.asm
&amp;gt; hexdump -x boot
0000000    05c7    8000    000b    2f4b    2f4f    00f4
000000b
&amp;gt; ndisasm -b 32 boot
00000000  C70500800B004B2F  mov dword [dword 0xb8000],0x2f4b2f4f
         -4F2F
0000000A  F4                hlt
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;&lt;h2 id=&quot;building-the-executable&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#building-the-executable&quot; aria-label=&quot;Anchor link for: building-the-executable&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Building the Executable&lt;&#x2f;h2&gt;
&lt;p&gt;To boot our executable later through GRUB, it should be an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Executable_and_Linkable_Format&quot;&gt;ELF&lt;&#x2f;a&gt; executable. So we want &lt;code&gt;nasm&lt;&#x2f;code&gt; to create ELF &lt;a href=&quot;http:&#x2f;&#x2f;wiki.osdev.org&#x2f;Object_Files&quot;&gt;object files&lt;&#x2f;a&gt; instead of plain binaries. To do that, we simply pass the &lt;code&gt;â€‘fÂ elf64&lt;&#x2f;code&gt; argument to it.&lt;&#x2f;p&gt;
&lt;p&gt;To create the ELF &lt;em&gt;executable&lt;&#x2f;em&gt;, we need to &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Linker_(computing)&quot;&gt;link&lt;&#x2f;a&gt; the object files together. We use a custom &lt;a href=&quot;https:&#x2f;&#x2f;sourceware.org&#x2f;binutils&#x2f;docs&#x2f;ld&#x2f;Scripts.html&quot;&gt;linker script&lt;&#x2f;a&gt; named &lt;code&gt;linker.ld&lt;&#x2f;code&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#569cd6;&quot;&gt;ENTRY&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;(start)

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;SECTIONS&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; {
    . = &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;1M&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;;

    .boot :
    {
        &lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;&#x2f;* ensure that the multiboot header is at the beginning *&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
        *(.multiboot_header)
    }

    .text :
    {
        *(.text)
    }
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Let&#x27;s translate it:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start&lt;&#x2f;code&gt; is the entry point, the bootloader will jump to it after loading the kernel&lt;&#x2f;li&gt;
&lt;li&gt;&lt;code&gt;. = 1M;&lt;&#x2f;code&gt; sets the load address of the first section to 1 MiB, which is a conventional place to load a kernel&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#Linker 1M&quot;&gt;2&lt;&#x2f;a&gt;&lt;&#x2f;sup&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the executable will have two sections: &lt;code&gt;.boot&lt;&#x2f;code&gt; at the beginning and &lt;code&gt;.text&lt;&#x2f;code&gt; afterwards&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;code&gt;.text&lt;&#x2f;code&gt; output section contains all input sections named &lt;code&gt;.text&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;Sections named &lt;code&gt;.multiboot_header&lt;&#x2f;code&gt; are added to the first output section (&lt;code&gt;.boot&lt;&#x2f;code&gt;) to ensure they are at the beginning of the executable. This is necessary because GRUB expects to find the Multiboot header very early in the file.&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;So let&#x27;s create the ELF object files and link them using our new linker script:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; nasm -f elf64 multiboot_header.asm
&amp;gt; nasm -f elf64 boot.asm
&amp;gt; ld -n -o kernel.bin -T linker.ld multiboot_header.o boot.o
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;It&#x27;s important to pass the &lt;code&gt;-n&lt;&#x2f;code&gt; (or &lt;code&gt;--nmagic&lt;&#x2f;code&gt;) flag to the linker, which disables the automatic section alignment in the executable. Otherwise the linker may page align the &lt;code&gt;.boot&lt;&#x2f;code&gt; section in the executable file. If that happens, GRUB isn&#x27;t able to find the Multiboot header because it isn&#x27;t at the beginning anymore.&lt;&#x2f;p&gt;
&lt;p&gt;We can use &lt;code&gt;objdump&lt;&#x2f;code&gt; to print the sections of the generated executable and verify that the &lt;code&gt;.boot&lt;&#x2f;code&gt; section has a low file offset:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; objdump -h kernel.bin
kernel.bin:     file format elf64-x86-64

Sections:
Idx Name      Size      VMA               LMA               File off  Algn
  0 .boot     00000018  0000000000100000  0000000000100000  00000080  2**0
              CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text     0000000b  0000000000100020  0000000000100020  000000a0  2**4
              CONTENTS, ALLOC, LOAD, READONLY, CODE
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;&#x2f;em&gt;: The &lt;code&gt;ld&lt;&#x2f;code&gt; and &lt;code&gt;objdump&lt;&#x2f;code&gt; commands are platform specific. If you&#x27;re &lt;em&gt;not&lt;&#x2f;em&gt; working on x86_64 architecture, you will need to &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cross-compile-binutils&#x2f;&quot;&gt;cross compile binutils&lt;&#x2f;a&gt;. Then use &lt;code&gt;x86_64â€‘elfâ€‘ld&lt;&#x2f;code&gt; and &lt;code&gt;x86_64â€‘elfâ€‘objdump&lt;&#x2f;code&gt; instead of &lt;code&gt;ld&lt;&#x2f;code&gt; and &lt;code&gt;objdump&lt;&#x2f;code&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;creating-the-iso&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#creating-the-iso&quot; aria-label=&quot;Anchor link for: creating-the-iso&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Creating the ISO&lt;&#x2f;h2&gt;
&lt;p&gt;All PC BIOSes know how to boot from a CD-ROM, so we want to create a bootable CD-ROM image, containing our kernel and the GRUB bootloader&#x27;s files, in a single file called an &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;ISO_image&quot;&gt;ISO&lt;&#x2f;a&gt;. Make the following directory structure and copy the &lt;code&gt;kernel.bin&lt;&#x2f;code&gt; to the right place:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;isofiles
â””â”€â”€ boot
    â”œâ”€â”€ grub
    â”‚   â””â”€â”€ grub.cfg
    â””â”€â”€ kernel.bin

&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The &lt;code&gt;grub.cfg&lt;&#x2f;code&gt; specifies the file name of our kernel and its Multiboot 2 compliance. It looks like this:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;set timeout=0
set default=0

menuentry &amp;quot;my os&amp;quot; {
    multiboot2 &#x2f;boot&#x2f;kernel.bin
    boot
}
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Now we can create a bootable image using the command:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;grub-mkrescue -o os.iso isofiles
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;&#x2f;em&gt;: &lt;code&gt;grub-mkrescue&lt;&#x2f;code&gt; causes problems on some platforms. If it does not work for you, try the following steps:&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;try to run it with &lt;code&gt;--verbose&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;make sure &lt;code&gt;xorriso&lt;&#x2f;code&gt; is installed (&lt;code&gt;xorriso&lt;&#x2f;code&gt; or &lt;code&gt;libisoburn&lt;&#x2f;code&gt; package)&lt;&#x2f;li&gt;
&lt;li&gt;If you&#x27;re using an EFI-system, &lt;code&gt;grub-mkrescue&lt;&#x2f;code&gt; tries to create an EFI image by default. You can either pass &lt;code&gt;-d &#x2f;usr&#x2f;lib&#x2f;grub&#x2f;i386-pc&lt;&#x2f;code&gt; to avoid EFI or install the &lt;code&gt;mtools&lt;&#x2f;code&gt; package to get a working EFI image&lt;&#x2f;li&gt;
&lt;li&gt;on some system the command is named &lt;code&gt;grub2-mkrescue&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;h2 id=&quot;booting&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#booting&quot; aria-label=&quot;Anchor link for: booting&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Booting&lt;&#x2f;h2&gt;
&lt;p&gt;Now it&#x27;s time to boot our OS. We will use &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;QEMU&quot;&gt;QEMU&lt;&#x2f;a&gt;:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qemu-system-x86_64 -cdrom os.iso
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;multiboot-kernel&#x2f;qemu-ok.png&quot; alt=&quot;qemu output&quot; &#x2f;&gt;&lt;&#x2f;p&gt;
&lt;p&gt;Notice the green &lt;code&gt;OK&lt;&#x2f;code&gt; in the upper left corner. If it does not work for you, take a look at the comment section.&lt;&#x2f;p&gt;
&lt;p&gt;Let&#x27;s summarize what happens:&lt;&#x2f;p&gt;
&lt;ol&gt;
&lt;li&gt;the BIOS loads the bootloader (GRUB) from the virtual CD-ROM (the ISO)&lt;&#x2f;li&gt;
&lt;li&gt;the bootloader reads the kernel executable and finds the Multiboot header&lt;&#x2f;li&gt;
&lt;li&gt;it copies the &lt;code&gt;.boot&lt;&#x2f;code&gt; and &lt;code&gt;.text&lt;&#x2f;code&gt; sections to memory (to addresses &lt;code&gt;0x100000&lt;&#x2f;code&gt; and &lt;code&gt;0x100020&lt;&#x2f;code&gt;)&lt;&#x2f;li&gt;
&lt;li&gt;it jumps to the entry point (&lt;code&gt;0x100020&lt;&#x2f;code&gt;, you can obtain it through &lt;code&gt;objdump -f&lt;&#x2f;code&gt;)&lt;&#x2f;li&gt;
&lt;li&gt;our kernel prints the green &lt;code&gt;OK&lt;&#x2f;code&gt; and stops the CPU&lt;&#x2f;li&gt;
&lt;&#x2f;ol&gt;
&lt;p&gt;You can test it on real hardware, too. Just burn the ISO to a disk or USB stick and boot from it.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;build-automation&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#build-automation&quot; aria-label=&quot;Anchor link for: build-automation&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Build Automation&lt;&#x2f;h2&gt;
&lt;p&gt;Right now we need to execute 4 commands in the right order every time we change a file. That&#x27;s bad. So let&#x27;s automate the build using a &lt;code&gt;Makefile&lt;&#x2f;code&gt;. But first we should create some clean directory structure for our source files to separate the architecture specific files:&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;â€¦
â”œâ”€â”€ Makefile
â””â”€â”€ src
    â””â”€â”€ arch
        â””â”€â”€ x86_64
            â”œâ”€â”€ multiboot_header.asm
            â”œâ”€â”€ boot.asm
            â”œâ”€â”€ linker.ld
            â””â”€â”€ grub.cfg
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;The Makefile looks like this (indented with tabs instead of spaces):&lt;&#x2f;p&gt;
&lt;pre style=&quot;background-color:#1e1e1e;&quot;&gt;
&lt;span style=&quot;color:#dcdcdc;&quot;&gt;arch ?= &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;x86_64&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
kernel := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;build&#x2f;kernel-&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.bin&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
iso := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;build&#x2f;os-&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.iso&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

linker_script := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;linker.ld&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
grub_cfg := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;grub.cfg&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
assembly_source_files := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;wildcard &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;*&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
assembly_object_files := &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;patsubst &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm, \
	build&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.o, &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_source_files&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;))&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

.PHONY: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;all clean run iso&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

all: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

clean:
	&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;@rm -r build&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

run: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;iso&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;qemu-system-x86_64 -cdrom &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;iso&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;iso: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;iso&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;iso&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;grub_cfg&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;mkdir -p build&#x2f;isofiles&#x2f;boot&#x2f;grub
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; build&#x2f;isofiles&#x2f;boot&#x2f;kernel.bin
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;cp &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;grub_cfg&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; build&#x2f;isofiles&#x2f;boot&#x2f;grub
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;grub-mkrescue -o &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;iso&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; build&#x2f;isofiles &lt;&#x2f;span&gt;&lt;span style=&quot;color:#b5cea8;&quot;&gt;2&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&amp;gt; &#x2f;dev&#x2f;null
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;rm -r build&#x2f;isofiles

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;ld -n -T &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;linker_script&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt; -o &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;kernel&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;) $(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;assembly_object_files&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)

&lt;&#x2f;span&gt;&lt;span style=&quot;color:#608b4e;&quot;&gt;# compile assembly files&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
build&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;&#x2f;%.o: &lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;src&#x2f;arch&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;arch&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#569cd6;&quot;&gt;)&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;&#x2f;&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#dcdcdc;&quot;&gt;%&lt;&#x2f;span&gt;&lt;span style=&quot;background-color:#282828;color:#d69d85;&quot;&gt;.asm&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;
	&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;mkdir -p &lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;$(&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;shell dirname $@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#569cd6;&quot;&gt;)
	@&lt;&#x2f;span&gt;&lt;span style=&quot;color:#dcdcdc;&quot;&gt;nasm -felf64 $&amp;lt; -o $@
&lt;&#x2f;span&gt;&lt;&#x2f;pre&gt;
&lt;p&gt;Some comments (see the [Makefile tutorial] if you don&#x27;t know &lt;code&gt;make&lt;&#x2f;code&gt;):&lt;&#x2f;p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;$(wildcard src&#x2f;arch&#x2f;$(arch)&#x2f;*.asm)&lt;&#x2f;code&gt; chooses all assembly files in the src&#x2f;arch&#x2f;$(arch)` directory, so you don&#x27;t have to update the Makefile when you add a file&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;code&gt;patsubst&lt;&#x2f;code&gt; operation for &lt;code&gt;assembly_object_files&lt;&#x2f;code&gt; just translates &lt;code&gt;src&#x2f;arch&#x2f;$(arch)&#x2f;XYZ.asm&lt;&#x2f;code&gt; to &lt;code&gt;build&#x2f;arch&#x2f;$(arch)&#x2f;XYZ.o&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;li&gt;the &lt;code&gt;$&amp;lt;&lt;&#x2f;code&gt; and &lt;code&gt;$@&lt;&#x2f;code&gt; in the assembly target are &lt;a href=&quot;https:&#x2f;&#x2f;www.gnu.org&#x2f;software&#x2f;make&#x2f;manual&#x2f;html_node&#x2f;Automatic-Variables.html&quot;&gt;automatic variables&lt;&#x2f;a&gt;&lt;&#x2f;li&gt;
&lt;li&gt;if you&#x27;re using &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;cross-compile-binutils&#x2f;&quot;&gt;cross-compiled binutils&lt;&#x2f;a&gt; just replace &lt;code&gt;ld&lt;&#x2f;code&gt; with &lt;code&gt;x86_64â€‘elfâ€‘ld&lt;&#x2f;code&gt;&lt;&#x2f;li&gt;
&lt;&#x2f;ul&gt;
&lt;p&gt;Now we can invoke &lt;code&gt;make&lt;&#x2f;code&gt; and all updated assembly files are compiled and linked. The &lt;code&gt;make iso&lt;&#x2f;code&gt; command also creates the ISO image and &lt;code&gt;make run&lt;&#x2f;code&gt; will additionally start QEMU.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;what-s-next&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-s-next&quot; aria-label=&quot;Anchor link for: what-s-next&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
What&#x27;s next?&lt;&#x2f;h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https:&#x2f;&#x2f;os.phil-opp.com&#x2f;entering-longmode&#x2f;&quot;&gt;next post&lt;&#x2f;a&gt; we will create a page table and do some CPU configuration to switch to the 64-bit &lt;a href=&quot;https:&#x2f;&#x2f;en.wikipedia.org&#x2f;wiki&#x2f;Long_mode&quot;&gt;long mode&lt;&#x2f;a&gt;.&lt;&#x2f;p&gt;
&lt;h2 id=&quot;footnotes&quot;&gt;&lt;a class=&quot;zola-anchor&quot; href=&quot;#footnotes&quot; aria-label=&quot;Anchor link for: footnotes&quot;&gt;ðŸ”—&lt;&#x2f;a&gt;
Footnotes&lt;&#x2f;h2&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;fn-checksum_hack&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2f;sup&gt;
&lt;p&gt;The formula from the table, &lt;code&gt;-(magic + architecture + header_length)&lt;&#x2f;code&gt;, creates a negative value that doesn&#x27;t fit into 32bit. By subtracting from &lt;code&gt;0x100000000&lt;&#x2f;code&gt; (= 2^(32)) instead, we keep the value positive without changing its truncated value. Without the additional sign bit(s) the result fits into 32bit and the compiler is happy :).&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;Linker 1M&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2f;sup&gt;
&lt;p&gt;We don&#x27;t want to load the kernel to e.g. &lt;code&gt;0x0&lt;&#x2f;code&gt; because there are many special memory areas below the 1MB mark (for example the so-called VGA buffer at &lt;code&gt;0xb8000&lt;&#x2f;code&gt;, that we use to print &lt;code&gt;OK&lt;&#x2f;code&gt; to the screen).&lt;&#x2f;p&gt;
&lt;&#x2f;div&gt;
</description>
            </item>
        
    </channel>
</rss>
