<!doctype html><html lang=en><head><meta charset=UTF-8><meta content=yes name=apple-mobile-web-app-capable><meta content="width=device-width,initial-scale=1" name=viewport><meta content="This blog series creates a small operating system in the Rust programming language. Each post is a small tutorial and includes all needed code." name=description><meta content="Philipp Oppermann" name=author><link href=/css/edition-1/poole.css rel=stylesheet><link href=/css/edition-1/main.css rel=stylesheet><link href=/css/edition-1/isso.css rel=stylesheet><script async src=/js/edition-1/main.js></script><title>Returning from Exceptions | Writing an OS in Rust (First Edition)</title><body><div class="container content"><header class=masthead><h2 class=masthead-title><a href=/edition-1 title=Home>Writing an OS in Rust (First Edition)</a></h2><p><small>Philipp¬†Oppermann's¬†blog</small></header><main><h1>Returning from Exceptions</h1><time class=post-date datetime=2016-09-21> Sep 21, 2016 (updated on Nov 01, 2016) </time><aside id=toc-aside><h2>Table of Contents</h2><ol><li><a href=#introduction>Introduction</a><li><a href=#the-breakpoint-exception>The Breakpoint Exception</a> <ol><li><a href=#catching-breakpoints>Catching Breakpoints</a></ol><li><a href=#returning-from-exceptions>Returning from Exceptions</a> <ol><li><a href=#the-iretq-instruction>The iretq Instruction</a><li><a href=#implementation>Implementation</a><li><a href=#testing>Testing</a><li><a href=#debugging>Debugging</a></ol><li><a href=#calling-conventions>Calling Conventions</a> <ol><li><a href=#preserved-and-scratch-registers>Preserved and Scratch Registers</a><li><a href=#the-exception-calling-convention>The Exception Calling Convention</a><li><a href=#a-naked-wrapper-function>A naked wrapper function</a><li><a href=#fixing-our-handler-macro>Fixing our Handler Macro</a><li><a href=#testing-it-again>Testing it again</a></ol><li><a href=#multimedia-registers>Multimedia Registers</a> <ol><li><a href=#saving-and-restoring-multimedia-registers>Saving and Restoring Multimedia Registers</a><li><a href=#disabling-multimedia-extensions>Disabling Multimedia Extensions</a><li><a href=#target-specifications>Target Specifications</a><li><a href=#cross-compilation>Cross compilation</a><li><a href=#sse-register-return>SSE Register Return</a></ol><li><a href=#the-red-zone>The Red Zone</a> <ol><li><a href=#adjusting-our-exception-handler>Adjusting our Exception Handler?</a><li><a href=#disabling-the-red-zone>Disabling the Red Zone</a></ol><li><a href=#exceptions-with-error-codes>Exceptions with Error Codes</a> <ol><li><a href=#testing-1>Testing</a></ol><li><a href=#what-s-next>What‚Äôs next?</a></ol></aside><div class=warning><b>No longer updated!</b> You are viewing the a post of the first edition of ‚ÄúWriting an OS in Rust‚Äù, which is no longer updated. You can find the second edition <a href=https://os.phil-opp.com/edition-2/>here</a>.</div><p>In this post, we learn how to return from exceptions correctly. In the course of this, we will explore the <code>iretq</code> instruction, the C calling convention, multimedia registers, and the red zone.</p><span id=continue-reading></span><p>As always, the complete source code is on <a href=https://github.com/phil-opp/blog_os/tree/returning_from_exceptions>GitHub</a>. Please file <a href=https://github.com/phil-opp/blog_os/issues>issues</a> for any problems, questions, or improvement suggestions. There is also a <a href=https://gitter.im/phil-opp/blog_os>gitter chat</a> and a comment section at the end of this page.<blockquote><p><strong>Note</strong>: This post describes how to handle exceptions using naked functions (see <a href=https://os.phil-opp.com/edition-1/extra/naked-exceptions/>‚ÄúHandling Exceptions with Naked Functions‚Äù</a> for an overview). Our new way of handling exceptions can be found in the <a href=https://os.phil-opp.com/handling-exceptions/>‚ÄúHandling Exceptions‚Äù</a> post.</blockquote><h2 id=introduction><a aria-label="Anchor link for: introduction" class=zola-anchor href=#introduction>üîó</a>Introduction</h2><p>Most exceptions are fatal and can‚Äôt be resolved. For example, we can‚Äôt return from a divide-by-zero exception in a reasonable way. However, there are some exceptions that we can resolve:<p>Imagine a system that uses <a href=https://en.wikipedia.org/wiki/Memory-mapped_file>memory mapped files</a>: We map a file into the virtual address space without loading it into memory. Whenever we access a part of the file for the first time, a page fault occurs. However, this page fault is not fatal. We can resolve it by loading the corresponding page from disk into memory and setting the <code>present</code> flag in the page table. Then we can return from the page fault handler and restart the failed instruction, which now successfully accesses the file data.<p>Memory mapped files are completely out of scope for us right now (we have neither a file concept nor a hard disk driver). So we need an exception that we can resolve easily so that we can return from it in a reasonable way. Fortunately, there is an exception that needs no resolution at all: the breakpoint exception.<h2 id=the-breakpoint-exception><a aria-label="Anchor link for: the-breakpoint-exception" class=zola-anchor href=#the-breakpoint-exception>üîó</a>The Breakpoint Exception</h2><p>The breakpoint exception is the perfect exception to test our upcoming return-from-exception logic. Its only purpose is to temporary pause a program when the breakpoint instruction <code>int3</code> is executed.<p>The breakpoint exception is commonly used in debuggers: When the user sets a breakpoint, the debugger overwrites the corresponding instruction with the <code>int3</code> instruction so that the CPU throws the breakpoint exception when it reaches that line. When the user wants to continue the program, the debugger replaces the <code>int3</code> instruction with the original instruction again and continues the program. For more details, see the <a href=https://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints>How debuggers work</a> series.<p>For our use case, we don‚Äôt need to overwrite any instructions (it wouldn‚Äôt even be possible since we <a href=https://os.phil-opp.com/remap-the-kernel/#using-the-correct-flags>set the page table flags</a> to read-only). Instead, we just want to print a message when the breakpoint instruction is executed and then continue the program.<h3 id=catching-breakpoints><a aria-label="Anchor link for: catching-breakpoints" class=zola-anchor href=#catching-breakpoints>üîó</a>Catching Breakpoints</h3><p>Let‚Äôs start by defining a handler function for the breakpoint exception:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>breakpoint_handler(stack_frame: </span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame) -> </span><span style=color:#569cd6;>!
</span><span>{
</span><span>    </span><span style=color:#569cd6;>let</span><span> stack_frame = </span><span style=color:#569cd6;>unsafe </span><span>{ </span><span style=color:#569cd6;>&</span><span>*stack_frame };
</span><span>    println!(</span><span style=color:#d69d85;>"</span><span style=color:#e3bbab;>\n</span><span style=color:#d69d85;>EXCEPTION: BREAKPOINT at </span><span style=color:#b4cea8;>{:#x}</span><span style=color:#e3bbab;>\n</span><span style=color:#b4cea8;>{:#?}</span><span style=color:#d69d85;>"</span><span>,
</span><span>        stack_frame.instruction_pointer, stack_frame);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>We print an error message and also output the instruction pointer and the rest of the stack frame. Note that this function does <em>not</em> return yet, since our <code>handler!</code> macro still requires a diverging function.<p>We need to register our new handler function in the interrupt descriptor table (IDT):<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>lazy_static! {
</span><span>    </span><span style=color:#569cd6;>static ref </span><span style=color:#b4cea8;>IDT</span><span>: idt::Idt = {
</span><span>        </span><span style=color:#569cd6;>let mut</span><span> idt = idt::Idt::new();
</span><span>
</span><span>        idt.set_handler(</span><span style=color:#b5cea8;>0</span><span>, handler!(divide_by_zero_handler));
</span><span>        idt.set_handler(</span><span style=color:#b5cea8;>3</span><span>, handler!(breakpoint_handler)); </span><span style=color:#608b4e;>// new
</span><span>        idt.set_handler(</span><span style=color:#b5cea8;>6</span><span>, handler!(invalid_opcode_handler));
</span><span>        idt.set_handler(</span><span style=color:#b5cea8;>14</span><span>, handler_with_error_code!(page_fault_handler));
</span><span>
</span><span>        idt
</span><span>    };
</span><span>}
</span></code></pre><p>We set the IDT entry with number 3 since it‚Äôs the vector number of the breakpoint exception.<h4 id=testing-it><a aria-label="Anchor link for: testing-it" class=zola-anchor href=#testing-it>üîó</a>Testing it</h4><p>In order to test it, we insert an <code>int3</code> instruction in our <code>rust_main</code>:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/lib.rs
</span><span style=color:#569cd6;>...
</span><span>#[macro_use] </span><span style=color:#608b4e;>// needed for the `int!` macro
</span><span style=color:#569cd6;>extern crate</span><span> x86_64;
</span><span style=color:#569cd6;>...
</span><span>
</span><span>#[no_mangle]
</span><span style=color:#569cd6;>pub extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>rust_main(...) {
</span><span>    </span><span style=color:#569cd6;>...
</span><span>    interrupts::init();
</span><span>
</span><span>    </span><span style=color:#608b4e;>// trigger a breakpoint exception
</span><span>    </span><span style=color:#569cd6;>unsafe </span><span>{ int!(</span><span style=color:#b5cea8;>3</span><span>) };
</span><span>
</span><span>    println!(</span><span style=color:#d69d85;>"It did not crash!"</span><span>);
</span><span>    </span><span style=color:#569cd6;>loop </span><span>{}
</span><span>}
</span></code></pre><p>When we execute <code>make run</code>, we see the following:<p><img alt="QEMU showing EXCEPTION: BREAKPOINT at 0x110970 and a dump of the exception stack frame" src=qemu-breakpoint-handler.png><p>It works! Now we ‚Äújust‚Äù need to return from the breakpoint handler somehow so that we see the <code>It did not crash</code> message again.<h2 id=returning-from-exceptions><a aria-label="Anchor link for: returning-from-exceptions" class=zola-anchor href=#returning-from-exceptions>üîó</a>Returning from Exceptions</h2><p>So how do we return from exceptions? To make it easier, we look at a normal function return first:<p><img alt="function stack frame" src=function-stack-frame.svg><p>When calling a function, the <code>call</code> instruction pushes the return address on the stack. When the called function is finished, it can return to the parent function through the <code>ret</code> instruction, which pops the return address from the stack and then jumps to it.<p>The exception stack frame, in contrast, looks a bit different:<p><img alt="exception stack frame" src=exception-stack-frame.svg><p>Instead of pushing a return address, the CPU pushes the stack and instruction pointers (with their segment descriptors), the RFLAGS register, and an optional error code. It also aligns the stack pointer to a 16 byte boundary before pushing values.<p>So we can‚Äôt use a normal <code>ret</code> instruction, since it expects a different stack frame layout. Instead, there is a special instruction for returning from exceptions: <code>iretq</code>.<h3 id=the-iretq-instruction><a aria-label="Anchor link for: the-iretq-instruction" class=zola-anchor href=#the-iretq-instruction>üîó</a>The <code>iretq</code> Instruction</h3><p>The <code>iretq</code> instruction is the one and only way to return from exceptions and is specifically designed for this purpose. The AMD64 instruction manual (<a href=https://www.amd.com/system/files/TechDocs/24594.pdf>PDF</a>) even demands that <code>iretq</code> ‚Äú<em>must</em> be used to terminate the exception or interrupt handler associated with the exception‚Äù.<p>IRETQ restores <code>rip</code>, <code>cs</code>, <code>rflags</code>, <code>rsp</code>, and <code>ss</code> from the values saved on the stack and thus continues the interrupted program. The instruction does not handle the optional error code, so it must be popped from the stack before.<p>We see that <code>iretq</code> treats the stored instruction pointer as return address. For most exceptions, the stored <code>rip</code> points to the instruction that caused the fault. So by executing <code>iretq</code>, we restart the failing instruction. This makes sense because we should have resolved the exception when returning from it, so the instruction should no longer fail (e.g. the accessed part of the memory mapped file is now present in memory).<p>The situation is a bit different for the breakpoint exception, since it needs no resolution. Restarting the <code>int3</code> instruction wouldn‚Äôt make sense, since it would cause a new breakpoint exception and we would enter an endless loop. For this reason the hardware designers decided that the stored <code>rip</code> should point to the next instruction after the <code>int3</code> instruction.<p>Let‚Äôs check this for our breakpoint handler. Remember, the handler printed the following message (see the image above):<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>EXCEPTION: BREAKPOINT at 0x110970
</span></code></pre><p>So let‚Äôs disassemble the instruction at <code>0x110970</code> and its predecessor:<pre class=language-bash data-lang=bash style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-bash data-lang=bash><span>> objdump -d build/kernel-x86_64.bin </span><span style=color:#569cd6;>| </span><span>grep -B1 </span><span style=color:#d69d85;>"110970:"
</span><span>11096f:	cc                   	int3
</span><span>110970:	48 c7 01 2a 00 00 00 	movq   $0x2a,(%rcx)
</span></code></pre><p>We see that <code>0x110970</code> indeed points to the next instruction after <code>int3</code>. So we can simply jump to the stored instruction pointer when we want to return from the breakpoint exception.<h3 id=implementation><a aria-label="Anchor link for: implementation" class=zola-anchor href=#implementation>üîó</a>Implementation</h3><p>Let‚Äôs update our <code>handler!</code> macro to support non-diverging exception handlers:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! handler {
</span><span>    ($name: ident) </span><span style=color:#569cd6;>=> </span><span>{{
</span><span>        #[naked]
</span><span>        </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>wrapper() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>            </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>                asm!(</span><span style=color:#d69d85;>"mov rdi, rsp
</span><span style=color:#d69d85;>                      sub rsp, 8 // align the stack pointer
</span><span style=color:#d69d85;>                      call $0"
</span><span>                      :: </span><span style=color:#d69d85;>"i"</span><span>($name </span><span style=color:#569cd6;>as extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn</span><span>(
</span><span>                          </span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame)) </span><span style=color:#608b4e;>// no longer diverging
</span><span>                      : </span><span style=color:#d69d85;>"rdi" </span><span>: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>
</span><span>                </span><span style=color:#608b4e;>// new
</span><span>                asm!(</span><span style=color:#d69d85;>"add rsp, 8 // undo stack pointer alignment
</span><span style=color:#d69d85;>                      iretq"
</span><span>                      :::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>                ::core::intrinsics::unreachable();
</span><span>            }
</span><span>        }
</span><span>        wrapper
</span><span>    }}
</span><span>}
</span></code></pre><p>When an exception handler returns from the <code>call</code> instruction, we use the <code>iretq</code> instruction to continue the interrupted program. Note that we need to undo the stack pointer alignment before, so that <code>rsp</code> points to the end of the exception stack frame again.<p>We‚Äôve changed the handler function type, so we need to adjust our existing exception handlers:<pre class=language-diff data-lang=diff style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-diff data-lang=diff><span>// in src/interrupts/mod.rs
</span><span>
</span><span>extern "C" fn divide_by_zero_handler(
</span><span>-   stack_frame: &ExceptionStackFrame) -> ! {...}
</span><span>+   stack_frame: &ExceptionStackFrame) {...}
</span><span>
</span><span>extern "C" fn invalid_opcode_handler(
</span><span>-   stack_frame: &ExceptionStackFrame) -> ! {...}
</span><span>+   stack_frame: &ExceptionStackFrame) {...}
</span><span>
</span><span>extern "C" fn breakpoint_handler(
</span><span>-   stack_frame: &ExceptionStackFrame) -> ! {
</span><span>+   stack_frame: &ExceptionStackFrame) {
</span><span>    println!(...);
</span><span>-   loop {}
</span><span>}
</span></code></pre><p>Note that we also removed the <code>loop {}</code> at the end of our <code>breakpoint_handler</code> so that it no longer diverges. The <code>divide_by_zero_handler</code> and the <code>invalid_opcode_handler</code> still diverge (albeit the new function type would allow a return).<h3 id=testing><a aria-label="Anchor link for: testing" class=zola-anchor href=#testing>üîó</a>Testing</h3><p>Let‚Äôs try our new <code>iretq</code> logic:<p><img alt="QEMU output with EXCEPTION BREAKPOINT and EXCEPTION PAGE FAULT but no It did not crash" src=qemu-breakpoint-return-page-fault.png><p>Instead of the expected <em>‚ÄúIt did not crash‚Äù</em> message after the breakpoint exception, we get a page fault. The strange thing is that our kernel tried to access address <code>0x1</code>, which should never happen. So it seems like we messed up something important.<h3 id=debugging><a aria-label="Anchor link for: debugging" class=zola-anchor href=#debugging>üîó</a>Debugging</h3><p>Let‚Äôs debug it using GDB. For that we execute <code>make debug</code> in one terminal (which starts QEMU with the <code>-s -S</code> flags) and then <code>make gdb</code> (which starts and connects GDB) in a second terminal. For more information about GDB debugging, check out our <a href=https://os.phil-opp.com/set-up-gdb/>Set Up GDB</a> guide.<p>First we want to check if our <code>iretq</code> was successful. Therefore we set a breakpoint on the <code>println!("It did not crash line!")</code> statement in <code>src/lib.rs</code>. Let‚Äôs assume that it‚Äôs on line 61:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>(gdb) break blog_os/src/lib.rs:61
</span><span>Breakpoint 1 at 0x110a95: file /home/.../blog_os/src/lib.rs, line 61.
</span></code></pre><p>This line is after the <code>int3</code> instruction, so we know that the <code>iretq</code> succeeded when the breakpoint is hit. To test this, we continue the execution:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>(gdb) continue
</span><span>Continuing.
</span><span>
</span><span>Breakpoint 1, blog_os::rust_main (multiboot_information_address=1539136)
</span><span>    at /home/.../blog_os/src/lib.rs:61
</span><span>61	    println!("It did not crash!");
</span><span>
</span></code></pre><p>It worked! So our kernel successfully returned from the <code>int3</code> instruction, which means that the <code>iretq</code> itself works.<p>However, when we <code>continue</code> the execution again, we get the page fault. So the exception occurs somewhere in the <code>println</code> logic. This means that it occurs in code generated by the compiler (and not e.g. in inline assembly). But the compiler should never access <code>0x1</code>, so how is this happening?<p>The answer is that we‚Äôve used the wrong <em>calling convention</em> for our exception handlers. Thus, we violate some compiler invariants so that the code that works fine without intermediate exceptions starts to violate memory safety when it‚Äôs executed after a breakpoint exception.<h2 id=calling-conventions><a aria-label="Anchor link for: calling-conventions" class=zola-anchor href=#calling-conventions>üîó</a>Calling Conventions</h2><p>Exceptions are quite similar to function calls: The CPU jumps to the first instruction of the (handler) function and executes the function. Afterwards, if the function is not diverging, the CPU jumps to the return address and continues the execution of the parent function.<p>However, there is a major difference between exceptions and function calls: A function call is invoked voluntary by a compiler inserted <code>call</code> instruction, while an exception might occur at <em>any</em> instruction. In order to understand the consequences of this difference, we need to examine function calls in more detail.<p><a href=https://en.wikipedia.org/wiki/Calling_convention>Calling conventions</a> specify the details of a function call. For example, they specify where function parameters are placed (e.g. in registers or on the stack) and how results are returned. On x86_64 Linux, the following rules apply for C functions (specified in the <a href=https://refspecs.linuxbase.org/elf/gabi41.pdf>System V ABI</a>):<ul><li>the first six integer arguments are passed in registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code><li>additional arguments are passed on the stack<li>results are returned in <code>rax</code> and <code>rdx</code></ul><p>Note that Rust does not follow the C ABI (in fact, <a href=https://github.com/rust-lang/rfcs/issues/600>there isn‚Äôt even a Rust ABI yet</a>). So these rules apply only to functions declared as <code>extern "C" fn</code>.<h3 id=preserved-and-scratch-registers><a aria-label="Anchor link for: preserved-and-scratch-registers" class=zola-anchor href=#preserved-and-scratch-registers>üîó</a>Preserved and Scratch Registers</h3><p>The calling convention divides the registers in two parts: <em>preserved</em> and <em>scratch</em> registers.<p>The values of the preserved register must remain unchanged across function calls. So a called function (the <em>‚Äúcallee‚Äù</em>) is only allowed to overwrite these registers if it restores their original values before returning. Therefore these registers are called <em>‚Äúcallee-saved‚Äù</em>. A common pattern is to save these registers to the stack at the function‚Äôs beginning and restore them just before returning.<p>In contrast, a called function is allowed to overwrite scratch registers without restrictions. If the caller wants to preserve the value of a scratch register across a function call, it needs to backup and restore it (e.g. by pushing it to the stack before the function call). So the scratch registers are <em>caller-saved</em>.<p>On x86_64, the C calling convention specifies the following preserved and scratch registers:<table><thead><tr><th>preserved registers<th>scratch registers<tbody><tr><td><code>rbp</code>, <code>rbx</code>, <code>rsp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code><td><code>rax</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code><tr><td><em>callee-saved</em><td><em>caller-saved</em></table><p>The compiler knows these rules, so it generates the code accordingly. For example, most functions begin with a <code>push rbp</code>, which backups <code>rbp</code> on the stack (because it‚Äôs a callee-saved register).<h3 id=the-exception-calling-convention><a aria-label="Anchor link for: the-exception-calling-convention" class=zola-anchor href=#the-exception-calling-convention>üîó</a>The Exception Calling Convention</h3><p>In contrast to function calls, exceptions can occur on <em>any</em> instruction. In most cases we don‚Äôt even know at compile time if the generated code will cause an exception. For example, the compiler can‚Äôt know if an instruction causes a stack overflow or an other page fault.<p>Since we don‚Äôt know when an exception occurs, we can‚Äôt backup any registers before. This means that we can‚Äôt use a calling convention that relies on caller-saved registers for our exception handlers. But we do so at the moment: Our exception handlers are declared as <code>extern "C" fn</code> and thus use the C calling convention.<p>So here is what happens:<ul><li><code>rust_main</code> is executing; it writes some memory address into <code>rax</code>.<li>The <code>int3</code> instruction causes a breakpoint exception.<li>Our <code>breakpoint_handler</code> prints to the screen and assumes that it can overwrite <code>rax</code> freely (since it‚Äôs a scratch register). Somehow the value <code>0</code> ends up in <code>rax</code>.<li>We return from the breakpoint exception using <code>iretq</code>.<li><code>rust_main</code> continues and accesses the memory address in <code>rax</code>.<li>The CPU tries to access address <code>0x1</code>, which causes a page fault.</ul><p>So our exception handler erroneously assumes that the scratch registers were saved by the caller. But the caller (<code>rust_main</code>) couldn‚Äôt save any registers since it didn‚Äôt know that an exception occurs. So nobody saves <code>rax</code> and the other scratch registers, which leads to the page fault.<p>The problem is that we use a calling convention with caller-saved registers for our exception handlers. Instead, we need a calling convention means that preserves <em>all registers</em>. In other words, all registers must be callee-saved:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"all-registers-callee-saved" </span><span style=color:#569cd6;>fn </span><span>exception_handler() {</span><span style=color:#569cd6;>...</span><span>}
</span></code></pre><p>Unfortunately, Rust does not support such a calling convention. It was <a href=https://github.com/rust-lang/rfcs/pull/1275>proposed once</a>, but did not get accepted for various reasons. The primary reason was that such calling conventions can be simulated by writing a naked wrapper function.<p>(Remember: <a href=https://github.com/rust-lang/rfcs/blob/master/text/1201-naked-fns.md>Naked functions</a> are functions without prologue and can contain only inline assembly. They were discussed in the <a href=https://os.phil-opp.com/better-exception-messages/#naked-functions>previous post</a>.)<h3 id=a-naked-wrapper-function><a aria-label="Anchor link for: a-naked-wrapper-function" class=zola-anchor href=#a-naked-wrapper-function>üîó</a>A naked wrapper function</h3><p>Such a naked wrapper function might look like this:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>#[naked]
</span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>calling_convention_wrapper() {
</span><span>    </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>        asm!(</span><span style=color:#d69d85;>"
</span><span style=color:#d69d85;>            push rax
</span><span style=color:#d69d85;>            push rcx
</span><span style=color:#d69d85;>            push rdx
</span><span style=color:#d69d85;>            push rsi
</span><span style=color:#d69d85;>            push rdi
</span><span style=color:#d69d85;>            push r8
</span><span style=color:#d69d85;>            push r9
</span><span style=color:#d69d85;>            push r10
</span><span style=color:#d69d85;>            push r11
</span><span style=color:#d69d85;>            // TODO: call exception handler with C calling convention
</span><span style=color:#d69d85;>            pop r11
</span><span style=color:#d69d85;>            pop r10
</span><span style=color:#d69d85;>            pop r9
</span><span style=color:#d69d85;>            pop r8
</span><span style=color:#d69d85;>            pop rdi
</span><span style=color:#d69d85;>            pop rsi
</span><span style=color:#d69d85;>            pop rdx
</span><span style=color:#d69d85;>            pop rcx
</span><span style=color:#d69d85;>            pop rax
</span><span style=color:#d69d85;>        " </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>This wrapper function saves all <em>scratch</em> registers to the stack before calling the exception handler and restores them afterwards. Note that we <code>pop</code> the registers in reverse order.<p>We don‚Äôt need to backup <em>preserved</em> registers since they are callee-saved in the C calling convention. Thus, the compiler already takes care of preserving their values.<h3 id=fixing-our-handler-macro><a aria-label="Anchor link for: fixing-our-handler-macro" class=zola-anchor href=#fixing-our-handler-macro>üîó</a>Fixing our Handler Macro</h3><p>Let‚Äôs update our handler macro to fix the calling convention problem. Therefore we need to backup and restore all scratch registers. For that we create two new macros:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! save_scratch_registers {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>{
</span><span>        asm!(</span><span style=color:#d69d85;>"push rax
</span><span style=color:#d69d85;>              push rcx
</span><span style=color:#d69d85;>              push rdx
</span><span style=color:#d69d85;>              push rsi
</span><span style=color:#d69d85;>              push rdi
</span><span style=color:#d69d85;>              push r8
</span><span style=color:#d69d85;>              push r9
</span><span style=color:#d69d85;>              push r10
</span><span style=color:#d69d85;>              push r11
</span><span style=color:#d69d85;>        " </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span>macro_rules! restore_scratch_registers {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>{
</span><span>        asm!(</span><span style=color:#d69d85;>"pop r11
</span><span style=color:#d69d85;>              pop r10
</span><span style=color:#d69d85;>              pop r9
</span><span style=color:#d69d85;>              pop r8
</span><span style=color:#d69d85;>              pop rdi
</span><span style=color:#d69d85;>              pop rsi
</span><span style=color:#d69d85;>              pop rdx
</span><span style=color:#d69d85;>              pop rcx
</span><span style=color:#d69d85;>              pop rax
</span><span style=color:#d69d85;>            " </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>We need to declare these macros <em>above</em> our <code>handler</code> macro, since macros are only available after their declaration.<p>Now we can use these macros to fix our <code>handler!</code> macro:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! handler {
</span><span>    ($name: ident) </span><span style=color:#569cd6;>=> </span><span>{{
</span><span>        #[naked]
</span><span>        </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>wrapper() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>            </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>                save_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"mov rdi, rsp
</span><span style=color:#d69d85;>                      add rdi, 9*8 // calculate exception stack frame pointer
</span><span style=color:#d69d85;>                      // sub rsp, 8 (stack is aligned already)
</span><span style=color:#d69d85;>                      call $0"
</span><span>                      :: </span><span style=color:#d69d85;>"i"</span><span>($name </span><span style=color:#569cd6;>as
</span><span>                             </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn</span><span>(</span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame))
</span><span>                      : </span><span style=color:#d69d85;>"rdi" </span><span>: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>
</span><span>                restore_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"
</span><span style=color:#d69d85;>                      // add rsp, 8 (undo stack alignment; not needed anymore)
</span><span style=color:#d69d85;>                      iretq"
</span><span>                      :::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>                ::core::intrinsics::unreachable();
</span><span>            }
</span><span>        }
</span><span>        wrapper
</span><span>    }}
</span><span>}
</span></code></pre><p>It‚Äôs important that we save the registers first, before we modify any of them. After the <code>call</code> instruction (but before <code>iretq</code>) we restore the registers again. Because we‚Äôre now changing <code>rsp</code> (by pushing the register values) before we load it into <code>rdi</code>, we would get a wrong exception stack frame pointer. Therefore we need to adjust it by adding the number of bytes we push. We push 9 registers that are 8 bytes each, so <code>9 * 8</code> bytes in total.<p>Note that we no longer need to manually align the stack pointer, because we‚Äôre pushing an uneven number of registers in <code>save_scratch_registers</code>. Thus the stack pointer already has the required 16-byte alignment.<h3 id=testing-it-again><a aria-label="Anchor link for: testing-it-again" class=zola-anchor href=#testing-it-again>üîó</a>Testing it again</h3><p>Let‚Äôs test it again with our corrected <code>handler!</code> macro:<p><img alt="QEMU output with EXCEPTION BREAKPOINT and It did not crash" src=qemu-breakpoint-return.png><p>The page fault is gone and we see the <em>‚ÄúIt did not crash‚Äù</em> message again!<p>So the page fault occurred because our exception handler didn‚Äôt preserve the scratch register <code>rax</code>. Our new <code>handler!</code> macro fixes this problem by saving all scratch registers (including <code>rax</code>) before calling exception handlers. Thus, <code>rax</code> still contains the valid memory address when <code>rust-main</code> continues execution.<h2 id=multimedia-registers><a aria-label="Anchor link for: multimedia-registers" class=zola-anchor href=#multimedia-registers>üîó</a>Multimedia Registers</h2><p>When we discussed calling conventions above, we assumed that a x86_64 CPU only has the following 16 registers: <code>rax</code>, <code>rbx</code>, <code>rcx</code>, <code>rdx</code>, <code>rsi</code>, <code>rdi</code>, <code>rsp</code>, <code>rbp</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code>.<code>r12</code>, <code>r13</code>, <code>r14</code>, and <code>r15</code>. These registers are called <em>general purpose registers</em> since each of them can be used for arithmetic and load/store instructions.<p>However, modern CPUs also have a set of <em>special purpose registers</em>, which can be used to improve performance in several use cases. On x86_64, the most important set of special purpose registers are the <em>multimedia registers</em>. These registers are larger than the general purpose registers and can be used to speed up audio/video processing or matrix calculations. For example, we could use them to add two 4-dimensional vectors <em>in a single CPU instruction</em>:<p><img alt="(1,2,3,4) + (5,6,7,8) = (6,8,10,12)" src=vector-addition.png><p>Such multimedia instructions are called <a href=https://en.wikipedia.org/wiki/SIMD>Single Instruction Multiple Data (SIMD)</a> instructions, because they simultaneously perform an operation (e.g. addition) on multiple data words. Good compilers are able to transform normal loops into such SIMD code automatically. This process is called <a href=https://en.wikipedia.org/wiki/Automatic_vectorization>auto-vectorization</a> and can lead to huge performance improvements.<p>However, auto-vectorization causes a problem for us: Most of the multimedia registers are caller-saved. According to our discussion of calling conventions above, this means that our exception handlers erroneously assume that they are allowed to overwrite them without preserving their values.<p>We don‚Äôt use any multimedia registers explicitly, but the Rust compiler might auto-vectorize our code (including the exception handlers). Thus we could silently clobber the multimedia registers, which leads to the same problems as above:<p><img alt="example: program uses mm0, mm1, and mm2. Then the exception handler clobbers mm1." src=xmm-overwrite.svg><p>This example shows a program that is using the first three multimedia registers (<code>mm0</code> to <code>mm2</code>). At some point, an exception occurs and control is transferred to the exception handler. The exception handler uses <code>mm1</code> for its own data and thus overwrites the previous value. When the exception is resolved, the CPU continues the interrupted program again. However, the program is now corrupt since it relies on the original <code>mm1</code> value.<h3 id=saving-and-restoring-multimedia-registers><a aria-label="Anchor link for: saving-and-restoring-multimedia-registers" class=zola-anchor href=#saving-and-restoring-multimedia-registers>üîó</a>Saving and Restoring Multimedia Registers</h3><p>In order to fix this problem, we need to backup all caller-saved multimedia registers before we call the exception handler. The problem is that the set of multimedia registers varies between CPUs. There are different standards:<ul><li><a href=https://en.wikipedia.org/wiki/MMX_(instruction_set)>MMX</a>: The MMX instruction set was introduced in 1997 and defines eight 64 bit registers called <code>mm0</code> through <code>mm7</code>. These registers are just aliases for the registers of the <a href=https://en.wikipedia.org/wiki/X87>x87 floating point unit</a>.<li><a href=https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions>SSE</a>: The <em>Streaming SIMD Extensions</em> instruction set was introduced in 1999. Instead of re-using the floating point registers, it adds a completely new register set. The sixteen new registers are called <code>xmm0</code> through <code>xmm15</code> and are 128 bits each.<li><a href=https://en.wikipedia.org/wiki/Advanced_Vector_Extensions>AVX</a>: The <em>Advanced Vector Extensions</em> are extensions that further increase the size of the multimedia registers. The new registers are called <code>ymm0</code> through <code>ymm15</code> and are 256 bits each. They extend the <code>xmm</code> registers, so e.g. <code>xmm0</code> is the lower (or upper?) half of <code>ymm0</code>.</ul><p>The Rust compiler (and LLVM) assume that the <code>x86_64-unknown-linux-gnu</code> target supports only MMX and SSE, so we don‚Äôt need to save the <code>ymm0</code> through <code>ymm15</code>. But we need to save <code>xmm0</code> through <code>xmm15</code> and also <code>mm0</code> through <code>mm7</code>. There is a special instruction to do this: <a href=https://www.felixcloutier.com/x86/fxsave>fxsave</a>. This instruction saves the floating point and multimedia state to a given address. It needs <em>512 bytes</em> to store that state.<p>In order to save/restore the multimedia registers, we <em>could</em> add new macros:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span>macro_rules! save_multimedia_registers {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>{
</span><span>        asm!(</span><span style=color:#d69d85;>"sub rsp, 512
</span><span style=color:#d69d85;>              fxsave [rsp]
</span><span style=color:#d69d85;>        " </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span><span>macro_rules! restore_multimedia_registers {
</span><span>    () </span><span style=color:#569cd6;>=> </span><span>{
</span><span>        asm!(</span><span style=color:#d69d85;>"fxrstor [rsp]
</span><span style=color:#d69d85;>              add rsp, 512
</span><span style=color:#d69d85;>            " </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>First, we reserve the 512 bytes on the stack and then we use <code>fxsave</code> to backup the multimedia registers. In order to restore them later, we use the <a href=https://www.felixcloutier.com/x86/fxrstor>fxrstor</a> instruction. Note that <code>fxsave</code> and <code>fxrstor</code> require a 16 byte aligned memory address.<p>However, <em>we won‚Äôt do it that way</em>. The problem is the large amount of memory required. We will reuse the same code when we handle hardware interrupts in a future post. So for each mouse click, pressed key, or arrived network package we need to write 512 bytes to memory. This would be a huge performance problem.<p>Fortunately, there exists an alternative solution.<h3 id=disabling-multimedia-extensions><a aria-label="Anchor link for: disabling-multimedia-extensions" class=zola-anchor href=#disabling-multimedia-extensions>üîó</a>Disabling Multimedia Extensions</h3><p>We just disable MMX, SSE, and all the other fancy multimedia extensions in our kernel<sup class=footnote-reference><a href=#fn-userspace-sse>1</a></sup>. This way, our exception handlers won‚Äôt clobber the multimedia registers because they won‚Äôt use them at all.<div class=footnote-definition id=fn-userspace-sse><sup class=footnote-definition-label>1</sup><p>Userspace programs will still be able to use the multimedia registers.</div><p>This solution has its own disadvantages, of course. For example, it leads to slower kernel code because the compiler can‚Äôt perform any auto-vectorization optimizations. But it‚Äôs still the faster solution (since we save many memory accesses) and most kernels do it this way (including Linux).<p>So how do we disable MMX and SSE? Well, we just tell the compiler that our target system doesn‚Äôt support it. Since the very beginning, we‚Äôre compiling our kernel for the <code>x86_64-unknown-linux-gnu</code> target. This worked fine so far, but now we want a different target without support for multimedia extensions. We can do so by creating a <em>target configuration file</em>.<h3 id=target-specifications><a aria-label="Anchor link for: target-specifications" class=zola-anchor href=#target-specifications>üîó</a>Target Specifications</h3><p>In order to disable the multimedia extensions for our kernel, we need to compile for a custom target. We want a target that is equal to <code>x86_64-unknown-linux-gnu</code>, but without MMX and SSE support. Rust allows us to specify such a target using a JSON configuration file.<p>A minimal target specification that describes the <code>x86_64-unknown-linux-gnu</code> target looks like this:<pre class=language-json data-lang=json style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-json data-lang=json><span>{
</span><span>  </span><span style=color:#d69d85;>"llvm-target"</span><span>: </span><span style=color:#d69d85;>"x86_64-unknown-linux-gnu"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"data-layout"</span><span>: </span><span style=color:#d69d85;>"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-endian"</span><span>: </span><span style=color:#d69d85;>"little"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-pointer-width"</span><span>: </span><span style=color:#d69d85;>"64"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-c-int-width"</span><span>: </span><span style=color:#d69d85;>"32"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"arch"</span><span>: </span><span style=color:#d69d85;>"x86_64"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"os"</span><span>: </span><span style=color:#d69d85;>"none"
</span><span>}
</span></code></pre><p>The <code>llvm-target</code> field specifies the target triple that is passed to LLVM. We want to derive a 64-bit Linux target, so we choose <code>x86_64-unknown-linux-gnu</code>. The <code>data-layout</code> field is also passed to LLVM and specifies how data should be laid out in memory. It consists of various specifications separated by a <code>-</code> character. For example, the <code>e</code> means little endian and <code>S128</code> specifies that the stack should be 128 bits (= 16 byte) aligned. The format is described in detail in the <a href=https://llvm.org/docs/LangRef.html#data-layout>LLVM documentation</a> but there shouldn‚Äôt be a reason to change this string.<p>The other fields are used for conditional compilation. This allows crate authors to use <code>cfg</code> variables to write special code for depending on the OS or the architecture. There isn‚Äôt any up-to-date documentation about these fields but the <a href=https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src/librustc_back/target/mod.rs#L194-L214>corresponding source code</a> is quite readable.<h4 id=disabling-mmx-and-sse><a aria-label="Anchor link for: disabling-mmx-and-sse" class=zola-anchor href=#disabling-mmx-and-sse>üîó</a>Disabling MMX and SSE</h4><p>In order to disable the multimedia extensions, we create a new target named <code>x86_64-blog_os</code>. To describe this target, we create a file named <code>x86_64-blog_os.json</code> in the project root with the following content:<pre class=language-json data-lang=json style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-json data-lang=json><span>{
</span><span>  </span><span style=color:#d69d85;>"llvm-target"</span><span>: </span><span style=color:#d69d85;>"x86_64-unknown-linux-gnu"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"data-layout"</span><span>: </span><span style=color:#d69d85;>"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-endian"</span><span>: </span><span style=color:#d69d85;>"little"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-pointer-width"</span><span>: </span><span style=color:#d69d85;>"64"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"target-c-int-width"</span><span>: </span><span style=color:#d69d85;>"32"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"arch"</span><span>: </span><span style=color:#d69d85;>"x86_64"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"os"</span><span>: </span><span style=color:#d69d85;>"none"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"features"</span><span>: </span><span style=color:#d69d85;>"-mmx,-sse"
</span><span>}
</span></code></pre><p>It‚Äôs equal to <code>x86_64-unknown-linux-gnu</code> target but has one additional option: <code>"features": "-mmx,-sse"</code>. So we added two target <em>features</em>: <code>-mmx</code> and <code>-sse</code>. The minus prefix defines that our target does <em>not</em> support this feature. So by specifying <code>-mmx</code> and <code>-sse</code>, we disable the default <code>mmx</code> and <code>sse</code> features.<p>In order to compile for the new target, we need to adjust our Makefile:<pre class=language-diff data-lang=diff style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-diff data-lang=diff><span># in `Makefile`
</span><span>
</span><span> arch ?= x86_64
</span><span>-target ?= $(arch)-unknown-linux-gnu
</span><span>+target ?= $(arch)-blog_os
</span><span>...
</span></code></pre><p>The new target name (<code>x86_64-blog_os</code>) is the file name of the JSON configuration file without the <code>.json</code> extension.<h3 id=cross-compilation><a aria-label="Anchor link for: cross-compilation" class=zola-anchor href=#cross-compilation>üîó</a>Cross compilation</h3><p>Let‚Äôs try if our kernel still works with the new target:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> make run
</span><span>Compiling raw-cpuid v2.0.1
</span><span>Compiling rlibc v0.1.5
</span><span>Compiling x86 v0.7.1
</span><span>Compiling spin v0.3.5
</span><span>error[E0463]: can't find crate for `core`
</span><span>
</span><span>error: aborting due to previous error
</span><span>
</span><span>Build failed, waiting for other jobs to finish...
</span><span>...
</span><span>Makefile:52: recipe for target 'cargo' failed
</span><span>make: *** [cargo] Error 101
</span></code></pre><p>It doesn‚Äôt compile anymore. The error tells us that the Rust compiler no longer finds the core library.<p>The <a href=https://doc.rust-lang.org/nightly/core/index.html>core library</a> is implicitly linked to all <code>no_std</code> crates and contains things such as <code>Result</code>, <code>Option</code>, and iterators. We‚Äôve used that library without problems since <a href=https://os.phil-opp.com/set-up-rust/>the very beginning</a>, so why is it no longer available?<p>The problem is that the core library is distributed together with the Rust compiler as a <em>precompiled</em> library. So it is only valid for the host triple, which is <code>x86_64-unknown-linux-gnu</code> in our case. If we want to compile code for other targets, we need to recompile <code>core</code> for these targets first.<h4 id=xargo><a aria-label="Anchor link for: xargo" class=zola-anchor href=#xargo>üîó</a>Xargo</h4><p>That‚Äôs where <a href=https://github.com/japaric/xargo>xargo</a> comes in. It is a wrapper for cargo that eases cross compilation. We can install it by executing:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>cargo install xargo
</span></code></pre><p>Xargo depends on the rust source code, which we can install with <code>rustup component add rust-src</code>.<p>Xargo is ‚Äúa drop-in replacement for cargo‚Äù, so every cargo command also works with <code>xargo</code>. You can do e.g. <code>xargo --help</code>, <code>xargo clean</code>, or <code>xargo doc</code>. However, the <code>build</code> command gains additional functionality: <code>xargo build</code> will automatically cross compile the <code>core</code> library when compiling for custom targets.<p>That‚Äôs exactly what we want, so we change one letter in our Makefile:<pre class=language-diff data-lang=diff style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-diff data-lang=diff><span># in `Makefile`
</span><span>...
</span><span>
</span><span>cargo:
</span><span>-	@cargo build --target $(target)
</span><span>+	@xargo build --target $(target)
</span><span>...
</span></code></pre><p>Now the build goes through <code>xargo</code>, which should fix the compilation error. Let‚Äôs try it out:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> make run
</span><span>Compiling core v0.0.0 (file:///home/‚Ä¶/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
</span><span>LLVM ERROR: SSE register return with SSE disabled
</span><span>error: Could not compile `core`.
</span></code></pre><p>Well, we get a different error now, so it seems like we‚Äôre making progress :). It seems like there is a ‚ÄúSSE register return‚Äù although SSE is disabled. But what‚Äôs an ‚ÄúSSE register return‚Äù?<h3 id=sse-register-return><a aria-label="Anchor link for: sse-register-return" class=zola-anchor href=#sse-register-return>üîó</a>SSE Register Return</h3><p>Remember when we discussed calling conventions above? The calling convention defines which registers are used for return values. Well, the <a href=https://refspecs.linuxbase.org/elf/gabi41.pdf>System V ABI</a> defines that <code>xmm0</code> should be used for returning floating point values. So somewhere in the <code>core</code> library a function returns a float and LLVM doesn‚Äôt know what to do. The ABI says ‚Äúuse <code>xmm0</code>‚Äù but the target specification says ‚Äúdon‚Äôt use <code>xmm</code> registers‚Äù.<p>In order to fix this problem, we need to change our float ABI. The idea is to avoid normal hardware-supported floats and use a pure software implementation instead. We can do so by enabling the <code>soft-float</code> feature for our target. For that, we edit <code>x86_64-blog_os.json</code>:<pre class=language-json data-lang=json style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-json data-lang=json><span>{
</span><span>  </span><span style=color:#d69d85;>"llvm-target"</span><span>: </span><span style=color:#d69d85;>"x86_64-unknown-linux-gnu"</span><span>,
</span><span>  </span><span style=color:#ff3333;>...
</span><span>  </span><span style=color:#d69d85;>"features"</span><span>: </span><span style=color:#d69d85;>"-mmx,-sse,+soft-float"
</span><span>}
</span></code></pre><p>The plus prefix tells LLVM to enable the <code>soft-float</code> feature.<p>Let‚Äôs try <code>make run</code> again:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> make run
</span><span>   Compiling core v0.0.0 (file:///‚Ä¶/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
</span><span>    Finished release [optimized] target(s) in 21.95 secs
</span><span>   Compiling spin v0.4.5
</span><span>   Compiling once v0.3.2
</span><span>   Compiling x86 v0.8.0
</span><span>   Compiling bitflags v0.9.1
</span><span>   Compiling raw-cpuid v2.0.1
</span><span>   Compiling rlibc v0.1.5
</span><span>   Compiling linked_list_allocator v0.2.3
</span><span>   Compiling volatile v0.1.0
</span><span>   Compiling bitflags v0.4.0
</span><span>   Compiling bit_field v0.5.0
</span><span>   Compiling spin v0.3.5
</span><span>   Compiling multiboot2 v0.1.0
</span><span>   Compiling lazy_static v0.2.2
</span><span>   Compiling hole_list_allocator v0.1.0 (file:///‚Ä¶/libs/hole_list_allocator)
</span><span>   Compiling blog_os v0.1.0 (file:///‚Ä¶)
</span><span>error[E0463]: can't find crate for `alloc`
</span><span>  --> src/lib.rs:33:1
</span><span>   |
</span><span>33 | extern crate alloc;
</span><span>   | ^^^^^^^^^^^^^^^^^^^ can't find crate
</span><span>
</span><span>error: aborting due to previous error
</span></code></pre><p>We see that <code>xargo</code> now compiles the <code>core</code> crate in release mode. Then it starts the normal cargo build. Cargo then recompiles all dependencies, since it needs to generate different code for the new target.<p>However, the build still fails. The reason is that xargo only installs <code>core</code> by default, but we also need the <code>alloc</code> crate. We can enable it by creating a file named <code>Xargo.toml</code> with the following contents:<pre class=language-toml data-lang=toml style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-toml data-lang=toml><span style=color:#608b4e;># Xargo.toml
</span><span>
</span><span>[</span><span style=color:#808080;>target.x86_64-blog_os.dependencies</span><span>]
</span><span style=color:#569cd6;>alloc </span><span>= {}
</span></code></pre><p>Now xargo compiles <code>alloc</code>, too:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> make run
</span><span>   Compiling core v0.0.0 (file:///‚Ä¶/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore)
</span><span>   Compiling std_unicode v0.0.0 (file:///‚Ä¶/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd_unicode)
</span><span>   Compiling alloc v0.0.0 (file:///‚Ä¶/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/liballoc)
</span><span>    Finished release [optimized] target(s) in 28.84 secs
</span><span>   Compiling blog_os v0.1.0 (file:///‚Ä¶/Documents/blog_os/master)
</span><span>warning: unused variable: `allocator` [‚Ä¶]
</span><span>warning: unused variable: `frame` [‚Ä¶]
</span><span>
</span><span>    Finished debug [unoptimized + debuginfo] target(s) in 1.75 secs
</span></code></pre><p>It worked! Now we have a kernel that never touches the multimedia registers! We can verify this by executing:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>> objdump -d build/kernel-x86_64.bin | grep "mm[0-9]"
</span></code></pre><p>If the command produces no output, our kernel uses neither MMX (<code>mm0</code> ‚Äì <code>mm7</code>) nor SSE (<code>xmm0</code> ‚Äì <code>xmm15</code>) registers.<p>So now our return-from-exception logic works without problems in <em>most</em> cases. However, there is still a pitfall hidden in the C calling convention, which might cause hideous bugs in some rare cases.<h2 id=the-red-zone><a aria-label="Anchor link for: the-red-zone" class=zola-anchor href=#the-red-zone>üîó</a>The Red Zone</h2><p>The <a href=https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64#the-red-zone>red zone</a> is an optimization of the <a href=https://refspecs.linuxbase.org/elf/gabi41.pdf>System V ABI</a> that allows functions to temporary use the 128 bytes below its stack frame without adjusting the stack pointer:<p><img alt="stack frame with red zone" src=red-zone.svg><p>The image shows the stack frame of a function with <code>n</code> local variables. On function entry, the stack pointer is adjusted to make room on the stack for the local variables.<p>The red zone is defined as the 128 bytes below the adjusted stack pointer. The function can use this area for temporary data that‚Äôs not needed across function calls. Thus, the two instructions for adjusting the stack pointer can be avoided in some cases (e.g. in small leaf functions).<p>However, this optimization leads to huge problems with exceptions. Let‚Äôs assume that an exception occurs while a function uses the red zone:<p><img alt="red zone overwritten by exception handler" src=red-zone-overwrite.svg><p>The CPU and the exception handler overwrite the data in red zone. But this data is still needed by the interrupted function. So the function won‚Äôt work correctly anymore when we return from the exception handler. It might fail or cause another exception, but it could also lead to strange bugs that <a href="https://forum.osdev.org/viewtopic.php?t=21720">take weeks to debug</a>.<h3 id=adjusting-our-exception-handler><a aria-label="Anchor link for: adjusting-our-exception-handler" class=zola-anchor href=#adjusting-our-exception-handler>üîó</a>Adjusting our Exception Handler?</h3><p>The problem is that the <a href=https://refspecs.linuxbase.org/elf/gabi41.pdf>System V ABI</a> demands that the red zone <em>‚Äúshall not be modified by signal or interrupt handlers.‚Äù</em> Our current exception handlers do not respect this. We could try to fix it by subtracting 128 from the stack pointer before pushing anything:<pre class=language-nasm data-lang=nasm style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-nasm data-lang=nasm><span style=color:#569cd6;>sub </span><span>rsp, </span><span style=color:#b4cea8;>128
</span><span>save_scratch_registers()
</span><span>...
</span><span style=color:#569cd6;>call </span><span>...
</span><span>...
</span><span>restore_scratch_registers()
</span><span style=color:#569cd6;>add </span><span>rsp, </span><span style=color:#b4cea8;>128
</span><span>
</span><span style=color:#569cd6;>iretq
</span></code></pre><p><em>This will not work.</em> The problem is that the CPU pushes the exception stack frame before even calling our handler function. So the CPU itself will clobber the red zone and there is nothing we can do about that. So our only chance is to disable the red zone.<h3 id=disabling-the-red-zone><a aria-label="Anchor link for: disabling-the-red-zone" class=zola-anchor href=#disabling-the-red-zone>üîó</a>Disabling the Red Zone</h3><p>The red zone is a property of our target, so in order to disable it we edit our <code>x86_64-blog_os.json</code> a last time:<pre class=language-json data-lang=json style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-json data-lang=json><span>{
</span><span>  </span><span style=color:#d69d85;>"llvm-target"</span><span>: </span><span style=color:#d69d85;>"x86_64-unknown-linux-gnu"</span><span>,
</span><span>  </span><span style=color:#ff3333;>...
</span><span>  </span><span style=color:#d69d85;>"features"</span><span>: </span><span style=color:#d69d85;>"-mmx,-sse,+soft-float"</span><span>,
</span><span>  </span><span style=color:#d69d85;>"disable-redzone"</span><span>: </span><span style=color:#569cd6;>true
</span><span>}
</span></code></pre><p>We add one additional option at the end: <code>"disable-redzone": true</code>. As you might guess, this option disables the red zone optimization.<p>Now we have a red zone free kernel!<h2 id=exceptions-with-error-codes><a aria-label="Anchor link for: exceptions-with-error-codes" class=zola-anchor href=#exceptions-with-error-codes>üîó</a>Exceptions with Error Codes</h2><p>We‚Äôre now able to correctly return from exceptions without error codes. However, we still can‚Äôt return from exceptions that push an error code (e.g. page faults). Let‚Äôs fix that by updating our <code>handler_with_error_code</code> macro:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! handler_with_error_code {
</span><span>    ($name: ident) </span><span style=color:#569cd6;>=> </span><span>{{
</span><span>        #[naked]
</span><span>        </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>wrapper() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>            </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>                asm!(</span><span style=color:#d69d85;>"pop rsi // pop error code into rsi
</span><span style=color:#d69d85;>                      mov rdi, rsp
</span><span style=color:#d69d85;>                      sub rsp, 8 // align the stack pointer
</span><span style=color:#d69d85;>                      call $0"
</span><span>                      :: </span><span style=color:#d69d85;>"i"</span><span>($name </span><span style=color:#569cd6;>as extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn</span><span>(
</span><span>                          </span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame, </span><span style=color:#569cd6;>u64</span><span>))
</span><span>                      : </span><span style=color:#d69d85;>"rdi"</span><span>,</span><span style=color:#d69d85;>"rsi" </span><span>: </span><span style=color:#d69d85;>"intel"</span><span>);
</span><span>                asm!(</span><span style=color:#d69d85;>"iretq" </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>                ::core::intrinsics::unreachable();
</span><span>            }
</span><span>        }
</span><span>        wrapper
</span><span>    }}
</span><span>}
</span></code></pre><p>First, we change the type of the handler function: no more <code>-> !</code>, so it no longer needs to diverge. We also add an <code>iretq</code> instruction at the end.<p>Now we can make our <code>page_fault_handler</code> non-diverging:<pre class=language-diff data-lang=diff style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-diff data-lang=diff><span>// in src/interrupts/mod.rs
</span><span>
</span><span> extern "C" fn page_fault_handler(stack_frame: &ExceptionStackFrame,
</span><span>-   error_code: u64) -> ! { ... }
</span><span>+   error_code: u64) { ... }
</span></code></pre><p>However, now we have the same problem as above: The handler function will overwrite the scratch registers and cause bugs when returning. Let‚Äôs fix this by invoking <code>save_scratch_registers</code> at the beginning:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! handler_with_error_code {
</span><span>    ($name: ident) </span><span style=color:#569cd6;>=> </span><span>{{
</span><span>        #[naked]
</span><span>        </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>wrapper() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>            </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>                save_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"pop rsi // pop error code into rsi
</span><span style=color:#d69d85;>                      mov rdi, rsp
</span><span style=color:#d69d85;>                      add rdi, 10*8 // calculate exception stack frame pointer
</span><span style=color:#d69d85;>                      sub rsp, 8 // align the stack pointer
</span><span style=color:#d69d85;>                      call $0
</span><span style=color:#d69d85;>                      add rsp, 8 // undo stack pointer alignment
</span><span style=color:#d69d85;>                      " </span><span>:: </span><span style=color:#d69d85;>"i"</span><span>($name </span><span style=color:#569cd6;>as extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn</span><span>(
</span><span>                          </span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame, </span><span style=color:#569cd6;>u64</span><span>))
</span><span>                      : </span><span style=color:#d69d85;>"rdi"</span><span>,</span><span style=color:#d69d85;>"rsi" </span><span>: </span><span style=color:#d69d85;>"intel"</span><span>);
</span><span>                restore_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"iretq" </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>                ::core::intrinsics::unreachable();
</span><span>            }
</span><span>        }
</span><span>        wrapper
</span><span>    }}
</span><span>}
</span></code></pre><p>Now we backup the scratch registers to the stack right at the beginning and restore them just before the <code>iretq</code>. Like in the <code>handler</code> macro, we now need to add <code>10*8</code> to <code>rdi</code> in order to get the correct exception stack frame pointer (<code>save_scratch_registers</code> pushes nine 8 byte registers, plus the error code). We also need to undo the stack pointer alignment after the <code>call</code> <sup class=footnote-reference><a href=#fn-stack-alignment>2</a></sup>.<div class=footnote-definition id=fn-stack-alignment><sup class=footnote-definition-label>2</sup><p>The stack alignment is actually wrong here, since we additionally pushed an uneven number of registers. However, the <code>pop rsi</code> is wrong too, since the error code is no longer at the top of the stack. When we fix that problem, the stack alignment becomes correct again. So I left it in to keep things simple.</div><p>Now we have one last bug: We <code>pop</code> the error code into <code>rsi</code>, but the error code is no longer at the top of the stack (since <code>save_scratch_registers</code> pushed 9 registers on top of it). So we need to do it differently:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in src/interrupts/mod.rs
</span><span>
</span><span>macro_rules! handler_with_error_code {
</span><span>    ($name: ident) </span><span style=color:#569cd6;>=> </span><span>{{
</span><span>        #[naked]
</span><span>        </span><span style=color:#569cd6;>extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn </span><span>wrapper() -> </span><span style=color:#569cd6;>! </span><span>{
</span><span>            </span><span style=color:#569cd6;>unsafe </span><span>{
</span><span>                save_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"mov rsi, [rsp + 9*8] // load error code into rsi
</span><span style=color:#d69d85;>                      mov rdi, rsp
</span><span style=color:#d69d85;>                      add rdi, 10*8 // calculate exception stack frame pointer
</span><span style=color:#d69d85;>                      sub rsp, 8 // align the stack pointer
</span><span style=color:#d69d85;>                      call $0
</span><span style=color:#d69d85;>                      add rsp, 8 // undo stack pointer alignment
</span><span style=color:#d69d85;>                      " </span><span>:: </span><span style=color:#d69d85;>"i"</span><span>($name </span><span style=color:#569cd6;>as extern </span><span style=color:#d69d85;>"C" </span><span style=color:#569cd6;>fn</span><span>(
</span><span>                          </span><span style=color:#569cd6;>&</span><span>ExceptionStackFrame, </span><span style=color:#569cd6;>u64</span><span>))
</span><span>                      : </span><span style=color:#d69d85;>"rdi"</span><span>,</span><span style=color:#d69d85;>"rsi" </span><span>: </span><span style=color:#d69d85;>"intel"</span><span>);
</span><span>                restore_scratch_registers!();
</span><span>                asm!(</span><span style=color:#d69d85;>"add rsp, 8 // pop error code
</span><span style=color:#d69d85;>                      iretq" </span><span>:::: </span><span style=color:#d69d85;>"intel"</span><span>, </span><span style=color:#d69d85;>"volatile"</span><span>);
</span><span>                ::core::intrinsics::unreachable();
</span><span>            }
</span><span>        }
</span><span>        wrapper
</span><span>    }}
</span><span>}
</span></code></pre><p>Instead of using <code>pop</code>, we‚Äôre calculating the error code address manually (<code>save_scratch_registers</code> pushes nine 8 byte registers) and load it into <code>rsi</code> using a <code>mov</code>. So now the error code stays on the stack. But <code>iretq</code> doesn‚Äôt handle the error code, so we need to pop it before invoking <code>iretq</code>.<p>Phew! That was a lot of fiddling with assembly. Let‚Äôs test if it still works.<h3 id=testing-1><a aria-label="Anchor link for: testing-1" class=zola-anchor href=#testing-1>üîó</a>Testing</h3><p>First, we test if the exception stack frame pointer and the error code are still correct:<pre class=language-rust data-lang=rust style=background-color:#1e1e1e;color:#dcdcdc;><code class=language-rust data-lang=rust><span style=color:#608b4e;>// in rust_main in src/lib.rs
</span><span>
</span><span style=color:#569cd6;>...
</span><span style=color:#569cd6;>unsafe </span><span>{ int!(</span><span style=color:#b5cea8;>3</span><span>) };
</span><span>
</span><span style=color:#608b4e;>// provoke a page fault
</span><span style=color:#569cd6;>unsafe </span><span>{ *(</span><span style=color:#b5cea8;>0xdeadbeaf </span><span style=color:#569cd6;>as *mut u64</span><span>) = </span><span style=color:#b5cea8;>42</span><span>; }
</span><span>
</span><span>println!(</span><span style=color:#d69d85;>"It did not crash!"</span><span>);
</span><span style=color:#569cd6;>loop </span><span>{}
</span></code></pre><p>This should cause the following error message:<pre style=background-color:#1e1e1e;color:#dcdcdc;><code><span>EXCEPTION: PAGE FAULT while accessing 0xdeadbeaf
</span><span>error code: CAUSED_BY_WRITE
</span><span>ExceptionStackFrame {
</span><span>    instruction_pointer: 1114753,
</span><span>    code_segment: 8,
</span><span>    cpu_flags: 2097158,
</span><span>    stack_pointer: 1171104,
</span><span>    stack_segment: 16
</span><span>}
</span></code></pre><p>The error code should still be <code>CAUSED_BY_WRITE</code> and the exception stack frame values should also be correct (e.g. <code>code_segment</code> should be 8 and <code>stack_segment</code> should be 16).<h4 id=returning-from-page-faults><a aria-label="Anchor link for: returning-from-page-faults" class=zola-anchor href=#returning-from-page-faults>üîó</a>Returning from Page Faults</h4><p>Let‚Äôs see what happens if we comment out the trailing <code>loop</code> in our page fault handler:<p><img alt="QEMU printing the same page fault message again and again" src=qemu-page-fault-return.png><p>We see that the same error message is printed over and over again. Here is what happens:<ul><li>The CPU executes <code>rust_main</code> and tries to access <code>0xdeadbeaf</code>. This causes a page fault.<li>The page fault handler prints an error message and returns without fixing the cause of the exception (<code>0xdeadbeaf</code> is still unaccessible).<li>The CPU restarts the instruction that caused the page fault and thus tries to access <code>0xdeadbeaf</code> again. Of course, this causes a page fault again.<li>The page fault handler prints the error message and returns.</ul><p>‚Ä¶ and so on. Thus, our code indefinitely jumps between the page fault handler and the instruction that accesses <code>0xdeadbeaf</code>.<p>This is a good thing! It means that our <code>iretq</code> logic is working correctly, since it returns to the correct instruction every time. So our <code>handler_with_error_code</code> macro seems to be correct.<h2 id=what-s-next><a aria-label="Anchor link for: what-s-next" class=zola-anchor href=#what-s-next>üîó</a>What‚Äôs next?</h2><p>We are now able to catch exceptions and to return from them. However, there are still exceptions that completely crash our kernel by causing a <a href=https://en.wikipedia.org/wiki/Triple_fault>triple fault</a>. In the next post, we will fix this issue by handling a special type of exception: the <a href=https://en.wikipedia.org/wiki/Double_fault>double fault</a>. Thus, we will be able to avoid random reboots in our kernel.</main><div><hr><div class=PageNavigation><a class=prev href=/better-exception-messages/>¬´ Better Exception Messages</a></div><hr><section><h2>Comments (Archived)</h2><section id=isso-thread><div id=isso-root><div class="isso-comment isso-no-votes" id=isso-218><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=666df3217240 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=20 y=12></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Philipp Oppermann</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-218 rel=nofollow><time title="Thu Sep 22 2016 11:53:29 GMT+0200 (Central European Summer Time)" datetime=2016-08-04T09:53:29Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>There are also great comments on <a href="https://news.ycombinator.com/item?id=12548066" rel=nofollow>hackernews</a> and <a href=https://www.reddit.com/r/rust/comments/53t6zv/writing_an_os_in_rust_returning_from_exceptions/ rel=nofollow>/r/rust</a>!</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div><div class="isso-comment isso-no-votes" id=isso-219><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=60f87e74c51c shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #be5168" height=8 width=8 x=4 y=20></rect><rect style="fill: #be5168" height=8 width=8 x=36 y=20></rect><rect style="fill: #be5168" height=8 width=8 x=4 y=28></rect><rect style="fill: #be5168" height=8 width=8 x=36 y=28></rect><rect style="fill: #be5168" height=8 width=8 x=12 y=20></rect><rect style="fill: #be5168" height=8 width=8 x=28 y=20></rect><rect style="fill: #be5168" height=8 width=8 x=12 y=36></rect><rect style="fill: #be5168" height=8 width=8 x=28 y=36></rect><rect style="fill: #be5168" height=8 width=8 x=20 y=28></rect><rect style="fill: #be5168" height=8 width=8 x=20 y=36></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>SmallEgg</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-219 rel=nofollow><time title="Sat Sep 24 2016 19:02:32 GMT+0200 (Central European Summer Time)" datetime=2016-08-06T17:02:32Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Wohoooo ! New post ! o/</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div><div class="isso-comment isso-no-votes" id=isso-220><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=046dc8da1607 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #447c69" height=8 width=8 x=4 y=4></rect><rect style="fill: #447c69" height=8 width=8 x=36 y=4></rect><rect style="fill: #447c69" height=8 width=8 x=12 y=4></rect><rect style="fill: #447c69" height=8 width=8 x=28 y=4></rect><rect style="fill: #447c69" height=8 width=8 x=12 y=20></rect><rect style="fill: #447c69" height=8 width=8 x=28 y=20></rect><rect style="fill: #447c69" height=8 width=8 x=12 y=28></rect><rect style="fill: #447c69" height=8 width=8 x=28 y=28></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>cshnc</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-220 rel=nofollow><time title="Sun Sep 25 2016 00:37:17 GMT+0200 (Central European Summer Time)" datetime=2016-08-06T22:37:17Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Great!</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div><div class="isso-comment isso-no-votes" id=isso-221><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=8dec010e6542 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=4></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=4></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=28></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=28></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=12 y=20></rect><rect style="fill: #e279a3" height=8 width=8 x=28 y=20></rect><rect style="fill: #e279a3" height=8 width=8 x=12 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=28 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=20 y=12></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Hoschi</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-221 rel=nofollow><time title="Mon Oct 31 2016 21:30:46 GMT+0100 (Central European Standard Time)" datetime=2016-09-01T20:30:46Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Hi everybody!<p>When I try to modify the page fault handler to define accesses to 0xdeadbeaf as legal, I get an error for this line:<p>let stack_frame = &mut *(stack_frame as *mut ExceptionStackFrame);<p>error: casting `&interrupts::ExceptionStackFrame` as `*mut interrupts::ExceptionStackFrame` is invalid<p>Thanks in advance!<p>Christian</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up><div class="isso-comment isso-no-votes" id=isso-223><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=666df3217240 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=20 y=12></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Philipp Oppermann</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-223 rel=nofollow><time title="Thu Nov 03 2016 16:48:34 GMT+0100 (Central European Standard Time)" datetime=2016-10-04T15:48:34Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Hmm, I've updated this post two days ago and removed this section. Before that, we used to take stack_frame as *const pointer. Since the update, we take stack_frame as & reference, which makes the cast illegal.<p>But this doesn't make any sense since I've pushed this update after your comment?..</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div><div class="isso-comment isso-no-votes" id=isso-224><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=8dec010e6542 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=4></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=4></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=28></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=28></rect><rect style="fill: #e279a3" height=8 width=8 x=4 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=36 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=12 y=20></rect><rect style="fill: #e279a3" height=8 width=8 x=28 y=20></rect><rect style="fill: #e279a3" height=8 width=8 x=12 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=28 y=36></rect><rect style="fill: #e279a3" height=8 width=8 x=20 y=12></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Hoschi</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-224 rel=nofollow><time title="Fri Nov 04 2016 15:15:18 GMT+0100 (Central European Standard Time)" datetime=2016-10-05T14:15:18Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Hi! I tested it before your changes. I cannot find the illegal cast anymore. Thanks for your reply!</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div></div></div></div><div class="isso-comment isso-no-votes" id=isso-222><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=398b1c02daf5 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=20></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=20></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=12 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=28 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=12 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=28 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=12 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=28 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=20></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=28></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Niklas R</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-222 rel=nofollow><time title="Thu Nov 03 2016 12:34:36 GMT+0100 (Central European Standard Time)" datetime=2016-10-04T11:34:36Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>This is impressive work and pedagogical. Phil, how long time did it take to acquire the necessary technical knowledge and what did you do to achieve this technical competence?</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up><div class=isso-comment id=isso-226><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=666df3217240 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=12></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=4 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=36 y=36></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=4></rect><rect style="fill: #9abf88" height=8 width=8 x=12 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=28 y=28></rect><rect style="fill: #9abf88" height=8 width=8 x=20 y=12></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Philipp Oppermann</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-226 rel=nofollow><time title="Mon Nov 07 2016 09:30:04 GMT+0100 (Central European Standard Time)" datetime=2016-10-01T08:30:04Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Thanks a lot!<p>I took (and still take) some operating system classes at university. However, most of the details of these posts I learned from various blogs, tutorials, and wikis (e.g. the awesome OSDev wiki). The x86 details come from the official manuals from AMD and Intel.<p>I started my own little toy kernels a few years ago, at first in C. At some point I discovered Rust. It was still highly unstable at that time, but I loved to play with it and I learned a lot.<p>So I think that I learned most things from writing my own toy kernels and experimenting with them.</div><div class=isso-comment-footer><span class=votes>1</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div></div></div></div><div class="isso-comment isso-no-votes" id=isso-225><div class=avatar><svg preserveaspectratio="xMinYMin meet" viewbox="0 0 48 48" data-hash=9fd3149742d5 shape-rendering=crispEdges version=1.1><rect style="fill: #f0f0f0" height=56 width=56 x=0 y=0></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=4 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=36 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=12 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=28 y=28></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=4></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=12></rect><rect style="fill: #f19670" height=8 width=8 x=20 y=28></rect></svg></div><div class=text-wrapper><div class=isso-comment-header role=meta><span class=author>Adam Brown</span><span class=spacer>‚Ä¢</span><a class=permalink href=#isso-225 rel=nofollow><time title="Fri Nov 04 2016 22:53:08 GMT+0100 (Central European Standard Time)" datetime=2016-10-05T21:53:08Z>vor 3 Jahren</time></a><span class=note></span></div><div class=text><p>Wow this is awesome, looking forward to following this.</div><div class=isso-comment-footer><span class=votes>0</span><a class=upvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,18.299c-0.651-0.669-7.512-7.203-7.512-7.203C 16.912,10.739, 16.456,10.56, 16,10.56c-0.458,0-0.914,0.179-1.261,0.536 c0,0-6.861,6.534-7.514,7.203c-0.651,0.669-0.696,1.872,0,2.586c 0.698,0.712, 1.669,0.77, 2.522,0L 16,14.89l 6.251,5.995 c 0.854,0.77, 1.827,0.712, 2.522,0C 25.47,20.17, 25.427,18.966, 24.773,18.299z"> </path> </g> </svg> </a><span class=spacer>|</span><a class=downvote href=# rel=nofollow><svg viewbox="0 0 32 32" fill=gray height=16 width=16 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink> <g> <path d="M 24.773,13.701c-0.651,0.669-7.512,7.205-7.512,7.205C 16.912,21.262, 16.456,21.44, 16,21.44c-0.458,0-0.914-0.178-1.261-0.534 c0,0-6.861-6.536-7.514-7.205c-0.651-0.669-0.696-1.87,0-2.586c 0.698-0.714, 1.669-0.77, 2.522,0L 16,17.112l 6.251-5.995 c 0.854-0.77, 1.827-0.714, 2.522,0C 25.47,11.83, 25.427,13.034, 24.773,13.701z"> </path> </g> </svg> </a><a class=reply href=# rel=nofollow>Antworten</a></div><div class=isso-follow-up></div></div></div></div></section></section></div><footer class=footer><hr><small> ¬© <time datetime=2017>2017</time>. All rights reserved. <a href=https://os.phil-opp.com/contact/>Contact</a> </small></footer></div><script async data-goatcounter=https://phil-opp.goatcounter.com/count src=//gc.zgo.at/count.js></script>